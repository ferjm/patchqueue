# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Parent  dd736514d9d22ebdc209aef79859cc87100b8073
Bug 1350175 - Part 3: Set source position for style, page, namespace, media, supports and font-face. r?SimonSapin

diff --git a/layout/style/ServoBindings.cpp b/layout/style/ServoBindings.cpp
--- a/layout/style/ServoBindings.cpp
+++ b/layout/style/ServoBindings.cpp
@@ -1946,19 +1946,19 @@ Gecko_CSSKeywordString(nsCSSKeyword aKey
   MOZ_ASSERT(NS_IsMainThread());
   MOZ_ASSERT(aLength);
   const nsAFlatCString& value = nsCSSKeywords::GetStringValue(aKeyword);
   *aLength = value.Length();
   return value.get();
 }
 
 nsCSSFontFaceRule*
-Gecko_CSSFontFaceRule_Create()
+Gecko_CSSFontFaceRule_Create(uint32_t aLine, uint32_t aColumn)
 {
-  RefPtr<nsCSSFontFaceRule> rule = new nsCSSFontFaceRule(0, 0);
+  RefPtr<nsCSSFontFaceRule> rule = new nsCSSFontFaceRule(aLine, aColumn);
   return rule.forget().take();
 }
 
 void
 Gecko_CSSFontFaceRule_GetCssText(const nsCSSFontFaceRule* aRule,
                                  nsAString* aResult)
 {
   // GetCSSText serializes nsCSSValues, which have a heap write
diff --git a/layout/style/ServoBindings.h b/layout/style/ServoBindings.h
--- a/layout/style/ServoBindings.h
+++ b/layout/style/ServoBindings.h
@@ -463,17 +463,17 @@ void InitializeServo();
 void ShutdownServo();
 
 const nsMediaFeature* Gecko_GetMediaFeatures();
 nsCSSKeyword Gecko_LookupCSSKeyword(const uint8_t* string, uint32_t len);
 const char* Gecko_CSSKeywordString(nsCSSKeyword keyword, uint32_t* len);
 
 // Font face rule
 // Creates and returns a new (already-addrefed) nsCSSFontFaceRule object.
-nsCSSFontFaceRule* Gecko_CSSFontFaceRule_Create();
+nsCSSFontFaceRule* Gecko_CSSFontFaceRule_Create(uint32_t line, uint32_t column);
 void Gecko_CSSFontFaceRule_GetCssText(const nsCSSFontFaceRule* rule, nsAString* result);
 NS_DECL_FFI_REFCOUNTING(nsCSSFontFaceRule, CSSFontFaceRule);
 
 RawGeckoElementBorrowedOrNull Gecko_GetBody(RawGeckoPresContextBorrowed pres_context);
 
 // We use an int32_t here instead of a LookAndFeel::ColorID
 // because forward-declaring a nested enum/struct is impossible
 nscolor Gecko_GetLookAndFeelSystemColor(int32_t color_id,
diff --git a/servo/components/style/font_face.rs b/servo/components/style/font_face.rs
--- a/servo/components/style/font_face.rs
+++ b/servo/components/style/font_face.rs
@@ -7,16 +7,17 @@
 //! [ff]: https://drafts.csswg.org/css-fonts/#at-font-face-rule
 
 #![deny(missing_docs)]
 
 #[cfg(feature = "gecko")]
 use computed_values::{font_style, font_weight, font_stretch};
 use computed_values::font_family::FamilyName;
 use cssparser::{AtRuleParser, DeclarationListParser, DeclarationParser, Parser};
+use cssparser::SourceLocation;
 #[cfg(feature = "gecko")] use gecko_bindings::structs::CSSFontFaceDescriptors;
 #[cfg(feature = "gecko")] use cssparser::UnicodeRange;
 use parser::{ParserContext, log_css_error, Parse};
 use shared_lock::{SharedRwLockReadGuard, ToCssWithGuard};
 use std::fmt;
 use style_traits::{ToCss, OneOrMoreCommaSeparated};
 use values::specified::url::SpecifiedUrl;
 
@@ -69,18 +70,20 @@ impl ToCss for UrlSource {
     {
         dest.write_str(self.url.as_str())
     }
 }
 
 /// Parse the block inside a `@font-face` rule.
 ///
 /// Note that the prelude parsing code lives in the `stylesheets` module.
-pub fn parse_font_face_block(context: &ParserContext, input: &mut Parser) -> FontFaceRuleData {
+pub fn parse_font_face_block(context: &ParserContext, input: &mut Parser, location: SourceLocation)
+    -> FontFaceRuleData {
     let mut rule = FontFaceRuleData::empty();
+    rule.source_location = location;
     {
         let parser = FontFaceRuleParser {
             context: context,
             rule: &mut rule,
         };
         let mut iter = DeclarationListParser::new(input, parser);
         while let Some(declaration) = iter.next() {
             if let Err(range) = declaration {
@@ -181,24 +184,30 @@ macro_rules! font_face_descriptors_commo
         ///
         /// https://drafts.csswg.org/css-fonts/#font-face-rule
         #[derive(Debug, PartialEq, Eq)]
         pub struct FontFaceRuleData {
             $(
                 #[$doc]
                 pub $ident: Option<$ty>,
             )*
+            /// Line and column of the @font-face rule source code.
+            pub source_location: SourceLocation,
         }
 
         impl FontFaceRuleData {
             fn empty() -> Self {
                 FontFaceRuleData {
                     $(
                         $ident: None,
                     )*
+                    source_location: SourceLocation {
+                        line: 0,
+                        column: 0,
+                    },
                 }
             }
 
             /// Convert to Gecko types
             #[cfg(feature = "gecko")]
             pub fn set_descriptors(&self, descriptors: &mut CSSFontFaceDescriptors) {
                 $(
                     if let Some(ref value) = self.$ident {
diff --git a/servo/components/style/gecko/rules.rs b/servo/components/style/gecko/rules.rs
--- a/servo/components/style/gecko/rules.rs
+++ b/servo/components/style/gecko/rules.rs
@@ -112,17 +112,19 @@ impl ToNsCssValue for Vec<UnicodeRange> 
             target[1].set_integer(range.end as i32);
         }
     }
 }
 
 impl From<FontFaceRuleData> for FontFaceRule {
     fn from(data: FontFaceRuleData) -> FontFaceRule {
         let mut result = unsafe {
-            UniqueRefPtr::from_addrefed(bindings::Gecko_CSSFontFaceRule_Create())
+            UniqueRefPtr::from_addrefed(bindings::Gecko_CSSFontFaceRule_Create(
+                data.source_location.line as u32, data.source_location.column as u32
+            ))
         };
         data.set_descriptors(&mut result.mDecl.mDescriptors);
         result.get()
     }
 }
 
 impl ToCssWithGuard for FontFaceRule {
     fn to_css<W>(&self, _guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
diff --git a/servo/components/style/stylesheets.rs b/servo/components/style/stylesheets.rs
--- a/servo/components/style/stylesheets.rs
+++ b/servo/components/style/stylesheets.rs
@@ -5,17 +5,17 @@
 //! Style sheets and their CSS rules.
 
 #![deny(missing_docs)]
 
 use {Atom, Prefix, Namespace};
 use context::QuirksMode;
 use counter_style::{CounterStyleRule, parse_counter_style_name, parse_counter_style_body};
 use cssparser::{AtRuleParser, Parser, QualifiedRuleParser};
-use cssparser::{AtRuleType, RuleListParser, parse_one_rule};
+use cssparser::{AtRuleType, RuleListParser, parse_one_rule, SourceLocation};
 use cssparser::ToCss as ParserToCss;
 use document_condition::DocumentCondition;
 use error_reporting::{ParseErrorReporter, NullReporter};
 #[cfg(feature = "servo")]
 use font_face::FontFaceRuleData;
 use font_face::parse_font_face_block;
 #[cfg(feature = "gecko")]
 pub use gecko::rules::FontFaceRule;
@@ -484,22 +484,32 @@ impl ToCssWithGuard for CssRule {
             CssRule::Media(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Supports(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Page(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Document(ref lock) => lock.read_with(guard).to_css(guard, dest),
         }
     }
 }
 
+/// Calculates the location of a rule's source given an offset.
+fn get_location_with_offset(location: SourceLocation, offset: u64)
+    -> SourceLocation {
+    SourceLocation {
+        line: location.line + offset as usize - 1,
+        column: location.column,
+    }
+}
+
 #[derive(Debug, PartialEq)]
 #[allow(missing_docs)]
 pub struct NamespaceRule {
     /// `None` for the default Namespace
     pub prefix: Option<Prefix>,
     pub url: Namespace,
+    pub source_location: SourceLocation,
 }
 
 impl ToCssWithGuard for NamespaceRule {
     // https://drafts.csswg.org/cssom/#serialize-a-css-rule CSSNamespaceRule
     fn to_css<W>(&self, _guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
     where W: fmt::Write {
         try!(dest.write_str("@namespace "));
         if let Some(ref prefix) = self.prefix {
@@ -576,16 +586,17 @@ impl ToCssWithGuard for KeyframesRule {
     }
 }
 
 #[allow(missing_docs)]
 #[derive(Debug)]
 pub struct MediaRule {
     pub media_queries: Arc<Locked<MediaList>>,
     pub rules: Arc<Locked<CssRules>>,
+    pub source_location: SourceLocation,
 }
 
 impl ToCssWithGuard for MediaRule {
     // Serialization of MediaRule is not specced.
     // https://drafts.csswg.org/cssom/#serialize-a-css-rule CSSMediaRule
     fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
     where W: fmt::Write {
         try!(dest.write_str("@media "));
@@ -604,16 +615,18 @@ impl ToCssWithGuard for MediaRule {
 /// An @supports rule
 pub struct SupportsRule {
     /// The parsed condition
     pub condition: SupportsCondition,
     /// Child rules
     pub rules: Arc<Locked<CssRules>>,
     /// The result of evaluating the condition
     pub enabled: bool,
+    /// The line and column of the rule's source code.
+    pub source_location: SourceLocation,
 }
 
 impl ToCssWithGuard for SupportsRule {
     fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
     where W: fmt::Write {
         try!(dest.write_str("@supports "));
         try!(self.condition.to_css(dest));
         try!(dest.write_str(" {"));
@@ -625,38 +638,43 @@ impl ToCssWithGuard for SupportsRule {
     }
 }
 
 /// A [`@page`][page] rule.  This implements only a limited subset of the CSS 2.2 syntax.  In this
 /// subset, [page selectors][page-selectors] are not implemented.
 ///
 /// [page]: https://drafts.csswg.org/css2/page.html#page-box
 /// [page-selectors]: https://drafts.csswg.org/css2/page.html#page-selectors
+#[allow(missing_docs)]
 #[derive(Debug)]
-pub struct PageRule(pub Arc<Locked<PropertyDeclarationBlock>>);
+pub struct PageRule {
+    pub block: Arc<Locked<PropertyDeclarationBlock>>,
+    pub source_location: SourceLocation,
+}
 
 impl ToCssWithGuard for PageRule {
     // Serialization of PageRule is not specced, adapted from steps for StyleRule.
     fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
     where W: fmt::Write {
         dest.write_str("@page { ")?;
-        let declaration_block = self.0.read_with(guard);
+        let declaration_block = self.block.read_with(guard);
         declaration_block.to_css(dest)?;
         if declaration_block.declarations().len() > 0 {
             write!(dest, " ")?;
         }
         dest.write_str("}")
     }
 }
 
 #[allow(missing_docs)]
 #[derive(Debug)]
 pub struct StyleRule {
     pub selectors: SelectorList<SelectorImpl>,
     pub block: Arc<Locked<PropertyDeclarationBlock>>,
+    pub source_location: SourceLocation,
 }
 
 impl ToCssWithGuard for StyleRule {
     // https://drafts.csswg.org/cssom/#serialize-a-css-rule CSSStyleRule
     fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
     where W: fmt::Write {
         // Step 1
         try!(self.selectors.to_css(dest));
@@ -991,29 +1009,29 @@ pub enum VendorPrefix {
     /// -moz prefix.
     Moz,
     /// -webkit prefix.
     WebKit,
 }
 
 enum AtRulePrelude {
     /// A @font-face rule prelude.
-    FontFace,
+    FontFace(SourceLocation),
     /// A @counter-style rule prelude, with its counter style name.
     CounterStyle(CustomIdent),
     /// A @media rule prelude, with its media queries.
-    Media(Arc<Locked<MediaList>>),
+    Media(Arc<Locked<MediaList>>, SourceLocation),
     /// An @supports rule, with its conditional
-    Supports(SupportsCondition),
+    Supports(SupportsCondition, SourceLocation),
     /// A @viewport rule prelude.
     Viewport,
     /// A @keyframes rule, with its animation name and vendor prefix if exists.
     Keyframes(KeyframesName, Option<VendorPrefix>),
     /// A @page rule prelude.
-    Page,
+    Page(SourceLocation),
     /// A @document rule, with its conditional.
     Document(DocumentCondition),
 }
 
 
 impl<'a> AtRuleParser for TopLevelRuleParser<'a> {
     type Prelude = AtRulePrelude;
     type AtRule = CssRule;
@@ -1061,32 +1079,36 @@ impl<'a> AtRuleParser for TopLevelRulePa
                     self.state.set(State::Invalid);
                     return Err(())  // "@import must be before any rule but @charset"
                 }
             },
             "namespace" => {
                 if self.state.get() <= State::Namespaces {
                     self.state.set(State::Namespaces);
 
+                    let location = get_location_with_offset(input.current_source_location(),
+                                                            self.context.line_number_offset);
+
                     let prefix_result = input.try(|input| input.expect_ident());
                     let url = Namespace::from(try!(input.expect_url_or_string()));
 
                     let opt_prefix = if let Ok(prefix) = prefix_result {
                         let prefix = Prefix::from(prefix);
                         self.namespaces.prefixes.insert(prefix.clone(), url.clone());
                         Some(prefix)
                     } else {
                         self.namespaces.default = Some(url.clone());
                         None
                     };
 
                     return Ok(AtRuleType::WithoutBlock(CssRule::Namespace(Arc::new(
                         self.shared_lock.wrap(NamespaceRule {
                             prefix: opt_prefix,
                             url: url,
+                            source_location: location,
                         })
                     ))))
                 } else {
                     self.state.set(State::Invalid);
                     return Err(())  // "@namespace must be before any rule but @charset and @import"
                 }
             },
             // @charset is removed by rust-cssparser if itâ€™s the first rule in the stylesheet
@@ -1171,28 +1193,30 @@ fn is_viewport_enabled() -> bool {
 }
 
 impl<'a, 'b> AtRuleParser for NestedRuleParser<'a, 'b> {
     type Prelude = AtRulePrelude;
     type AtRule = CssRule;
 
     fn parse_prelude(&mut self, name: &str, input: &mut Parser)
                      -> Result<AtRuleType<AtRulePrelude, CssRule>, ()> {
+        let location = get_location_with_offset(input.current_source_location(),
+                                                self.context.line_number_offset);
         match_ignore_ascii_case! { name,
             "media" => {
                 let media_queries = parse_media_query_list(self.context, input);
                 let arc = Arc::new(self.shared_lock.wrap(media_queries));
-                Ok(AtRuleType::WithBlock(AtRulePrelude::Media(arc)))
+                Ok(AtRuleType::WithBlock(AtRulePrelude::Media(arc, location)))
             },
             "supports" => {
                 let cond = SupportsCondition::parse(input)?;
-                Ok(AtRuleType::WithBlock(AtRulePrelude::Supports(cond)))
+                Ok(AtRuleType::WithBlock(AtRulePrelude::Supports(cond, location)))
             },
             "font-face" => {
-                Ok(AtRuleType::WithBlock(AtRulePrelude::FontFace))
+                Ok(AtRuleType::WithBlock(AtRulePrelude::FontFace(location)))
             },
             "counter-style" => {
                 if !cfg!(feature = "gecko") {
                     // Support for this rule is not fully implemented in Servo yet.
                     return Err(())
                 }
                 let name = parse_counter_style_name(input)?;
                 // ASCII-case-insensitive matches for "decimal" are already lower-cased
@@ -1224,17 +1248,17 @@ impl<'a, 'b> AtRuleParser for NestedRule
                     return Err(())
                 }
                 let name = KeyframesName::parse(self.context, input)?;
 
                 Ok(AtRuleType::WithBlock(AtRulePrelude::Keyframes(name, prefix)))
             },
             "page" => {
                 if cfg!(feature = "gecko") {
-                    Ok(AtRuleType::WithBlock(AtRulePrelude::Page))
+                    Ok(AtRuleType::WithBlock(AtRulePrelude::Page(location)))
                 } else {
                     Err(())
                 }
             },
             "-moz-document" => {
                 if cfg!(feature = "gecko") {
                     let cond = DocumentCondition::parse(self.context, input)?;
                     Ok(AtRuleType::WithBlock(AtRulePrelude::Document(cond)))
@@ -1243,59 +1267,62 @@ impl<'a, 'b> AtRuleParser for NestedRule
                 }
             },
             _ => Err(())
         }
     }
 
     fn parse_block(&mut self, prelude: AtRulePrelude, input: &mut Parser) -> Result<CssRule, ()> {
         match prelude {
-            AtRulePrelude::FontFace => {
+            AtRulePrelude::FontFace(location) => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::FontFace));
                 Ok(CssRule::FontFace(Arc::new(self.shared_lock.wrap(
-                   parse_font_face_block(&context, input).into()))))
+                   parse_font_face_block(&context, input, location).into()))))
             }
             AtRulePrelude::CounterStyle(name) => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::CounterStyle));
                 Ok(CssRule::CounterStyle(Arc::new(self.shared_lock.wrap(
                    parse_counter_style_body(name, &context, input)?))))
             }
-            AtRulePrelude::Media(media_queries) => {
+            AtRulePrelude::Media(media_queries, location) => {
                 Ok(CssRule::Media(Arc::new(self.shared_lock.wrap(MediaRule {
                     media_queries: media_queries,
                     rules: self.parse_nested_rules(input, CssRuleType::Media),
+                    source_location: location,
                 }))))
             }
-            AtRulePrelude::Supports(cond) => {
+            AtRulePrelude::Supports(cond, location) => {
                 let enabled = cond.eval(self.context);
                 Ok(CssRule::Supports(Arc::new(self.shared_lock.wrap(SupportsRule {
                     condition: cond,
                     rules: self.parse_nested_rules(input, CssRuleType::Supports),
                     enabled: enabled,
+                    source_location: location,
                 }))))
             }
             AtRulePrelude::Viewport => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Viewport));
                 Ok(CssRule::Viewport(Arc::new(self.shared_lock.wrap(
                    try!(ViewportRule::parse(&context, input))))))
             }
             AtRulePrelude::Keyframes(name, prefix) => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Keyframes));
                 Ok(CssRule::Keyframes(Arc::new(self.shared_lock.wrap(KeyframesRule {
                     name: name,
                     keyframes: parse_keyframe_list(&context, input, self.shared_lock),
                     vendor_prefix: prefix,
                 }))))
             }
-            AtRulePrelude::Page => {
+            AtRulePrelude::Page(location) => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Page));
                 let declarations = parse_property_declaration_list(&context, input);
-                Ok(CssRule::Page(Arc::new(self.shared_lock.wrap(PageRule(
-                    Arc::new(self.shared_lock.wrap(declarations))
-                )))))
+                Ok(CssRule::Page(Arc::new(self.shared_lock.wrap(PageRule {
+                    block: Arc::new(self.shared_lock.wrap(declarations)),
+                    source_location: location,
+                }))))
             }
             AtRulePrelude::Document(cond) => {
                 if cfg!(feature = "gecko") {
                     Ok(CssRule::Document(Arc::new(self.shared_lock.wrap(DocumentRule {
                         condition: cond,
                         rules: self.parse_nested_rules(input, CssRuleType::Document),
                     }))))
                 } else {
@@ -1315,16 +1342,19 @@ impl<'a, 'b> QualifiedRuleParser for Nes
             stylesheet_origin: self.stylesheet_origin,
             namespaces: self.namespaces,
         };
         SelectorList::parse(&selector_parser, input)
     }
 
     fn parse_block(&mut self, prelude: SelectorList<SelectorImpl>, input: &mut Parser)
                    -> Result<CssRule, ()> {
+        let location = get_location_with_offset(input.current_source_location(),
+                                                self.context.line_number_offset);
         let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Style));
         let declarations = parse_property_declaration_list(&context, input);
         Ok(CssRule::Style(Arc::new(self.shared_lock.wrap(StyleRule {
             selectors: prelude,
-            block: Arc::new(self.shared_lock.wrap(declarations))
+            block: Arc::new(self.shared_lock.wrap(declarations)),
+            source_location: location,
         }))))
     }
 }
diff --git a/servo/ports/geckolib/glue.rs b/servo/ports/geckolib/glue.rs
--- a/servo/ports/geckolib/glue.rs
+++ b/servo/ports/geckolib/glue.rs
@@ -908,26 +908,26 @@ pub extern "C" fn Servo_NamespaceRule_Ge
 #[no_mangle]
 pub extern "C" fn Servo_NamespaceRule_GetURI(rule: RawServoNamespaceRuleBorrowed) -> *mut nsIAtom {
     read_locked_arc(rule, |rule: &NamespaceRule| rule.url.0.as_ptr())
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_PageRule_GetStyle(rule: RawServoPageRuleBorrowed) -> RawServoDeclarationBlockStrong {
     read_locked_arc(rule, |rule: &PageRule| {
-        rule.0.clone().into_strong()
+        rule.block.clone().into_strong()
     })
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_PageRule_SetStyle(rule: RawServoPageRuleBorrowed,
                                            declarations: RawServoDeclarationBlockBorrowed) {
     let declarations = Locked::<PropertyDeclarationBlock>::as_arc(&declarations);
     write_locked_arc(rule, |rule: &mut PageRule| {
-        rule.0 = declarations.clone();
+        rule.block = declarations.clone();
     })
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_SupportsRule_GetConditionText(rule: RawServoSupportsRuleBorrowed,
                                                       result: *mut nsAString) {
     read_locked_arc(rule, |rule: &SupportsRule| {
         rule.condition.to_css(unsafe { result.as_mut().unwrap() }).unwrap();
