# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  f01df2626fbe8de47116d4ebf49b35f33683875c

diff --git a/dom/backgroundsync/BackgroundSyncTypes.h b/dom/backgroundsync/BackgroundSyncTypes.h
--- a/dom/backgroundsync/BackgroundSyncTypes.h
+++ b/dom/backgroundsync/BackgroundSyncTypes.h
@@ -11,26 +11,16 @@
 #include "nsCOMPtr.h"
 #include "nsIFile.h"
 #include "nsString.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
-struct QuotaInfo
-{
-  QuotaInfo() : mIsApp(false) { }
-  nsCOMPtr<nsIFile> mDir;
-  nsCString mSuffix;
-  nsCString mGroup;
-  nsCString mOrigin;
-  bool mIsApp;
-};
-
 enum RegistrationState
 {
   PENDING = 1,
   WAITING,
   FIRING,
   REREGISTERING_WHILE_FIRING
 };
 
diff --git a/dom/backgroundsync/DBAction.cpp b/dom/backgroundsync/DBAction.cpp
--- a/dom/backgroundsync/DBAction.cpp
+++ b/dom/backgroundsync/DBAction.cpp
@@ -62,28 +62,28 @@ DBAction::RunOnTarget(Resolver* aResolve
 
   nsCOMPtr<mozIStorageConnection> conn;
 
   // Attempt to reuse the connection opened by a previous Action.
   if (aOptionalData) {
     conn = aOptionalData->GetConnection();
   }
 
-  // If there is no previous StorageAction, then we must open one.
+  // If there is no previous ClientAction, then we must open one.
   if (!conn) {
     rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
     if (NS_WARN_IF(NS_FAILED(rv))) {
       aResolver->Resolve(rv);
       return;
     }
     MOZ_ASSERT(conn);
 
-    // Save this connection in the shared Data object so later StorageActions
+    // Save this connection in the shared Data object so later ClientActions
     // can use it.  This avoids opening a new connection for every
-    // StorageAction.
+    // ClientAction.
     if (aOptionalData) {
       // Since we know this connection will be around for as long as the
       // storage is open, use our special wrapped connection class.  This
       // will let us perform certain operations once the storage origin
       // is closed.
       nsCOMPtr<mozIStorageConnection> wrapped = new DBConnection(conn);
       aOptionalData->SetConnection(wrapped);
     }
diff --git a/dom/backgroundsync/DBAction.h b/dom/backgroundsync/DBAction.h
--- a/dom/backgroundsync/DBAction.h
+++ b/dom/backgroundsync/DBAction.h
@@ -2,42 +2,45 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_DBAction_h
 #define mozilla_dom_DBAction_h
 
-#include "StorageAction.h"
-
+#include "mozilla/dom/quota/ClientAction.h"
+#include "mozilla/dom/quota/QuotaInfo.h"
 #include "mozilla/RefPtr.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
-class DBAction : public StorageAction
+using quota::ClientAction;
+using quota::QuotaInfo;
+
+class DBAction : public ClientAction
 {
 protected:
   // The mode specifies whether the database should already exist or if its
   // ok to create a new database.
   enum Mode
   {
     Existing,
     Create
   };
 
   explicit DBAction(Mode aMode);
 
-  // StorageAction objects are deleted through their base pointer
+  // ClientAction objects are deleted through their base pointer
   virtual ~DBAction();
 
   // Just as the resolver must be ref'd until resolve, you may also
   // ref the DB connection. The connection can only be referenced from the
   // target thread and must be released upon resolve.
   virtual void
   RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
                     nsIFile* aDBDir, mozIStorageConnection* aConn) = 0;
diff --git a/dom/backgroundsync/QuotaClient.cpp b/dom/backgroundsync/QuotaClient.cpp
--- a/dom/backgroundsync/QuotaClient.cpp
+++ b/dom/backgroundsync/QuotaClient.cpp
@@ -119,17 +119,17 @@ public:
   virtual void
   OnOriginClearCompleted(PersistenceType aPersistenceType,
                          const nsACString& aOrigin) override
   { }
 
   virtual void
   ReleaseIOThreadObjects() override
   {
-    // Nothing to do here as the StorageContext handles cleaning everything up
+    // Nothing to do here as the ClientContext handles cleaning everything up
     // automatically.
   }
 
   virtual void
   AbortOperations(const nsACString& aOrigin) override
   {
     AssertIsOnBackgroundThread();
 
diff --git a/dom/backgroundsync/StorageAction.cpp b/dom/backgroundsync/StorageAction.cpp
deleted file mode 100644
--- a/dom/backgroundsync/StorageAction.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "StorageAction.h"
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-
-void
-StorageAction::CancelOnInitiatingThread()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageAction);
-  // It is possible for cancellation to be duplicated. For example, an
-  // individual BackgroundSync could have its StorageActions canceled
-  // and then shutdown could trigger a second action.
-  mCanceled = true;
-}
-
-StorageAction::StorageAction()
-  : mCanceled(false)
-{
-}
-
-StorageAction::~StorageAction()
-{
-}
-
-bool
-StorageAction::IsCanceled() const
-{
-  return mCanceled;
-}
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/backgroundsync/StorageAction.h b/dom/backgroundsync/StorageAction.h
deleted file mode 100644
--- a/dom/backgroundsync/StorageAction.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_StorageAction_h
-#define mozilla_dom_StorageAction_h
-
-#include "BackgroundSyncTypes.h"
-
-#include "mozilla/Atomics.h"
-#include "nsISupportsImpl.h"
-
-class mozIStorageConnection;
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-
-class StorageAction
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(StorageAction)
-
-  class Resolver
-  {
-  public:
-    // Note: StorageAction must drop Resolver ref after calling Resolve()!
-    // Note: Must be called on the same thread used to execute
-    //       StorageAction::RunOnTarget().
-    virtual void Resolve(nsresult aRv) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    AddRef(void) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    Release(void) = 0;
-  };
-
-  // Class containing data that can be opportunistically shared between
-  // multiple StorageActions running on the same thread/StorageContext.
-  class Data
-  {
-  public:
-    virtual mozIStorageConnection*
-    GetConnection() const = 0;
-
-    virtual void
-    SetConnection(mozIStorageConnection* aConn) = 0;
-  };
-
-  // Execute operations on the target thread.  Once complete call
-  // Resolver::Resolve(). This can be done sync or async.
-  // Note: StorageAction should hold Resolver ref until its ready to call
-  //        Resolve().
-  // Note: The "target" thread is determined when the StorageAction is scheduled
-  //       on StorageContext. The StorageAction should not assume any particular
-  //       thread is used.
-  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
-                           Data* aOptionalData) = 0;
-
-  // Called on initiating thread when the StorageAction is canceled.
-  // The StorageAction is responsible for calling Resolver::Resolve() as normal;
-  // either with a normal error code or NS_ERROR_ABORT. If
-  // CancelOnInitiatingThread() is called after Resolve() has already occurred,
-  // then the cancel can be ignored.
-  //
-  // Cancellation is a best effort to stop processing as soon as possible, but
-  // does not guarantee the StorageAction will not run.
-  //
-  // CancelOnInitiatingThread() may be called more than once. Subsequent
-  // calls should have no effect.
-  //
-  // Default implementation sets an internal cancellation flag that can be
-  // queried with IsCanceled().
-  virtual void CancelOnInitiatingThread();
-
-  // Executed on the initiating thread and is passed the nsresult given to
-  // Resolver::Resolve().
-  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
-
-protected:
-  StorageAction();
-
-  // virtual because deleted through base class pointer
-  virtual ~StorageAction();
-
-  // Check if this StorageAction has been canceled.
-  // May be called from any thread, but typically used from the target thread.
-  bool IsCanceled() const;
-
-private:
-  // Accessible from any thread.
-  Atomic<bool> mCanceled;
-};
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_StorageAction_h
diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
deleted file mode 100644
--- a/dom/backgroundsync/StorageContext.cpp
+++ /dev/null
@@ -1,1118 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "StorageAction.h"
-#include "StorageContext.h"
-#include "StorageManager.h"
-#include "StorageManagerId.h"
-
-#include "mozilla/AutoRestore.h"
-#include "mozilla/DebugOnly.h"
-#include "mozilla/dom/quota/QuotaManager.h"
-#include "mozIStorageConnection.h"
-#include "nsIFile.h"
-#include "nsIPrincipal.h"
-#include "nsIRunnable.h"
-#include "nsThreadUtils.h"
-
-namespace {
-
-using mozilla::dom::backgroundsync::StorageAction;
-using mozilla::dom::backgroundsync::QuotaInfo;
-
-class NullAction final : public StorageAction
-{
-public:
-  NullAction()
-  {
-  }
-
-  virtual void
-  RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
-  {
-    // Resolve success immediately. This Action does no actual work.
-    MOZ_ASSERT(aResolver);
-    aResolver->Resolve(NS_OK);
-  }
-};
-
-} // namespace
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-
-using mozilla::DebugOnly;
-using mozilla::dom::quota::AssertIsOnIOThread;
-using mozilla::dom::quota::OpenDirectoryListener;
-using mozilla::dom::quota::QuotaManager;
-using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
-using mozilla::dom::quota::PersistenceType;
-using mozilla::dom::quota::DirectoryLock;
-
-class StorageContext::Data final : public StorageAction::Data
-{
-public:
-  explicit Data(nsIThread* aTarget)
-    : mTarget(aTarget)
-  {
-    MOZ_ASSERT(mTarget);
-  }
-
-  virtual mozIStorageConnection*
-  GetConnection() const override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    return mConnection;
-  }
-
-  virtual void
-  SetConnection(mozIStorageConnection* aConn) override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(!mConnection);
-    mConnection = aConn;
-    MOZ_ASSERT(mConnection);
-  }
-
-private:
-  ~Data()
-  {
-    // We could proxy release our data here, but instead just assert. The
-    // StorageContext code should guarantee that we are destroyed on the target
-    // thread once the connection is initialized. If we're not, then
-    // QuotaManager might race and try to clear the origin out from under us.
-    MOZ_ASSERT_IF(mConnection, mTarget == NS_GetCurrentThread());
-  }
-
-  nsCOMPtr<nsIThread> mTarget;
-  nsCOMPtr<mozIStorageConnection> mConnection;
-
-  // Threadsafe counting because we're created on the PBackground thread
-  // and destroyed on the target IO thread.
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageContext::Data)
-};
-
-// Executed to perform the complicated dance of steps necessary to initialize
-// the QuotaManager.This must be performed for each origin before any disk
-// IO occurrs.
-class StorageContext::QuotaInitRunnable final : public nsIRunnable
-                                              , public OpenDirectoryListener
-{
-public:
-  QuotaInitRunnable(StorageContext* aContext,
-                    StorageManager* aManager,
-                    Data* aData,
-                    nsIThread* aTarget,
-                    StorageAction* aInitAction)
-    : mContext(aContext)
-    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
-    , mManager(aManager)
-    , mData(aData)
-    , mTarget(aTarget)
-    , mInitAction(aInitAction)
-    , mInitiatingThread(NS_GetCurrentThread())
-    , mResult(NS_OK)
-    , mState(STATE_INIT)
-    , mCanceled(false)
-  {
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mManager);
-    MOZ_ASSERT(mData);
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mInitiatingThread);
-    MOZ_ASSERT(mInitAction);
-  }
-
-  nsresult Dispatch()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
-
-    mState = STATE_GET_INFO;
-    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      mState = STATE_COMPLETE;
-      Clear();
-    }
-    return rv;
-  }
-
-  void Cancel()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(!mCanceled);
-    mCanceled = true;
-    mInitAction->CancelOnInitiatingThread();
-  }
-
-  void OpenDirectory();
-
-  // OpenDirectoryListener methods
-  virtual void
-  DirectoryLockAcquired(mozilla::dom::quota::DirectoryLock* aLock) override;
-
-  virtual void
-  DirectoryLockFailed() override;
-
-private:
-  class SyncResolver final : public StorageAction::Resolver
-  {
-  public:
-    SyncResolver()
-      : mResolved(false)
-      , mResult(NS_OK)
-    { }
-
-    virtual void
-    Resolve(nsresult aRv) override
-    {
-      MOZ_ASSERT(!mResolved);
-      mResolved = true;
-      mResult = aRv;
-    };
-
-    bool Resolved() const { return mResolved; }
-    nsresult Result() const { return mResult; }
-
-  private:
-    ~SyncResolver() { }
-
-    bool mResolved;
-    nsresult mResult;
-
-    NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
-                               override)
-  };
-
-  ~QuotaInitRunnable()
-  {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mInitAction);
-  }
-
-  enum State
-  {
-    STATE_INIT,
-    STATE_GET_INFO,
-    STATE_CREATE_QUOTA_MANAGER,
-    STATE_OPEN_DIRECTORY,
-    STATE_WAIT_FOR_DIRECTORY_LOCK,
-    STATE_ENSURE_ORIGIN_INITIALIZED,
-    STATE_RUN_ON_TARGET,
-    STATE_RUNNING,
-    STATE_COMPLETING,
-    STATE_COMPLETE
-  };
-
-  void Complete(nsresult aResult)
-  {
-    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
-
-    MOZ_ASSERT(NS_SUCCEEDED(mResult));
-    mResult = aResult;
-
-    mState = STATE_COMPLETING;
-    MOZ_ALWAYS_SUCCEEDS(
-      mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-  }
-
-  void Clear()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mContext);
-    mContext = nullptr;
-    mManager = nullptr;
-    mInitAction = nullptr;
-  }
-
-  RefPtr<StorageContext> mContext;
-  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
-  RefPtr<StorageManager> mManager;
-  RefPtr<Data> mData;
-  nsCOMPtr<nsIThread> mTarget;
-  RefPtr<StorageAction> mInitAction;
-  nsCOMPtr<nsIThread> mInitiatingThread;
-  nsresult mResult;
-  QuotaInfo mQuotaInfo;
-  RefPtr<quota::DirectoryLock> mDirectoryLock;
-  State mState;
-  Atomic<bool> mCanceled;
-
-public:
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIRUNNABLE
-};
-
-void
-StorageContext::QuotaInitRunnable::OpenDirectory()
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
-             mState == STATE_OPEN_DIRECTORY);
-  MOZ_ASSERT(QuotaManager::Get());
-
-  // QuotaManager::OpenDirectory() will hold a reference to us as
-  // a listener. We will then get DirectoryLockAcquired() on the owning
-  // thread when it is safe to access our storage directory.
-  mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
-  QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
-                                     mQuotaInfo.mGroup,
-                                     mQuotaInfo.mOrigin,
-                                     mQuotaInfo.mIsApp,
-                                     mozilla::dom::quota::Client::BACKGROUNDSYNC,
-                                     /* aExclusive */ false,
-                                     this);
-}
-
-void
-StorageContext::QuotaInitRunnable::DirectoryLockAcquired(
-    mozilla::dom::quota::DirectoryLock* aLock)
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
-
-  mDirectoryLock = aLock;
-
-  if (mCanceled) {
-    Complete(NS_ERROR_ABORT);
-    return;
-  }
-
-  QuotaManager* qm = QuotaManager::Get();
-  MOZ_ASSERT(qm);
-
-  mState = STATE_ENSURE_ORIGIN_INITIALIZED;
-  nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    Complete(rv);
-    return;
-  }
-}
-
-void
-StorageContext::QuotaInitRunnable::DirectoryLockFailed()
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
-
-  NS_WARNING("Failed to acquire a directory lock!");
-
-  Complete(NS_ERROR_FAILURE);
-}
-
-NS_IMPL_ISUPPORTS(StorageContext::QuotaInitRunnable, nsIRunnable);
-
-// The QuotaManager init state machine is represented in the following diagram:
-//
-//    +---------------+
-//    |     Start     |      Resolve(error)
-//    | (Orig Thread) +---------------------+
-//    +-------+-------+                     |
-//            |                             |
-// +----------v-----------+                 |
-// |       GetInfo        |  Resolve(error) |
-// |    (Main Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// |  CreateQuotaManager  |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// |    OpenDirectory     |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// | WaitForDirectoryLock |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v------------+                |
-// |EnsureOriginInitialized| Resolve(error) |
-// |   (Quota IO Thread)   +----------------+
-// +----------+------------+                |
-//            |                             |
-// +----------v------------+                |
-// |     RunOnTarget       | Resolve(error) |
-// |   (Target Thread)     +----------------+
-// +----------+------------+                |
-//            |                             |
-//  +---------v---------+            +------v------+
-//  |      Running      |            |  Completing |
-//  | (Target Thread)   +------------>(Orig Thread)|
-//  +-------------------+            +------+------+
-//                                          |
-//                                    +-----v----+
-//                                    | Complete |
-//                                    +----------+
-//
-// The initialization process proceeds through the main states.  If an error
-// occurs, then we transition to Completing state back on the original thread.
-NS_IMETHODIMP
-StorageContext::QuotaInitRunnable::Run()
-{
-  // May run on different threads depending on the state.  See individual
-  // state cases for thread assertions.
-
-  RefPtr<SyncResolver> resolver = new SyncResolver();
-
-  switch(mState) {
-    // -----------------------------------
-    case STATE_GET_INFO:
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-
-      if (mCanceled) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
-      nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
-      nsresult rv = QuotaManager::GetInfoFromPrincipal(principal,
-                                                       &mQuotaInfo.mSuffix,
-                                                       &mQuotaInfo.mGroup,
-                                                       &mQuotaInfo.mOrigin,
-                                                       &mQuotaInfo.mIsApp);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        resolver->Resolve(rv);
-        break;
-      }
-
-      mState = STATE_CREATE_QUOTA_MANAGER;
-      MOZ_ALWAYS_SUCCEEDS(
-        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // ----------------------------------
-    case STATE_CREATE_QUOTA_MANAGER:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-
-      if (mCanceled || QuotaManager::IsShuttingDown()) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      if (QuotaManager::Get()) {
-        OpenDirectory();
-        return NS_OK;
-      }
-
-      mState = STATE_OPEN_DIRECTORY;
-      QuotaManager::GetOrCreate(this);
-      break;
-    }
-    // ----------------------------------
-    case STATE_OPEN_DIRECTORY:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-
-      if (NS_WARN_IF(!QuotaManager::Get())) {
-        resolver->Resolve(NS_ERROR_FAILURE);
-        break;
-      }
-
-      OpenDirectory();
-      break;
-    }
-    // ----------------------------------
-    case STATE_ENSURE_ORIGIN_INITIALIZED:
-    {
-      AssertIsOnIOThread();
-
-      if (mCanceled) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      QuotaManager* qm = QuotaManager::Get();
-      MOZ_ASSERT(qm);
-      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
-                                                  mQuotaInfo.mSuffix,
-                                                  mQuotaInfo.mGroup,
-                                                  mQuotaInfo.mOrigin,
-                                                  mQuotaInfo.mIsApp,
-                                                  getter_AddRefs(mQuotaInfo.mDir));
-      if (NS_FAILED(rv)) {
-        resolver->Resolve(rv);
-        break;
-      }
-
-      mState = STATE_RUN_ON_TARGET;
-
-      MOZ_ALWAYS_SUCCEEDS(
-        mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // -------------------
-    case STATE_RUN_ON_TARGET:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-
-      mState = STATE_RUNNING;
-
-      // Execute the provided initialization StorageAction. The
-      // StorageAction must Resolve() before returning.
-      mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
-      MOZ_ASSERT(resolver->Resolved());
-
-      mData = nullptr;
-
-      break;
-    }
-    // -------------------
-    case STATE_COMPLETING:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-      mInitAction->CompleteOnInitiatingThread(mResult);
-      mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
-      mState = STATE_COMPLETE;
-
-      // Explicitly cleanup here as the destructor could fire on any of
-      // the threads we have bounced through.
-      Clear();
-      break;
-    }
-    // -----
-    case STATE_WAIT_FOR_DIRECTORY_LOCK:
-    default:
-    {
-      MOZ_CRASH("unexpected state in QuotaInitRunnable");
-    }
-  }
-
-  if (resolver->Resolved()) {
-    Complete(resolver->Result());
-  }
-
-  return NS_OK;
-}
-
-// Runnable wrapper around StorageAction objects dispatched on the StorageContext.
-// This runnable executes the StorageAction on the appropriate threads while the
-// StorageContext is initialized.
-class StorageContext::ActionRunnable final : public nsIRunnable
-                                           , public StorageAction::Resolver
-                                           , public StorageContext::Activity
-{
-public:
-  ActionRunnable(StorageContext* aContext, Data* aData, nsIEventTarget* aTarget,
-                 StorageAction* aAction, const QuotaInfo& aQuotaInfo)
-    : mContext(aContext)
-    , mData(aData)
-    , mTarget(aTarget)
-    , mAction(aAction)
-    , mQuotaInfo(aQuotaInfo)
-    , mInitiatingThread(NS_GetCurrentThread())
-    , mState(STATE_INIT)
-    , mResult(NS_OK)
-    , mExecutingRunOnTarget(false)
-  {
-    MOZ_ASSERT(mContext);
-    // mData may be nullptr
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mAction);
-    // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
-    MOZ_ASSERT(mInitiatingThread);
-  }
-
-  nsresult Dispatch()
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
-
-    mState = STATE_RUN_ON_TARGET;
-    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      mState = STATE_COMPLETE;
-      Clear();
-    }
-    return rv;
-  }
-
-  virtual void
-  Cancel() override
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    mAction->CancelOnInitiatingThread();
-  }
-
-  virtual void Resolve(nsresult aRv) override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(mState == STATE_RUNNING);
-
-    mResult = aRv;
-
-    // We ultimately must complete on the initiating thread, but bounce through
-    // the current thread again to ensure that we don't destroy objects and
-    // state out from under the currently running action's stack.
-    mState = STATE_RESOLVING;
-
-    // If we were resolved synchronously within Action::RunOnTarget() then we
-    // can avoid a thread bounce and just resolve once RunOnTarget() returns.
-    // The Run() method will handle this by looking at mState after
-    // RunOnTarget() returns.
-    if (mExecutingRunOnTarget) {
-      return;
-    }
-
-    // Otherwise we are in an asynchronous resolve.  And must perform a thread
-    // bounce to run on the target thread again.
-    MOZ_ALWAYS_SUCCEEDS(
-      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-  }
-
-private:
-  ~ActionRunnable()
-  {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mAction);
-  }
-
-  void Clear()
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mAction);
-    mContext->RemoveActivity(this);
-    mContext = nullptr;
-    mAction = nullptr;
-  }
-
-  enum State
-  {
-    STATE_INIT,
-    STATE_RUN_ON_TARGET,
-    STATE_RUNNING,
-    STATE_RESOLVING,
-    STATE_COMPLETING,
-    STATE_COMPLETE
-  };
-
-  RefPtr<StorageContext> mContext;
-  RefPtr<Data> mData;
-  nsCOMPtr<nsIEventTarget> mTarget;
-  RefPtr<StorageAction> mAction;
-  const QuotaInfo mQuotaInfo;
-  nsCOMPtr<nsIThread> mInitiatingThread;
-  State mState;
-  nsresult mResult;
-
-  // Only accessible on target thread;
-  bool mExecutingRunOnTarget;
-
-public:
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIRUNNABLE
-};
-
-NS_IMPL_ISUPPORTS(StorageContext::ActionRunnable, nsIRunnable);
-
-// The ActionRunnable has a simpler state machine.  It basically needs to run
-// the action on the target thread and then complete on the original thread.
-//
-//   +-------------+
-//   |    Start    |
-//   |(Orig Thread)|
-//   +-----+-------+
-//         |
-// +-------v---------+
-// |  RunOnTarget    |
-// |Target IO Thread)+---+ Resolve()
-// +-------+---------+   |
-//         |             |
-// +-------v----------+  |
-// |     Running      |  |
-// |(Target IO Thread)|  |
-// +------------------+  |
-//         | Resolve()   |
-// +-------v----------+  |
-// |     Resolving    <--+                   +-------------+
-// |                  |                      |  Completing |
-// |(Target IO Thread)+---------------------->(Orig Thread)|
-// +------------------+                      +-------+-----+
-//                                                   |
-//                                                   |
-//                                              +----v---+
-//                                              |Complete|
-//                                              +--------+
-//
-// Its important to note that synchronous actions will effectively Resolve()
-// out of the Running state immediately. Asynchronous StorageActions may remain
-// in the Running state for some time, but normally the ActionRunnable itself
-// does not see any execution there. Its all handled internal to the StorageAction.
-NS_IMETHODIMP
-StorageContext::ActionRunnable::Run()
-{
-  switch(mState) {
-    // ----------------------
-    case STATE_RUN_ON_TARGET:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      MOZ_ASSERT(!mExecutingRunOnTarget);
-
-      // Note that we are calling RunOnTarget().  This lets us detect
-      // if Resolve() is called synchronously.
-      AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
-      mExecutingRunOnTarget = true;
-
-      mState = STATE_RUNNING;
-      mAction->RunOnTarget(this, mQuotaInfo, mData);
-
-      mData = nullptr;
-
-      // Resolve was called synchronously from RunOnTarget(). We can
-      // immediately move to completing now since we are sure RunOnTarget()
-      // completed.
-      if (mState == STATE_RESOLVING) {
-        // Use recursion instead of switch case fall-through...  Seems slightly
-        // easier to understand.
-        Run();
-      }
-
-      break;
-    }
-    // -----------------
-    case STATE_RESOLVING:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      // The call to StorageAction::RunOnTarget() must have returned now if we
-      // are running on the target thread again.  We may now proceed
-      // with completion.
-      mState = STATE_COMPLETING;
-      // Shutdown must be delayed until all Contexts are destroyed.  Crash
-      // for this invariant violation.
-      MOZ_ALWAYS_SUCCEEDS(
-        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // -------------------
-    case STATE_COMPLETING:
-    {
-      NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-      mAction->CompleteOnInitiatingThread(mResult);
-      mState = STATE_COMPLETE;
-      // Explicitly cleanup here as the destructor could fire on any of
-      // the threads we have bounced through.
-      Clear();
-      break;
-    }
-    // -----------------
-    default:
-    {
-      MOZ_CRASH("unexpected state in ActionRunnable");
-      break;
-    }
-  }
-  return NS_OK;
-}
-
-void
-StorageContext::ThreadsafeHandle::AllowToClose()
-{
-  if (mOwningThread == NS_GetCurrentThread()) {
-    AllowToCloseOnOwningThread();
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all StorageContexts have been destroyed.
-  nsCOMPtr<nsIRunnable> runnable =
-    NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
-  MOZ_ALWAYS_SUCCEEDS(
-    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
-}
-
-void
-StorageContext::ThreadsafeHandle::InvalidateAndAllowToClose()
-{
-  if (mOwningThread == NS_GetCurrentThread()) {
-    InvalidateAndAllowToCloseOnOwningThread();
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all StorageContexts have been destroyed.
-  nsCOMPtr<nsIRunnable> runnable =
-    NewRunnableMethod(this, &ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread);
-  MOZ_ALWAYS_SUCCEEDS(
-    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
-}
-
-StorageContext::ThreadsafeHandle::ThreadsafeHandle(StorageContext* aContext)
-  : mStrongRef(aContext)
-  , mWeakRef(aContext)
-  , mOwningThread(NS_GetCurrentThread())
-{
-}
-
-StorageContext::ThreadsafeHandle::~ThreadsafeHandle()
-{
-  // Normally we only touch mStrongRef on the owning thread.  This is safe,
-  // however, because when we do use mStrongRef on the owning thread we are
-  // always holding a strong ref to the ThreadsafeHandle via the owning
-  // runnable.  So we cannot run the ThreadsafeHandle destructor simultaneously.
-  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all Contexts have been destroyed.
-  NS_ProxyRelease(mOwningThread, mStrongRef.forget());
-}
-
-void
-StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-
-  // A StorageContext "closes" when its ref count drops to zero. Dropping this
-  // strong ref is necessary, but not sufficient for the close to occur.
-  // Any outstanding IO will continue and keep the StorageContext alive. Once
-  // the StorageContext is idle, it will be destroyed.
-
-  // First, tell the context to flush any target thread shared data. This
-  // data must be released on the target thread prior to running the
-  // StorageContext destructor. This will schedule an Action which ensures that
-  // the ~StorageContext() is not immediately executed when we drop the strong
-  // ref.
-  if (mStrongRef) {
-    mStrongRef->DoomTargetData();
-  }
-
-  // Now drop our strong ref and let StorageContext finish running any
-  // outstanding StorageActions.
-  mStrongRef = nullptr;
-}
-
-void
-StorageContext::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-  // Cancel the StorageContext through the weak reference. This means we can
-  // allow the StorageContext to close by dropping the strong ref, but then
-  // still cancel ongoing IO if necessary.
-  if (mWeakRef) {
-    mWeakRef->Invalidate();
-  }
-  // We should synchronously have AllowToCloseOnOwningThread called when
-  // the Context is canceled.
-  MOZ_ASSERT(!mStrongRef);
-}
-
-void
-StorageContext::ThreadsafeHandle::StorageContextDestroyed(StorageContext* aContext)
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-  MOZ_ASSERT(!mStrongRef);
-  MOZ_ASSERT(mWeakRef);
-  MOZ_ASSERT(mWeakRef == aContext);
-  mWeakRef = nullptr;
-}
-
-// static
-already_AddRefed<StorageContext>
-StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
-                       StorageAction* aInitAction, StorageContext* aOldContext)
-{
-  RefPtr<StorageContext> context =
-    new StorageContext(aManager, aTarget, aInitAction);
-  context->Init(aOldContext);
-  return context.forget();
-}
-
-StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
-                               StorageAction* aInitAction)
-  : mManager(aManager)
-  , mTarget(aTarget)
-  , mData(new Data(aTarget))
-  , mState(STATE_CONTEXT_PREINIT)
-  , mOrphanedData(false)
-  , mInitAction(aInitAction)
-{
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(mTarget);
-}
-
-void
-StorageContext::Dispatch(StorageAction* aAction)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(aAction);
-
-  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
-  if (mState == STATE_CONTEXT_CANCELED) {
-    return;
-  } else if (mState == STATE_CONTEXT_INIT ||
-             mState == STATE_CONTEXT_PREINIT) {
-    PendingStorageAction* pending = mPendingActions.AppendElement();
-    pending->mAction = aAction;
-    return;
-  }
-
-  MOZ_ASSERT(STATE_CONTEXT_READY);
-  DispatchAction(aAction);
-}
-
-void
-StorageContext::CancelAll()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  // In PREINIT state we have not dispatch the init action yet.  Just
-  // forget it.
-  if (mState == STATE_CONTEXT_PREINIT) {
-    MOZ_ASSERT(!mInitRunnable);
-    mInitAction = nullptr;
-
-  // In INIT state we have dispatched the runnable, but not received the
-  // async completion yet.  Cancel the runnable, but don't forget about it
-  // until we get OnQuotaInit() callback.
-  } else if (mState == STATE_CONTEXT_INIT) {
-    mInitRunnable->Cancel();
-  }
-
-  mState = STATE_CONTEXT_CANCELED;
-  mPendingActions.Clear();
-  {
-    ActivityList::ForwardIterator iter(mActivityList);
-    while (iter.HasMore()) {
-      iter.GetNext()->Cancel();
-    }
-  }
-  AllowToClose();
-}
-
-bool
-StorageContext::IsCanceled() const
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  return mState == STATE_CONTEXT_CANCELED;
-}
-
-void
-StorageContext::Invalidate()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  mManager->NoteClosing();
-  CancelAll();
-}
-
-void
-StorageContext::AllowToClose()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  if (mThreadsafeHandle) {
-    mThreadsafeHandle->AllowToClose();
-  }
-}
-
-StorageContext::~StorageContext()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(!mData);
-
-  if (mThreadsafeHandle) {
-    mThreadsafeHandle->StorageContextDestroyed(this);
-  }
-
-  // Note, this may set the mOrphanedData flag.
-  mManager->RemoveStorageContext(this);
-
-  if (mNextContext) {
-    mNextContext->Start();
-  }
-}
-
-void
-StorageContext::Init(StorageContext* aOldContext)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  if (aOldContext) {
-    aOldContext->SetNextContext(this);
-    return;
-  }
-
-  Start();
-}
-
-void
-StorageContext::Start()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  // Previous context closing delayed our start, but then we were canceled.
-  // In this case, just do nothing here.
-  if (mState == STATE_CONTEXT_CANCELED) {
-    MOZ_ASSERT(!mInitRunnable);
-    MOZ_ASSERT(!mInitAction);
-    return;
-  }
-
-  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
-  MOZ_ASSERT(!mInitRunnable);
-
-  mInitRunnable = new QuotaInitRunnable(this, mManager, mData, mTarget,
-                                        mInitAction);
-  mInitAction = nullptr;
-
-  mState = STATE_CONTEXT_INIT;
-
-  nsresult rv = mInitRunnable->Dispatch();
-  if (NS_FAILED(rv)) {
-    // Shutdown must be delayed until all StorageContexts are destroyed.
-    // Shutdown must also prevent any new StorageContexts from being constructed.
-    // Crash for this invariant violation.
-    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
-  }
-}
-
-void
-StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  RefPtr<ActionRunnable> runnable =
-    new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
-
-  if (aDoomData) {
-    mData = nullptr;
-  }
-
-  nsresult rv = runnable->Dispatch();
-  if (NS_FAILED(rv)) {
-    // Shutdown must be delayed until all Contexts are destroyed.  Crash
-    // for this invariant violation.
-    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
-  }
-  AddActivity(runnable);
-}
-
-void
-StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
-                            already_AddRefed<quota::DirectoryLock> aDirectoryLock)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-
-  MOZ_ASSERT(mInitRunnable);
-  mInitRunnable = nullptr;
-
-  mQuotaInfo = aQuotaInfo;
-
-  // Always save the directory lock to ensure QuotaManager does not shutdown
-  // before the StorageContext has gone away.
-  MOZ_ASSERT(!mDirectoryLock);
-  mDirectoryLock = aDirectoryLock;
-
-  // If we opening the context failed, but we were not explicitly canceled,
-  // still treat the entire context as canceled.  We don't want to allow
-  // new actions to be dispatched.  We also cannot leave the context in
-  // the INIT state after failing to open.
-  if (NS_FAILED(aRv)) {
-    mState = STATE_CONTEXT_CANCELED;
-  }
-
-  if (mState == STATE_CONTEXT_CANCELED) {
-    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
-    }
-    mPendingActions.Clear();
-    mThreadsafeHandle->AllowToClose();
-    // Context will destruct after return here and last ref is released.
-    return;
-  }
-
-  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
-  mState = STATE_CONTEXT_READY;
-
-  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-    DispatchAction(mPendingActions[i].mAction);
-  }
-  mPendingActions.Clear();
-}
-
-void
-StorageContext::AddActivity(Activity* aActivity)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(aActivity);
-  MOZ_ASSERT(!mActivityList.Contains(aActivity));
-  mActivityList.AppendElement(aActivity);
-}
-
-void
-StorageContext::RemoveActivity(Activity* aActivity)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(aActivity);
-  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
-  MOZ_ASSERT(!mActivityList.Contains(aActivity));
-}
-
-void
-StorageContext::NoteOrphanedData()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  // This may be called more than once
-  mOrphanedData = true;
-}
-
-already_AddRefed<StorageContext::ThreadsafeHandle>
-StorageContext::CreateThreadsafeHandle()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  if (!mThreadsafeHandle) {
-    mThreadsafeHandle = new ThreadsafeHandle(this);
-  }
-  RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
-  return ref.forget();
-}
-
-void
-StorageContext::SetNextContext(StorageContext* aNextContext)
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(aNextContext);
-  MOZ_ASSERT(!mNextContext);
-  mNextContext = aNextContext;
-}
-
-void
-StorageContext::DoomTargetData()
-{
-  NS_ASSERT_OWNINGTHREAD(StorageContext);
-  MOZ_ASSERT(mData);
-
-  // We are about to drop our reference to the Data. We need to ensure that
-  // the ~StorageContext() destructor does not run until contents of Data have
-  // been released on the Target thread.
-
-  // Dispatch a no-op StorageAction. This will hold the StorageContext alive
-  // through a roundtrip to the target thread and back to the owning thread.
-  // The ref to the Data object is cleared on the owning thread after creating
-  // the ActionRunnable, but before dispatching it.
-  RefPtr<StorageAction> action = new NullAction();
-  DispatchAction(action, true /* doomed data */);
-
-  MOZ_ASSERT(!mData);
-}
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/backgroundsync/StorageContext.h b/dom/backgroundsync/StorageContext.h
deleted file mode 100644
--- a/dom/backgroundsync/StorageContext.h
+++ /dev/null
@@ -1,218 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_StorageContext_h
-#define mozilla_dom_StorageContext_h
-
-#include "BackgroundSyncTypes.h"
-#include "StorageAction.h"
-
-namespace mozilla {
-namespace dom {
-
-namespace quota {
-  class DirectoryLock;
-} // namespace quota
-
-namespace backgroundsync {
-
-class StorageManager;
-
-/**
- * The StorageContext class is RAII-style class for managing IO operations
- * within Background Sync storage.
- *
- * When a StorageContext is created it performs the complicated steps necessary
- * to initialize the QuotaManager. StorageAction objects dispatched on the
- * Context are delayed until this initialization is complete. They are then
- * allow to execute on any specified thread. Once all references to the
- * StorageContext are gone, then the steps necessary to release the QuotaManager
- * are performed. After initialization the StorageContext holds a self reference,
- * so it will stay alive until one of three conditions occur:
- *
- * 1) The StorageManager will call StorageContext::AllowToClose() when all of
- *    the actors have removed themselves as listener. This means an idle
- *    context with no active DOM objects will close gracefully.
- * 2) The QuotaManager aborts all operations so it can delete the files.
- *    In this case the QuotaManager calls Client::AbortOperations() which
- *    in turn cancels all existing StorageAction objects and then marks the
- *    StorageManager as invalid.
- * 3) Browser shutdown occurs and the StorageManager calls
- *    StorageContext::CancelAll()
- *
- * In either case, though, the StorageAction objects must be destroyed first to
- * allow the StorageContext to be destroyed.
- *
- * While the StorageContext performs operations asynchronously on threads, all
- * of methods in its public interface must be called on the same thread
- * originally used to create the Context.
- */
-
-class StorageContext final
-{
-public:
-  NS_INLINE_DECL_REFCOUNTING(StorageContext)
-
-  // Define a class allowing other threads to hold the StorageContext alive.
-  // This also allows these other threads to safely close or cancel the
-  // StorageContext.
-  class ThreadsafeHandle final
-  {
-    friend class StorageContext;
-
-  public:
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ThreadsafeHandle)
-
-    void AllowToClose();
-    void InvalidateAndAllowToClose();
-
-  private:
-    explicit ThreadsafeHandle(StorageContext* aContext);
-    ~ThreadsafeHandle();
-
-    // Disallow copying.
-    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
-    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
-
-    void AllowToCloseOnOwningThread();
-    void InvalidateAndAllowToCloseOnOwningThread();
-
-    void StorageContextDestroyed(StorageContext* aContext);
-
-    // Cleared to allow the StorageContext to close.  Only safe to access on
-    // owning thread.
-    RefPtr<StorageContext> mStrongRef;
-
-    // Used to support cancelation even while the StorageContext is already
-    // allowed to close.  Cleared by ~StorageContext() calling
-    // StorageContextDestroyed().  Only safe to access on owning thread.
-    StorageContext* mWeakRef;
-
-    nsCOMPtr<nsIThread> mOwningThread;
-  };
-
-  // Different objects hold references to the StorageContext while some work is
-  // being performed asynchronously. These objects must implement the Activity
-  // interface and register themselves with the AddActivity().  When they are
-  // destroyed they must call RemoveActivity(). This allows the StorageContext
-  // to cancel any outstanding Activity work when the Context is cancelled.
-  class Activity
-  {
-  public:
-    virtual void Cancel() = 0;
-  };
-
-  // Create a Context attached to the given StorageManager.
-  // The given StorageAction will run on the QuotaManager IO thread.
-  // Note, this StorageAction must be execute synchronously.
-  static already_AddRefed<StorageContext>
-  Create(StorageManager* aManager, nsIThread* aTarget,
-         StorageAction* aInitAction, StorageContext* aOldContext);
-
-  // Execute given action on the target once the quota manager has been
-  // initialized.
-  //
-  // Only callable from the thread that created the Context.
-  void Dispatch(StorageAction* aAction);
-
-  // Cancel any StorageActions running or waiting to run.
-  // This should allow the StorageContext to be released and
-  // Listener::RemoveContext() will be called when complete.
-  //
-  // Only callable from the thread that created the Context.
-  void CancelAll();
-
-  // True if CancelAll() has been called.
-  bool IsCanceled() const;
-
-  // Like CancelAll(), but also marks the Manager as "invalid".
-  void Invalidate();
-
-  // Remove any self references and allow the StorageContext to be released
-  // when there are no more StorageActions to process.
-  void AllowToClose();
-
-  void AddActivity(Activity* aActivity);
-  void RemoveActivity(Activity* aActivity);
-
-  const QuotaInfo&
-  GetQuotaInfo() const
-  {
-    return mQuotaInfo;
-  }
-
-  // Tell the StorageContext that some state information has been orphaned in
-  // the data store and won't be cleaned up. The StoargeContext will leave the
-  // marker in place to trigger cleanup the next times its opened.
-  void NoteOrphanedData();
-
-private:
-  class Data;
-  class QuotaInitRunnable;
-  class ActionRunnable;
-
-  enum State
-  {
-    STATE_CONTEXT_PREINIT,
-    STATE_CONTEXT_INIT,
-    STATE_CONTEXT_READY,
-    STATE_CONTEXT_CANCELED
-  };
-
-  struct PendingStorageAction
-  {
-    nsCOMPtr<nsIEventTarget> mTarget;
-    RefPtr<StorageAction> mAction;
-  };
-
-  StorageContext(StorageManager* aManager, nsIThread* aTarget,
-                 StorageAction* aInitAction);
-  ~StorageContext();
-  void Init(StorageContext* aOldContext);
-  void Start();
-  void DispatchAction(StorageAction* aAction, bool aDoomData = false);
-  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
-    already_AddRefed<mozilla::dom::quota::DirectoryLock> aDirectoryLock);
-
-
-  already_AddRefed<ThreadsafeHandle>
-  CreateThreadsafeHandle();
-
-  void
-  SetNextContext(StorageContext* aNextContext);
-
-  void
-  DoomTargetData();
-
-  RefPtr<StorageManager> mManager;
-  nsCOMPtr<nsIThread> mTarget;
-  RefPtr<Data> mData;
-  State mState;
-  bool mOrphanedData;
-  QuotaInfo mQuotaInfo;
-  RefPtr<QuotaInitRunnable> mInitRunnable;
-  RefPtr<StorageAction> mInitAction;
-  nsTArray<PendingStorageAction> mPendingActions;
-
-  // Weak refs since activites must remove themselves from this list before
-  // being destroyed by calling RemoveActivity().
-  typedef nsTObserverArray<Activity*> ActivityList;
-  ActivityList mActivityList;
-
-  // The ThreadsafeHandle may have a strong ref back to us. This creates
-  // a ref-cycle that keeps the StorageContext alive.  The ref-cycle is broken
-  // when ThreadsafeHandle::AllowToClose() is called.
-  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
-
-  RefPtr<mozilla::dom::quota::DirectoryLock> mDirectoryLock;
-  RefPtr<StorageContext> mNextContext;
-};
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_StorageContext_h
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -1,30 +1,29 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "DBAction.h"
-#include "StorageContext.h"
 #include "StorageManager.h"
 
 #include "mozilla/AutoRestore.h"
 #include "mozilla/StaticMutex.h"
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
 namespace {
 
-// StorageActions that are executed when a StorageContext is first created.
+// ClientActions that are executed when a ClientContext is first created.
 // It ensures that the database is setup properly.
 // This lets other actions not worry about these details.
 class SetupAction final : public SyncDBAction
 {
 public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
@@ -278,17 +277,17 @@ StaticAutoPtr<StorageManager::Factory> S
 // static
 StaticMutex StorageManager::Factory::sMutex;
 
 // static
 bool StorageManager::Factory::sFactoryShutdown = false;
 
 // ---------------------------------------------------------------------------
 
-// Abstract class to help implement the varios StorageActions.
+// Abstract class to help implement the varios ClientActions.
 class StorageManager::BaseAction : public SyncDBAction
 {
 protected:
   BaseAction(const nsID& aRequestId, StorageManager* aManager)
     : SyncDBAction(DBAction::Existing)
     , mRequestId(aRequestId)
     , mManager(aManager)
   {}
@@ -554,43 +553,45 @@ StorageManager::~StorageManager()
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
 }
 
 void
 StorageManager::Init(StorageManager* aOldManager)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
-  RefPtr<StorageContext> oldContext;
+  RefPtr<ClientContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
   // Create the context immediately. Since there can at most be one
-  // StorageContext per StorageManager, this lets us cleanly call
-  // Factory::Remove() once the StorageContext goes away.
-  RefPtr<StorageAction> setupAction = new SetupAction();
-  RefPtr<StorageContext> ref = StorageContext::Create(this, mIOThread,
-                                                      setupAction, oldContext);
+  // ClientContext per StorageManager, this lets us cleanly call
+  // Factory::Remove() once the ClientContext goes away.
+  RefPtr<ClientAction> setupAction = new SetupAction();
+  RefPtr<ClientContext> ref =
+    ClientContext::Create(this, quota::Client::BACKGROUNDSYNC,
+                          NS_LITERAL_STRING("backgroundsync"),
+                          mIOThread, setupAction, oldContext);
   mContext = ref;
 }
 
 void
 StorageManager::Abort()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new StorageContext. We must ensure all Contexts and IO
+  // creating a new ClientContext. We must ensure all Contexts and IO
   // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
-  RefPtr<StorageContext> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   context->CancelAll();
 }
 
 void
 StorageManager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
@@ -599,100 +600,109 @@ StorageManager::Shutdown()
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
 
   mShuttingDown = true;
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new StorageContext. We must ensure all Contexts and IO
+  // creating a new ClientContext. We must ensure all Contexts and IO
   // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // If there is a context, then cancel and only note that we are done after
   // its cleaned up.
   if (mContext) {
-    RefPtr<StorageContext> context = mContext;
+    RefPtr<ClientContext> context = mContext;
     context->CancelAll();
   }
 }
 
 void
 StorageManager::NoteClosing()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
 void
-StorageManager::RemoveStorageContext(StorageContext* aContext)
+StorageManager::RemoveClientContext(ClientContext* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
-  // Wether the StorageContext destruction was triggered from the StorageManager
+  // Wether the ClientContext destruction was triggered from the StorageManager
   // going idle or the underlying storage being invalidated, we should know we
-  // are closing before the StorageContext is destroyed.
+  // are closing before the ClientContext is destroyed.
   MOZ_ASSERT(mState == Closing);
 
   mContext = nullptr;
 
   // Once the context is gone, we can immediately remove ourself from the
   // Factory list. We don't need to block shutdown by stayin in the list
   // any more.
   Factory::Remove(this);
 }
 
+already_AddRefed<nsIPrincipal>
+StorageManager::GetPrincipal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIPrincipal> ref = mManagerId->Principal();
+  return ref.forget();
+}
+
 void
 StorageManager::MaybeAllowContextToClose()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   // If we have an active context, but we have no more pending requests,
   // then let it shut itself down. We must wait for all possible users
   // of state information to complete before doing this.
-  RefPtr<StorageContext> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   if (context && mPendingRequests.IsEmpty()) {
     // Mark the StorageManager as invalid so that it won't get used again.
     NoteClosing();
 
     context->AllowToClose();
   }
 }
 
 // Common to DOM and internal requests.
 void
-StorageManager::ExecuteRequest(const nsID& aRequestId, StorageAction* aAction)
+StorageManager::ExecuteRequest(const nsID& aRequestId, ClientAction* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(aAction);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
     OnRequestComplete(aRequestId,
                       SyncOpError(static_cast<uint32_t>(NS_ERROR_ABORT)));
     return;
   }
 
-  RefPtr<StorageContext> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   context->Dispatch(aAction);
 }
 
 // DOM request.
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
 {
-  RefPtr<StorageAction> action;
+  RefPtr<ClientAction> action;
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       action = new RegisterAction(aRequestId, this,
                                   aOp.mArgs().get_SyncRegisterArgs());
       break;
     }
@@ -710,17 +720,17 @@ StorageManager::ExecuteRequest(const nsI
 
   ExecuteRequest(aRequestId, action);
 }
 
 // Internal request.
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp)
 {
-  RefPtr<StorageAction> action;
+  RefPtr<ClientAction> action;
 
   switch(aOp.mArgs().type()) {
     case SyncInternalOpArgs::TSyncGetAllArgs:
     {
       action = new GetAllAction(aRequestId, this);
       break;
     }
     case SyncInternalOpArgs::TSyncChangeStateArgs:
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
--- a/dom/backgroundsync/StorageManager.h
+++ b/dom/backgroundsync/StorageManager.h
@@ -2,42 +2,44 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_StorageManager_h
 #define mozilla_dom_StorageManager_h
 
-#include "StorageContext.h"
+#include "mozilla/dom/quota/ClientContext.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
+using quota::ClientContext;
+
 /**
  * The StorageManager class is responsible for managing the storage of sync
  * requests. The DOM objects and IPC actors are basically just plumbing to
  * get the request to the right StorageManager object running in the parent
  * process.
  *
  * There should be exactly one StorageManager object for each origin or app
  * using the BackgroundSync API. This uniqueness is defined by the
  * StorageManagerId equality operator. The uniqueness is enforced by the
  * Manager GetOrCreate() factory method.
  *
  * The StorageManager instances are kept alive by the BackgroundSyncService,
  * which keeps a reference to the StorageManager dealing with a storage request
  * until that request is completed or the actor requesting it is destroyed.
  */
 
-class StorageManager final
+class StorageManager final : public quota::ClientContext::Listener
 {
 public:
-  NS_INLINE_DECL_REFCOUNTING(StorageManager)
+  NS_INLINE_DECL_REFCOUNTING(StorageManager, override)
 
   static nsresult GetOrCreate(StorageManagerId* aManagerId,
                               StorageManager** aManagerOut);
 
   enum State
   {
     Open,
     Closing
@@ -55,25 +57,22 @@ public:
   }
 
   // Synchronously shutdown.  This spins the event loop.
   static void ShutdownAll();
 
   // Cancel actions for given origin or all actions if passed string is null.
   static void Abort(const nsACString& aOrigin);
 
-  // Must be called by StorageContext objects before they are destroyed.
-  void RemoveStorageContext(StorageContext* aContext);
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
 
-  // Marks the StorageManager "invalid". Once the StorageContext completes
-  // no new operations will be permitted with this StorageManager.
-  // New actors will get a new StorageManager.
-  void NoteClosing();
-
-  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+  // quota::ClientContext::Listener
+  virtual void NoteClosing() override;
+  virtual void RemoveClientContext(ClientContext* aContext) override;
+  virtual already_AddRefed<nsIPrincipal> GetPrincipal() const override;
 
 private:
   class BaseAction;
   class ChangeStateAction;
   class Factory;
   class GetAllAction;
   class GetTagsAction;
   class RegisterAction;
@@ -88,25 +87,25 @@ private:
   void Shutdown();
 
   void MaybeAllowContextToClose();
 
   void OnRequestComplete(const nsID& aRequestId);
   template<typename T>
   void OnRequestComplete(const nsID& aRequestId, const T& aResponse);
 
-  void ExecuteRequest(const nsID& aRequestId, StorageAction* aAction);
+  void ExecuteRequest(const nsID& aRequestId, ClientAction* aAction);
   void ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp);
 
   RefPtr<StorageManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
-  // Weak reference cleared by RemoveStorageContext() in StorageContext
+  // Weak reference cleared by RemoveClientContext() in ClientContext
   // destructor.
-  StorageContext* MOZ_NON_OWNING_REF mContext;
+  ClientContext* MOZ_NON_OWNING_REF mContext;
 
   bool mShuttingDown;
   State mState;
 
   // Keep a list of the request IDs coming from BackgroundSyncService.
   nsTArray<nsID> mPendingRequests;
 };
 
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -15,18 +15,16 @@ UNIFIED_SOURCES += [
     'BackgroundSyncParent.cpp',
     'ChromeDBSchema.cpp',
     'ChromeStorageManager.cpp',
     'DBAction.cpp',
     'DBConnection.cpp',
     'DBSchema.cpp',
     'DBSchemaUtils.cpp',
     'QuotaClient.cpp',
-    'StorageAction.cpp',
-    'StorageContext.cpp',
     'StorageManager.cpp',
     'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
