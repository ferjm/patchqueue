# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  efd985b7895a7e088537ca84aa4df9214b7222d3
Bug 1217544 - Implement one-off BackgroundSync API. Part 2: ServiceWorkerRegistration. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -46,24 +46,25 @@ BackgroundSync::CreateOnMainThread(nsIGl
   }
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
-BackgroundSync::CreateOnWorker(WorkerPrivate* aWorkerPrivate)
+BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
+                               WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
-  RefPtr<BackgroundSync> ref = new BackgroundSync(nullptr,
+  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal,
                                                   principalInfo);
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
                                const PrincipalInfo& aPrincipalInfo)
   : mGlobal(aGlobal)
   , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
@@ -84,17 +85,17 @@ BackgroundSync::WrapObject(JSContext* aC
 bool
 BackgroundSync::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   using mozilla::dom::workers::WorkerPrivate;
   using mozilla::dom::workers::GetWorkerPrivateFromContext;
 
   // If we are on the main thread, then check the pref directly.
   if (NS_IsMainThread()) {
-    return Preferences::GetBool("dom.background.sync.enabled", false);
+    return Preferences::GetBool("dom.backgroundSync.enabled", false);
   }
 
   // Otherwise check the pref via the worker private helper.
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
   if (!workerPrivate) {
     return false;
   }
 
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -41,17 +41,18 @@ public:
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(BackgroundSync)
 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
-  CreateOnWorker(workers::WorkerPrivate* aWorkerPrivate);
+  CreateOnWorker(nsIGlobalObject* aGlobal,
+                 workers::WorkerPrivate* aWorkerPrivate);
 
   // Binding methods.
 
   nsIGlobalObject*
   GetParentObject() const
   {
     return mGlobal;
   }
diff --git a/dom/webidl/ServiceWorkerRegistration.webidl b/dom/webidl/ServiceWorkerRegistration.webidl
--- a/dom/webidl/ServiceWorkerRegistration.webidl
+++ b/dom/webidl/ServiceWorkerRegistration.webidl
@@ -27,9 +27,12 @@ interface ServiceWorkerRegistration : Ev
   attribute EventHandler onupdatefound;
 };
 
 partial interface ServiceWorkerRegistration {
 #ifndef MOZ_SIMPLEPUSH
   [Throws, Exposed=(Window,Worker), Func="nsContentUtils::PushEnabled"]
   readonly attribute PushManager pushManager;
 #endif
+  [Throws, Exposed=(Window,Worker),
+   Func="backgroundsync::BackgroundSync::PrefEnabled"]
+  readonly attribute BackgroundSync sync;
 };
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -30,17 +30,21 @@
 #include "Workers.h"
 #include "WorkerScope.h"
 
 #ifndef MOZ_SIMPLEPUSH
 #include "mozilla/dom/PushManagerBinding.h"
 #include "mozilla/dom/PushManager.h"
 #endif
 
+#include "mozilla/dom/BackgroundSyncBinding.h"
+#include "mozilla/dom/backgroundsync/BackgroundSync.h"
+
 using namespace mozilla::dom::workers;
+using namespace mozilla::dom::backgroundsync;
 
 namespace mozilla {
 namespace dom {
 
 /* static */ bool
 ServiceWorkerRegistration::Visible(JSContext* aCx, JSObject* aObj)
 {
   if (NS_IsMainThread()) {
@@ -111,16 +115,19 @@ public:
   GetWaiting() override;
 
   already_AddRefed<ServiceWorker>
   GetActive() override;
 
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
 
+  backgroundsync::BackgroundSync*
+  GetSync(ErrorResult& aRv) override;
+
   // DOMEventTargethelper
   void DisconnectFromOwner() override
   {
     StopListeningForEvents();
     ServiceWorkerRegistration::DisconnectFromOwner();
   }
 
   // ServiceWorkerRegistrationListener
@@ -159,32 +166,35 @@ private:
   // These three may change to a new worker at any time.
   RefPtr<ServiceWorker> mInstallingWorker;
   RefPtr<ServiceWorker> mWaitingWorker;
   RefPtr<ServiceWorker> mActiveWorker;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<backgroundsync::BackgroundSync> mBackgroundSync;
 };
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistration)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistration)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread)
 NS_INTERFACE_MAP_END_INHERITING(ServiceWorkerRegistration)
 
 #ifndef MOZ_SIMPLEPUSH
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread,
                                    ServiceWorkerRegistration,
-                                   mPushManager,
+                                   mPushManager, mBackgroundSync,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #else
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread,
                                    ServiceWorkerRegistration,
+                                   mBackgroundSync,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #endif
 
 ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
                                                                          const nsAString& aScope)
   : ServiceWorkerRegistration(aWindow, aScope)
   , mListeningForEvents(false)
 {
@@ -856,16 +866,48 @@ ServiceWorkerRegistrationMainThread::Get
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+BackgroundSync*
+ServiceWorkerRegistrationMainThread::GetSync(ErrorResult& aRv)
+{
+  AssertIsOnMainThread();
+
+  if (!mBackgroundSync) {
+    nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
+
+    if (!globalObject) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIDocument> document = GetOwner()->GetExtantDoc();
+    if (!document) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIPrincipal> principal = document->NodePrincipal();
+    if (!principal) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    mBackgroundSync = BackgroundSync::CreateOnMainThread(globalObject, principal,
+                                                         aRv);
+  }
+
+  return mBackgroundSync;
+}
+
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
 class ServiceWorkerRegistrationWorkerThread final : public ServiceWorkerRegistration
                                                   , public WorkerHolder
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
@@ -908,16 +950,19 @@ public:
   }
 
   bool
   Notify(Status aStatus) override;
 
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv) override;
 
+  backgroundsync::BackgroundSync*
+  GetSync(ErrorResult& aRv) override;
+
 private:
   enum Reason
   {
     RegistrationIsGoingAway = 0,
     WorkerIsGoingAway,
   };
 
   ~ServiceWorkerRegistrationWorkerThread();
@@ -929,16 +974,18 @@ private:
   ReleaseListener(Reason aReason);
 
   WorkerPrivate* mWorkerPrivate;
   RefPtr<WorkerListener> mListener;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<backgroundsync::BackgroundSync> mBackgroundSync;
 };
 
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
   // Accessed on the main thread.
   WorkerPrivate* mWorkerPrivate;
   nsString mScope;
   bool mListeningForEvents;
@@ -1053,23 +1100,25 @@ NS_INTERFACE_MAP_END_INHERITING(ServiceW
 // Expanded macros since we need special behaviour to release the proxy.
 NS_IMPL_CYCLE_COLLECTION_CLASS(ServiceWorkerRegistrationWorkerThread)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                   ServiceWorkerRegistration)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mBackgroundSync)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                 ServiceWorkerRegistration)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mBackgroundSync)
   tmp->ReleaseListener(RegistrationIsGoingAway);
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 ServiceWorkerRegistrationWorkerThread::ServiceWorkerRegistrationWorkerThread(WorkerPrivate* aWorkerPrivate,
                                                                              const nsAString& aScope)
   : ServiceWorkerRegistration(nullptr, aScope)
   , mWorkerPrivate(aWorkerPrivate)
 {
@@ -1363,16 +1412,27 @@ ServiceWorkerRegistrationWorkerThread::G
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+BackgroundSync*
+ServiceWorkerRegistrationWorkerThread::GetSync(ErrorResult& aRv)
+{
+  if (!mBackgroundSync) {
+    mBackgroundSync = BackgroundSync::CreateOnWorker(
+        mWorkerPrivate->GlobalScope(), mWorkerPrivate);
+  }
+
+  return mBackgroundSync;
+}
+
 ////////////////////////////////////////////////////
 // Base class implementation
 
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistration, DOMEventTargetHelper)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistration)
 NS_INTERFACE_MAP_END_INHERITING(DOMEventTargetHelper)
diff --git a/dom/workers/ServiceWorkerRegistration.h b/dom/workers/ServiceWorkerRegistration.h
--- a/dom/workers/ServiceWorkerRegistration.h
+++ b/dom/workers/ServiceWorkerRegistration.h
@@ -25,16 +25,20 @@ class Promise;
 class PushManager;
 class WorkerListener;
 
 namespace workers {
 class ServiceWorker;
 class WorkerPrivate;
 } // namespace workers
 
+namespace backgroundsync {
+class BackgroundSync;
+} // namespace backgroundsync
+
 // Used by ServiceWorkerManager to notify ServiceWorkerRegistrations of
 // updatefound event and invalidating ServiceWorker instances.
 class ServiceWorkerRegistrationListener
 {
 public:
   NS_IMETHOD_(MozExternalRefCountType) AddRef() = 0;
   NS_IMETHOD_(MozExternalRefCountType) Release() = 0;
 
@@ -92,16 +96,19 @@ public:
   Update(ErrorResult& aRv) = 0;
 
   virtual already_AddRefed<Promise>
   Unregister(ErrorResult& aRv) = 0;
 
   virtual already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv) = 0;
 
+  virtual backgroundsync::BackgroundSync*
+  GetSync(ErrorResult& aRv) = 0;
+
   virtual already_AddRefed<Promise>
   ShowNotification(JSContext* aCx,
                    const nsAString& aTitle,
                    const NotificationOptions& aOptions,
                    ErrorResult& aRv) = 0;
 
   virtual already_AddRefed<Promise>
   GetNotifications(const GetNotificationOptions& aOptions,
diff --git a/dom/workers/WorkerPrefs.h b/dom/workers/WorkerPrefs.h
--- a/dom/workers/WorkerPrefs.h
+++ b/dom/workers/WorkerPrefs.h
@@ -29,17 +29,17 @@ WORKER_SIMPLE_PREF("dom.caches.enabled",
 WORKER_SIMPLE_PREF("dom.caches.testing.enabled", DOMCachesTestingEnabled, DOM_CACHES_TESTING)
 WORKER_SIMPLE_PREF("dom.performance.enable_user_timing_logging", PerformanceLoggingEnabled, PERFORMANCE_LOGGING_ENABLED)
 WORKER_SIMPLE_PREF("dom.webnotifications.enabled", DOMWorkerNotificationEnabled, DOM_WORKERNOTIFICATION)
 WORKER_SIMPLE_PREF("dom.webnotifications.serviceworker.enabled", DOMServiceWorkerNotificationEnabled, DOM_SERVICEWORKERNOTIFICATION)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.enabled", ServiceWorkersEnabled, SERVICEWORKERS_ENABLED)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.testing.enabled", ServiceWorkersTestingEnabled, SERVICEWORKERS_TESTING_ENABLED)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.openWindow.enabled", OpenWindowEnabled, OPEN_WINDOW_ENABLED)
 WORKER_SIMPLE_PREF("dom.push.enabled", PushEnabled, PUSH_ENABLED)
-WORKER_SIMPLE_PREF("dom.background.sync.enabled", BackgroundSyncEnabled, BACKGROUND_SYNC_ENABLED)
+WORKER_SIMPLE_PREF("dom.backgroundSync.enabled", BackgroundSyncEnabled, BACKGROUND_SYNC_ENABLED)
 WORKER_SIMPLE_PREF("dom.requestcontext.enabled", RequestContextEnabled, REQUESTCONTEXT_ENABLED)
 WORKER_SIMPLE_PREF("gfx.offscreencanvas.enabled", OffscreenCanvasEnabled, OFFSCREENCANVAS_ENABLED)
 WORKER_SIMPLE_PREF("dom.webkitBlink.dirPicker.enabled", WebkitBlinkDirectoryPickerEnabled, DOM_WEBKITBLINK_DIRPICKER_WEBKITBLINK)
 WORKER_PREF("dom.workers.latestJSVersion", JSVersionChanged)
 WORKER_PREF("intl.accept_languages", PrefLanguagesChanged)
 WORKER_PREF("general.appname.override", AppNameOverrideChanged)
 WORKER_PREF("general.appversion.override", AppVersionOverrideChanged)
 WORKER_PREF("general.platform.override", PlatformOverrideChanged)
