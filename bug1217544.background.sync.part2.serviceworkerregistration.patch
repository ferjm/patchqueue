# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  66ce8ad02c8782ed26e96c667a6e1f3f9eb1f0fb
Bug 1217544 - Implement one-off BackgroundSync API. Part 2: ServiceWorkerRegistration. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -44,24 +44,25 @@ BackgroundSync::CreateOnMainThread(nsIGl
   }
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
-BackgroundSync::CreateOnWorker(WorkerPrivate* aWorkerPrivate)
+BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
+                               WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
-  RefPtr<BackgroundSync> ref = new BackgroundSync(nullptr,
+  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal,
                                                   principalInfo);
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
                                const PrincipalInfo& aPrincipalInfo)
   : mGlobal(aGlobal)
   , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
@@ -82,17 +83,17 @@ BackgroundSync::WrapObject(JSContext* aC
 bool
 BackgroundSync::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   using mozilla::dom::workers::WorkerPrivate;
   using mozilla::dom::workers::GetWorkerPrivateFromContext;
 
   // If we are on the main thread, then check the pref directly.
   if (NS_IsMainThread()) {
-    return Preferences::GetBool("dom.background.sync.enabled", false);
+    return Preferences::GetBool("dom.backgroundSync.enabled", false);
   }
 
   // Otherwise check the pref via the worker private helper.
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
   if (!workerPrivate) {
     return false;
   }
 
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -27,29 +27,30 @@ namespace dom {
 
 namespace workers {
   class WorkerPrivate;
 } // namespace workers
 
 class Promise;
 
 class BackgroundSync final : public nsISupports
-                        , public nsWrapperCache
+                           , public nsWrapperCache
 {
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(BackgroundSync)
 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
-  CreateOnWorker(workers::WorkerPrivate* aWorkerPrivate);
+  CreateOnWorker(nsIGlobalObject* aGlobal,
+                 workers::WorkerPrivate* aWorkerPrivate);
 
   // Binding methods.
 
   nsIGlobalObject*
   GetParentObject() const
   {
     return mGlobal;
   }
diff --git a/dom/webidl/ServiceWorkerRegistration.webidl b/dom/webidl/ServiceWorkerRegistration.webidl
--- a/dom/webidl/ServiceWorkerRegistration.webidl
+++ b/dom/webidl/ServiceWorkerRegistration.webidl
@@ -27,9 +27,11 @@ interface ServiceWorkerRegistration : Ev
   attribute EventHandler onupdatefound;
 };
 
 partial interface ServiceWorkerRegistration {
 #ifndef MOZ_SIMPLEPUSH
   [Throws, Exposed=(Window,Worker), Func="nsContentUtils::PushEnabled"]
   readonly attribute PushManager pushManager;
 #endif
+  [Throws, Exposed=(Window,Worker), Func="BackgroundSync::PrefEnabled"]
+  readonly attribute BackgroundSync sync;
 };
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -28,16 +28,19 @@
 #include "Workers.h"
 #include "WorkerScope.h"
 
 #ifndef MOZ_SIMPLEPUSH
 #include "mozilla/dom/PushManagerBinding.h"
 #include "mozilla/dom/PushManager.h"
 #endif
 
+#include "mozilla/dom/BackgroundSyncBinding.h"
+#include "mozilla/dom/BackgroundSync.h"
+
 using namespace mozilla::dom::workers;
 
 namespace mozilla {
 namespace dom {
 
 bool
 ServiceWorkerRegistrationVisible(JSContext* aCx, JSObject* aObj)
 {
@@ -87,20 +90,21 @@ ServiceWorkerRegistrationBase::ServiceWo
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread)
 NS_INTERFACE_MAP_END_INHERITING(ServiceWorkerRegistrationBase)
 
 #ifndef MOZ_SIMPLEPUSH
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase,
-                                   mPushManager,
+                                   mPushManager, mBackgroundSync,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #else
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase,
+                                   mBackgroundSync,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #endif
 
 ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
                                                                          const nsAString& aScope)
   : ServiceWorkerRegistrationBase(aWindow, aScope)
   , mListeningForEvents(false)
 {
@@ -777,16 +781,48 @@ ServiceWorkerRegistrationMainThread::Get
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+BackgroundSync*
+ServiceWorkerRegistrationMainThread::GetSync(ErrorResult& aRv)
+{
+  AssertIsOnMainThread();
+
+  if (!mBackgroundSync) {
+    nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
+
+    if (!globalObject) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIDocument> document = GetOwner()->GetExtantDoc();
+    if (!document) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIPrincipal> principal = document->NodePrincipal();
+    if (!principal) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    mBackgroundSync = BackgroundSync::CreateOnMainThread(globalObject, principal,
+                                                   aRv);
+  }
+
+  return mBackgroundSync;
+}
+
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
   // Accessed on the main thread.
   WorkerPrivate* mWorkerPrivate;
   nsString mScope;
   bool mListeningForEvents;
@@ -901,23 +937,25 @@ NS_INTERFACE_MAP_END_INHERITING(ServiceW
 // Expanded macros since we need special behaviour to release the proxy.
 NS_IMPL_CYCLE_COLLECTION_CLASS(ServiceWorkerRegistrationWorkerThread)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                   ServiceWorkerRegistrationBase)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mBackgroundSync)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                 ServiceWorkerRegistrationBase)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mBackgroundSync)
   tmp->ReleaseListener(RegistrationIsGoingAway);
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 ServiceWorkerRegistrationWorkerThread::ServiceWorkerRegistrationWorkerThread(WorkerPrivate* aWorkerPrivate,
                                                                              const nsAString& aScope)
   : ServiceWorkerRegistrationBase(nullptr, aScope)
   , mWorkerPrivate(aWorkerPrivate)
 {
@@ -1216,10 +1254,21 @@ ServiceWorkerRegistrationWorkerThread::G
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+BackgroundSync*
+ServiceWorkerRegistrationWorkerThread::GetSync(ErrorResult& aRv)
+{
+  if (!mBackgroundSync) {
+    mBackgroundSync = BackgroundSync::CreateOnWorker(mWorkerPrivate->GlobalScope(),
+                                                     mWorkerPrivate);
+  }
+
+  return mBackgroundSync;
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/workers/ServiceWorkerRegistration.h b/dom/workers/ServiceWorkerRegistration.h
--- a/dom/workers/ServiceWorkerRegistration.h
+++ b/dom/workers/ServiceWorkerRegistration.h
@@ -17,16 +17,17 @@
 
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 class PushManager;
+class BackgroundSync;
 class WorkerListener;
 
 namespace workers {
 class ServiceWorker;
 class WorkerPrivate;
 } // namespace workers
 
 bool
@@ -120,16 +121,19 @@ public:
   GetWaiting() override;
 
   already_AddRefed<workers::ServiceWorker>
   GetActive() override;
 
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv);
 
+  BackgroundSync*
+  GetSync(ErrorResult& aRv);
+
   // DOMEventTargethelper
   void DisconnectFromOwner() override
   {
     StopListeningForEvents();
     ServiceWorkerRegistrationBase::DisconnectFromOwner();
   }
 
   // ServiceWorkerRegistrationListener
@@ -170,16 +174,18 @@ private:
   // These three may change to a new worker at any time.
   RefPtr<workers::ServiceWorker> mInstallingWorker;
   RefPtr<workers::ServiceWorker> mWaitingWorker;
   RefPtr<workers::ServiceWorker> mActiveWorker;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<BackgroundSync> mBackgroundSync;
 };
 
 class ServiceWorkerRegistrationWorkerThread final : public ServiceWorkerRegistrationBase
                                                   , public workers::WorkerFeature
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistrationWorkerThread,
@@ -223,16 +229,19 @@ public:
   }
 
   bool
   Notify(workers::Status aStatus) override;
 
   already_AddRefed<PushManager>
   GetPushManager(ErrorResult& aRv);
 
+  BackgroundSync*
+  GetSync(ErrorResult& aRv);
+
 private:
   enum Reason
   {
     RegistrationIsGoingAway = 0,
     WorkerIsGoingAway,
   };
 
   ~ServiceWorkerRegistrationWorkerThread();
@@ -244,14 +253,16 @@ private:
   ReleaseListener(Reason aReason);
 
   workers::WorkerPrivate* mWorkerPrivate;
   RefPtr<WorkerListener> mListener;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<BackgroundSync> mBackgroundSync;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_ServiceWorkerRegistration_h */
diff --git a/dom/workers/WorkerPrefs.h b/dom/workers/WorkerPrefs.h
--- a/dom/workers/WorkerPrefs.h
+++ b/dom/workers/WorkerPrefs.h
@@ -28,17 +28,17 @@ WORKER_SIMPLE_PREF("dom.caches.enabled",
 WORKER_SIMPLE_PREF("dom.caches.testing.enabled", DOMCachesTestingEnabled, DOM_CACHES_TESTING)
 WORKER_SIMPLE_PREF("dom.performance.enable_user_timing_logging", PerformanceLoggingEnabled, PERFORMANCE_LOGGING_ENABLED)
 WORKER_SIMPLE_PREF("dom.webnotifications.enabled", DOMWorkerNotificationEnabled, DOM_WORKERNOTIFICATION)
 WORKER_SIMPLE_PREF("dom.webnotifications.serviceworker.enabled", DOMServiceWorkerNotificationEnabled, DOM_SERVICEWORKERNOTIFICATION)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.enabled", ServiceWorkersEnabled, SERVICEWORKERS_ENABLED)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.testing.enabled", ServiceWorkersTestingEnabled, SERVICEWORKERS_TESTING_ENABLED)
 WORKER_SIMPLE_PREF("dom.serviceWorkers.openWindow.enabled", OpenWindowEnabled, OPEN_WINDOW_ENABLED)
 WORKER_SIMPLE_PREF("dom.push.enabled", PushEnabled, PUSH_ENABLED)
-WORKER_SIMPLE_PREF("dom.background.sync.enabled", BackgroundSyncEnabled, BACKGROUND_SYNC_ENABLED)
+WORKER_SIMPLE_PREF("dom.backgroundSync.enabled", BackgroundSyncEnabled, BACKGROUND_SYNC_ENABLED)
 WORKER_SIMPLE_PREF("dom.requestcontext.enabled", RequestContextEnabled, REQUESTCONTEXT_ENABLED)
 WORKER_SIMPLE_PREF("gfx.offscreencanvas.enabled", OffscreenCanvasEnabled, OFFSCREENCANVAS_ENABLED)
 WORKER_PREF("dom.workers.latestJSVersion", JSVersionChanged)
 WORKER_PREF("intl.accept_languages", PrefLanguagesChanged)
 WORKER_PREF("general.appname.override", AppNameOverrideChanged)
 WORKER_PREF("general.appversion.override", AppVersionOverrideChanged)
 WORKER_PREF("general.platform.override", PlatformOverrideChanged)
 #ifdef JS_GC_ZEAL
