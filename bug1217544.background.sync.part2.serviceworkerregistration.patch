# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  4cfb44debe970a63f0baa9c9d1618e64c5ed0105
Bug 1217544 - Implement one-off BackgroundSync API. Part 2: ServiceWorkerRegistration. r=baku

diff --git a/dom/sync/SyncManager.cpp b/dom/sync/SyncManager.cpp
--- a/dom/sync/SyncManager.cpp
+++ b/dom/sync/SyncManager.cpp
@@ -44,24 +44,25 @@ SyncManager::CreateOnMainThread(nsIGloba
   }
 
   RefPtr<SyncManager> ref = new SyncManager(aGlobal, principalInfo);
   return ref.forget();
 }
 
 // static
 already_AddRefed<SyncManager>
-SyncManager::CreateOnWorker(WorkerPrivate* aWorkerPrivate)
+SyncManager::CreateOnWorker(nsIGlobalObject* aGlobal,
+                            WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
-  RefPtr<SyncManager> ref = new SyncManager(nullptr, principalInfo);
+  RefPtr<SyncManager> ref = new SyncManager(aGlobal, principalInfo);
   return ref.forget();
 }
 
 SyncManager::SyncManager(nsIGlobalObject* aGlobal,
                          const PrincipalInfo& aPrincipalInfo)
   : mGlobal(aGlobal)
   , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
 {}
diff --git a/dom/sync/SyncManager.h b/dom/sync/SyncManager.h
--- a/dom/sync/SyncManager.h
+++ b/dom/sync/SyncManager.h
@@ -41,24 +41,24 @@ public:
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(SyncManager)
 
   static already_AddRefed<SyncManager>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<SyncManager>
-  CreateOnWorker(workers::WorkerPrivate* aWorkerPrivate);
+  CreateOnWorker(nsIGlobalObject* aGlobal,
+                 workers::WorkerPrivate* aWorkerPrivate);
 
   // Binding methods.
 
   nsIGlobalObject*
   GetParentObject() const
   {
-    // Can be nullptr on workers.
     return mGlobal;
   }
 
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
diff --git a/dom/webidl/ServiceWorkerRegistration.webidl b/dom/webidl/ServiceWorkerRegistration.webidl
--- a/dom/webidl/ServiceWorkerRegistration.webidl
+++ b/dom/webidl/ServiceWorkerRegistration.webidl
@@ -27,9 +27,11 @@ interface ServiceWorkerRegistration : Ev
   attribute EventHandler onupdatefound;
 };
 
 partial interface ServiceWorkerRegistration {
 #ifndef MOZ_SIMPLEPUSH
   [Throws, Exposed=(Window,Worker), Func="nsContentUtils::PushEnabled"]
   readonly attribute PushManager pushManager;
 #endif
+  [Throws, Exposed=(Window,Worker), Pref="dom.backgroundsync.enabled"]
+  readonly attribute SyncManager sync;
 };
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -28,16 +28,19 @@
 #include "Workers.h"
 #include "WorkerScope.h"
 
 #ifndef MOZ_SIMPLEPUSH
 #include "mozilla/dom/PushManagerBinding.h"
 #include "mozilla/dom/PushManager.h"
 #endif
 
+#include "mozilla/dom/SyncManagerBinding.h"
+#include "mozilla/dom/SyncManager.h"
+
 using namespace mozilla::dom::workers;
 
 namespace mozilla {
 namespace dom {
 
 bool
 ServiceWorkerRegistrationVisible(JSContext* aCx, JSObject* aObj)
 {
@@ -87,20 +90,21 @@ ServiceWorkerRegistrationBase::ServiceWo
 NS_IMPL_ADDREF_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase)
 NS_IMPL_RELEASE_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase)
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread)
 NS_INTERFACE_MAP_END_INHERITING(ServiceWorkerRegistrationBase)
 
 #ifndef MOZ_SIMPLEPUSH
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase,
-                                   mPushManager,
+                                   mPushManager, mSyncManager,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #else
 NS_IMPL_CYCLE_COLLECTION_INHERITED(ServiceWorkerRegistrationMainThread, ServiceWorkerRegistrationBase,
+                                   mSyncManager,
                                    mInstallingWorker, mWaitingWorker, mActiveWorker);
 #endif
 
 ServiceWorkerRegistrationMainThread::ServiceWorkerRegistrationMainThread(nsPIDOMWindowInner* aWindow,
                                                                          const nsAString& aScope)
   : ServiceWorkerRegistrationBase(aWindow, aScope)
   , mListeningForEvents(false)
 {
@@ -777,16 +781,48 @@ ServiceWorkerRegistrationMainThread::Get
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+SyncManager*
+ServiceWorkerRegistrationMainThread::GetSync(ErrorResult& aRv)
+{
+  AssertIsOnMainThread();
+
+  if (!mSyncManager) {
+    nsCOMPtr<nsIGlobalObject> globalObject = do_QueryInterface(GetOwner());
+
+    if (!globalObject) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIDocument> document = GetOwner()->GetExtantDoc();
+    if (!document) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    nsCOMPtr<nsIPrincipal> principal = document->NodePrincipal();
+    if (!principal) {
+      aRv.Throw(NS_ERROR_FAILURE);
+      return nullptr;
+    }
+
+    mSyncManager = SyncManager::CreateOnMainThread(globalObject, principal,
+                                                   aRv);
+  }
+
+  return mSyncManager;
+}
+
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 class WorkerListener final : public ServiceWorkerRegistrationListener
 {
   // Accessed on the main thread.
   WorkerPrivate* mWorkerPrivate;
   nsString mScope;
   bool mListeningForEvents;
@@ -901,23 +937,25 @@ NS_INTERFACE_MAP_END_INHERITING(ServiceW
 // Expanded macros since we need special behaviour to release the proxy.
 NS_IMPL_CYCLE_COLLECTION_CLASS(ServiceWorkerRegistrationWorkerThread)
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                   ServiceWorkerRegistrationBase)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSyncManager)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(ServiceWorkerRegistrationWorkerThread,
                                                 ServiceWorkerRegistrationBase)
 #ifndef MOZ_SIMPLEPUSH
   NS_IMPL_CYCLE_COLLECTION_UNLINK(mPushManager)
 #endif
+  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSyncManager)
   tmp->ReleaseListener(RegistrationIsGoingAway);
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 ServiceWorkerRegistrationWorkerThread::ServiceWorkerRegistrationWorkerThread(WorkerPrivate* aWorkerPrivate,
                                                                              const nsAString& aScope)
   : ServiceWorkerRegistrationBase(nullptr, aScope)
   , mWorkerPrivate(aWorkerPrivate)
 {
@@ -1215,10 +1253,21 @@ ServiceWorkerRegistrationWorkerThread::G
   }
 
   RefPtr<PushManager> ret = mPushManager;
   return ret.forget();
 
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
+SyncManager*
+ServiceWorkerRegistrationWorkerThread::GetSync(ErrorResult& aRv)
+{
+  if (!mSyncManager) {
+    mSyncManager = SyncManager::CreateOnWorker(mWorkerPrivate->GlobalScope(),
+                                               mWorkerPrivate);
+  }
+
+  return mSyncManager;
+}
+
 } // dom namespace
 } // mozilla namespace
diff --git a/dom/workers/ServiceWorkerRegistration.h b/dom/workers/ServiceWorkerRegistration.h
--- a/dom/workers/ServiceWorkerRegistration.h
+++ b/dom/workers/ServiceWorkerRegistration.h
@@ -17,16 +17,17 @@
 
 class nsPIDOMWindowInner;
 
 namespace mozilla {
 namespace dom {
 
 class Promise;
 class PushManager;
+class SyncManager;
 class WorkerListener;
 
 namespace workers {
 class ServiceWorker;
 class WorkerPrivate;
 } // namespace workers
 
 bool
@@ -120,16 +121,19 @@ public:
   GetWaiting() override;
 
   already_AddRefed<workers::ServiceWorker>
   GetActive() override;
 
   already_AddRefed<PushManager>
   GetPushManager(JSContext* aCx, ErrorResult& aRv);
 
+  SyncManager*
+  GetSync(ErrorResult& aRv);
+
   // DOMEventTargethelper
   void DisconnectFromOwner() override
   {
     StopListeningForEvents();
     ServiceWorkerRegistrationBase::DisconnectFromOwner();
   }
 
   // ServiceWorkerRegistrationListener
@@ -170,16 +174,18 @@ private:
   // These three may change to a new worker at any time.
   RefPtr<workers::ServiceWorker> mInstallingWorker;
   RefPtr<workers::ServiceWorker> mWaitingWorker;
   RefPtr<workers::ServiceWorker> mActiveWorker;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<SyncManager> mSyncManager;
 };
 
 class ServiceWorkerRegistrationWorkerThread final : public ServiceWorkerRegistrationBase
                                                   , public workers::WorkerFeature
 {
 public:
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(ServiceWorkerRegistrationWorkerThread,
@@ -223,16 +229,19 @@ public:
   }
 
   bool
   Notify(workers::Status aStatus) override;
 
   already_AddRefed<PushManager>
   GetPushManager(ErrorResult& aRv);
 
+  SyncManager*
+  GetSync(ErrorResult& aRv);
+
 private:
   enum Reason
   {
     RegistrationIsGoingAway = 0,
     WorkerIsGoingAway,
   };
 
   ~ServiceWorkerRegistrationWorkerThread();
@@ -244,14 +253,16 @@ private:
   ReleaseListener(Reason aReason);
 
   workers::WorkerPrivate* mWorkerPrivate;
   RefPtr<WorkerListener> mListener;
 
 #ifndef MOZ_SIMPLEPUSH
   RefPtr<PushManager> mPushManager;
 #endif
+
+  RefPtr<SyncManager> mSyncManager;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif /* mozilla_dom_ServiceWorkerRegistration_h */
