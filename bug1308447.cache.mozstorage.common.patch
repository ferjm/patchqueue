# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  2fd5888afa2d384b85c136dae0e0db8c49a69ce5
Bug 1308447 - Use mozStorageConnectionUtils and IncrementalVacuumConnection in dom/cache. r=bkelly

diff --git a/dom/cache/Connection.cpp b/dom/cache/Connection.cpp
deleted file mode 100644
--- a/dom/cache/Connection.cpp
+++ /dev/null
@@ -1,286 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/cache/Connection.h"
-
-#include "mozilla/dom/cache/DBSchema.h"
-#include "mozStorageHelper.h"
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-using mozilla::dom::quota::QuotaObject;
-
-NS_IMPL_ISUPPORTS(cache::Connection, mozIStorageAsyncConnection,
-                                     mozIStorageConnection);
-
-Connection::Connection(mozIStorageConnection* aBase)
-  : mBase(aBase)
-  , mClosed(false)
-{
-  MOZ_ASSERT(mBase);
-}
-
-Connection::~Connection()
-{
-  NS_ASSERT_OWNINGTHREAD(Connection);
-  MOZ_ALWAYS_SUCCEEDS(Close());
-}
-
-NS_IMETHODIMP
-Connection::Close()
-{
-  NS_ASSERT_OWNINGTHREAD(Connection);
-
-  if (mClosed) {
-    return NS_OK;
-  }
-  mClosed = true;
-
-  // If we are closing here, then Cache must not have a transaction
-  // open anywhere else.  This should be guaranteed to succeed.
-  MOZ_ALWAYS_SUCCEEDS(db::IncrementalVacuum(this));
-
-  return mBase->Close();
-}
-
-// The following methods are all boilerplate that either forward to the
-// base connection or block the method.  All the async execution methods
-// are blocked because Cache does not use them and they would require more
-// work to wrap properly.
-
-// mozIStorageAsyncConnection methods
-
-NS_IMETHODIMP
-Connection::AsyncClose(mozIStorageCompletionCallback*)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::AsyncClone(bool, mozIStorageCompletionCallback*)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::GetDatabaseFile(nsIFile** aFileOut)
-{
-  return mBase->GetDatabaseFile(aFileOut);
-}
-
-NS_IMETHODIMP
-Connection::CreateAsyncStatement(const nsACString&, mozIStorageAsyncStatement**)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::ExecuteAsync(mozIStorageBaseStatement**, uint32_t,
-                         mozIStorageStatementCallback*,
-                         mozIStoragePendingStatement**)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::ExecuteSimpleSQLAsync(const nsACString&,
-                                  mozIStorageStatementCallback*,
-                                  mozIStoragePendingStatement**)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::CreateFunction(const nsACString& aFunctionName,
-                           int32_t aNumArguments,
-                           mozIStorageFunction* aFunction)
-{
-  // async methods are not supported
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-Connection::CreateAggregateFunction(const nsACString& aFunctionName,
-                                    int32_t aNumArguments,
-                                    mozIStorageAggregateFunction* aFunction)
-{
-  return mBase->CreateAggregateFunction(aFunctionName, aNumArguments,
-                                        aFunction);
-}
-
-NS_IMETHODIMP
-Connection::RemoveFunction(const nsACString& aFunctionName)
-{
-  return mBase->RemoveFunction(aFunctionName);
-}
-
-NS_IMETHODIMP
-Connection::SetProgressHandler(int32_t aGranularity,
-                               mozIStorageProgressHandler* aHandler,
-                               mozIStorageProgressHandler** aHandlerOut)
-{
-  return mBase->SetProgressHandler(aGranularity, aHandler, aHandlerOut);
-}
-
-NS_IMETHODIMP
-Connection::RemoveProgressHandler(mozIStorageProgressHandler** aHandlerOut)
-{
-  return mBase->RemoveProgressHandler(aHandlerOut);
-}
-
-// mozIStorageConnection methods
-
-NS_IMETHODIMP
-Connection::Clone(bool aReadOnly, mozIStorageConnection** aConnectionOut)
-{
-  nsCOMPtr<mozIStorageConnection> conn;
-  nsresult rv = mBase->Clone(aReadOnly, getter_AddRefs(conn));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  nsCOMPtr<mozIStorageConnection> wrapped = new Connection(conn);
-  wrapped.forget(aConnectionOut);
-
-  return rv;
-}
-
-NS_IMETHODIMP
-Connection::GetDefaultPageSize(int32_t* aSizeOut)
-{
-  return mBase->GetDefaultPageSize(aSizeOut);
-}
-
-NS_IMETHODIMP
-Connection::GetConnectionReady(bool* aReadyOut)
-{
-  return mBase->GetConnectionReady(aReadyOut);
-}
-
-NS_IMETHODIMP
-Connection::GetLastInsertRowID(int64_t* aRowIdOut)
-{
-  return mBase->GetLastInsertRowID(aRowIdOut);
-}
-
-NS_IMETHODIMP
-Connection::GetAffectedRows(int32_t* aCountOut)
-{
-  return mBase->GetAffectedRows(aCountOut);
-}
-
-NS_IMETHODIMP
-Connection::GetLastError(int32_t* aErrorOut)
-{
-  return mBase->GetLastError(aErrorOut);
-}
-
-NS_IMETHODIMP
-Connection::GetLastErrorString(nsACString& aErrorOut)
-{
-  return mBase->GetLastErrorString(aErrorOut);
-}
-
-NS_IMETHODIMP
-Connection::GetSchemaVersion(int32_t* aVersionOut)
-{
-  return mBase->GetSchemaVersion(aVersionOut);
-}
-
-NS_IMETHODIMP
-Connection::SetSchemaVersion(int32_t aVersion)
-{
-  return mBase->SetSchemaVersion(aVersion);
-}
-
-NS_IMETHODIMP
-Connection::CreateStatement(const nsACString& aQuery,
-                            mozIStorageStatement** aStatementOut)
-{
-  return mBase->CreateStatement(aQuery, aStatementOut);
-}
-
-NS_IMETHODIMP
-Connection::ExecuteSimpleSQL(const nsACString& aQuery)
-{
-  return mBase->ExecuteSimpleSQL(aQuery);
-}
-
-NS_IMETHODIMP
-Connection::TableExists(const nsACString& aTableName, bool* aExistsOut)
-{
-  return mBase->TableExists(aTableName, aExistsOut);
-}
-
-NS_IMETHODIMP
-Connection::IndexExists(const nsACString& aIndexName, bool* aExistsOut)
-{
-  return mBase->IndexExists(aIndexName, aExistsOut);
-}
-
-NS_IMETHODIMP
-Connection::GetTransactionInProgress(bool* aResultOut)
-{
-  return mBase->GetTransactionInProgress(aResultOut);
-}
-
-NS_IMETHODIMP
-Connection::BeginTransaction()
-{
-  return mBase->BeginTransaction();
-}
-
-NS_IMETHODIMP
-Connection::BeginTransactionAs(int32_t aType)
-{
-  return mBase->BeginTransactionAs(aType);
-}
-
-NS_IMETHODIMP
-Connection::CommitTransaction()
-{
-  return mBase->CommitTransaction();
-}
-
-NS_IMETHODIMP
-Connection::RollbackTransaction()
-{
-  return mBase->RollbackTransaction();
-}
-
-NS_IMETHODIMP
-Connection::CreateTable(const char* aTable, const char* aSchema)
-{
-  return mBase->CreateTable(aTable, aSchema);
-}
-
-NS_IMETHODIMP
-Connection::SetGrowthIncrement(int32_t aIncrement, const nsACString& aDatabase)
-{
-  return mBase->SetGrowthIncrement(aIncrement, aDatabase);
-}
-
-NS_IMETHODIMP
-Connection::EnableModule(const nsACString& aModule)
-{
-  return mBase->EnableModule(aModule);
-}
-
-NS_IMETHODIMP
-Connection::GetQuotaObjects(QuotaObject** aDatabaseQuotaObject,
-                            QuotaObject** aJournalQuotaObject)
-{
-  return mBase->GetQuotaObjects(aDatabaseQuotaObject, aJournalQuotaObject);
-}
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/Connection.h b/dom/cache/Connection.h
deleted file mode 100644
--- a/dom/cache/Connection.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_Connection_h
-#define mozilla_dom_cache_Connection_h
-
-#include "mozIStorageConnection.h"
-#include "nsCOMPtr.h"
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-class Connection final : public mozIStorageConnection
-{
-public:
-  explicit Connection(mozIStorageConnection* aBase);
-
-private:
-  ~Connection();
-
-  nsCOMPtr<mozIStorageConnection> mBase;
-  bool mClosed;
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_MOZISTORAGEASYNCCONNECTION
-  NS_DECL_MOZISTORAGECONNECTION
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_Connection_h
diff --git a/dom/cache/DBAction.cpp b/dom/cache/DBAction.cpp
--- a/dom/cache/DBAction.cpp
+++ b/dom/cache/DBAction.cpp
@@ -1,21 +1,21 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/DBAction.h"
 
-#include "mozilla/dom/cache/Connection.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/quota/PersistenceType.h"
 #include "mozilla/net/nsFileProtocolHandler.h"
+#include "mozilla/storage.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
 #include "mozStorageCID.h"
 #include "nsIFile.h"
 #include "nsIURI.h"
 #include "nsIFileURL.h"
 #include "nsThreadUtils.h"
 
@@ -79,17 +79,18 @@ DBAction::RunOnTarget(Resolver* aResolve
 
     // Save this connection in the shared Data object so later Actions can
     // use it.  This avoids opening a new connection for every Action.
     if (aOptionalData) {
       // Since we know this connection will be around for as long as the
       // Cache is open, use our special wrapped connection class.  This
       // will let us perform certain operations once the Cache origin
       // is closed.
-      nsCOMPtr<mozIStorageConnection> wrapped = new Connection(conn);
+      nsCOMPtr<mozIStorageConnection> wrapped =
+        new storage::IncrementalVacuumConnection(conn, db::kMaxFreePages);
       aOptionalData->SetConnection(wrapped);
     }
   }
 
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
diff --git a/dom/cache/DBSchema.cpp b/dom/cache/DBSchema.cpp
--- a/dom/cache/DBSchema.cpp
+++ b/dom/cache/DBSchema.cpp
@@ -28,16 +28,20 @@
 #include "nsPrintfCString.h"
 #include "nsTArray.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 namespace db {
 
+using storage::utils::Expect;
+using storage::utils::Migration;
+using storage::utils::SchemaRewrite;
+
 const int32_t kFirstShippedSchemaVersion = 15;
 
 namespace {
 
 // Update this whenever the DB schema is changed.
 const int32_t kLatestSchemaVersion = 22;
 
 // ---------
@@ -162,27 +166,16 @@ const char* const kTableStorage =
   ")";
 
 // ---------
 // End schema definition
 // ---------
 
 const int32_t kMaxEntriesPerStatement = 255;
 
-const uint32_t kPageSize = 4 * 1024;
-
-// Grow the database in chunks to reduce fragmentation
-const uint32_t kGrowthSize = 32 * 1024;
-const uint32_t kGrowthPages = kGrowthSize / kPageSize;
-static_assert(kGrowthSize % kPageSize == 0,
-              "Growth size must be multiple of page size");
-
-// Only release free pages when we have more than this limit
-const int32_t kMaxFreePages = kGrowthPages;
-
 // Limit WAL journal to a reasonable size
 const uint32_t kWalAutoCheckpointSize = 512 * 1024;
 const uint32_t kWalAutoCheckpointPages = kWalAutoCheckpointSize / kPageSize;
 static_assert(kWalAutoCheckpointSize % kPageSize == 0,
               "WAL checkpoint size must be multiple of page size");
 
 } // namespace
 
@@ -350,228 +343,111 @@ static nsresult BindId(mozIStorageStatem
 static nsresult ExtractId(mozIStorageStatement* aState, uint32_t aPos,
                           nsID* aIdOut);
 static nsresult CreateAndBindKeyStatement(mozIStorageConnection* aConn,
                                           const char* aQueryFormat,
                                           const nsAString& aKey,
                                           mozIStorageStatement** aStateOut);
 static nsresult HashCString(nsICryptoHash* aCrypto, const nsACString& aIn,
                             nsACString& aOut);
-nsresult Validate(mozIStorageConnection* aConn);
-nsresult Migrate(mozIStorageConnection* aConn);
+
+// Declare migration functions here.  Each function should upgrade
+// the version by a single increment.  Don't skip versions.
+nsresult MigrateFrom15To16(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom16To17(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom17To18(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom18To19(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom19To20(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom20To21(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+nsresult MigrateFrom21To22(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql);
+
+const char* const kRewriteEntriesSchema =
+  "UPDATE sqlite_master SET sql=:sql WHERE name='entries'";
+
 } // namespace
 
-class MOZ_RAII AutoDisableForeignKeyChecking
-{
-public:
-  explicit AutoDisableForeignKeyChecking(mozIStorageConnection* aConn)
-    : mConn(aConn)
-    , mForeignKeyCheckingDisabled(false)
-  {
-    nsCOMPtr<mozIStorageStatement> state;
-    nsresult rv = mConn->CreateStatement(NS_LITERAL_CSTRING(
-      "PRAGMA foreign_keys;"
-    ), getter_AddRefs(state));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-
-    bool hasMoreData = false;
-    rv = state->ExecuteStep(&hasMoreData);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-
-    int32_t mode;
-    rv = state->GetInt32(0, &mode);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-
-    if (mode) {
-      nsresult rv = mConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-        "PRAGMA foreign_keys = OFF;"
-      ));
-      if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-      mForeignKeyCheckingDisabled = true;
-    }
-  }
-
-  ~AutoDisableForeignKeyChecking()
-  {
-    if (mForeignKeyCheckingDisabled) {
-      nsresult rv = mConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-        "PRAGMA foreign_keys = ON;"
-      ));
-      if (NS_WARN_IF(NS_FAILED(rv))) { return; }
-    }
-  }
-
-private:
-  nsCOMPtr<mozIStorageConnection> mConn;
-  bool mForeignKeyCheckingDisabled;
-};
-
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
-  int32_t schemaVersion;
-  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (schemaVersion == kLatestSchemaVersion) {
-    // We already have the correct schema version.  Validate it matches
-    // our expected schema and then proceed.
-    rv = Validate(aConn);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    return rv;
-  }
-
-  // Turn off checking foreign keys before starting a transaction, and restore
-  // it once we're done.
-  AutoDisableForeignKeyChecking restoreForeignKeyChecking(aConn);
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-  bool needVacuum = false;
-
-  if (schemaVersion) {
-    // A schema exists, but its not the current version.  Attempt to
-    // migrate it to our new schema.
-    rv = Migrate(aConn);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    // Migrations happen infrequently and reflect a chance in DB structure.
-    // This is a good time to rebuild the database.  It also helps catch
-    // if a new migration is incorrect by fast failing on the corruption.
-    needVacuum = true;
-  } else {
-    // There is no schema installed.  Create the database from scratch.
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableCaches));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableSecurityInfo));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kIndexSecurityInfoHash));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableEntries));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kIndexEntriesRequest));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableRequestHeaders));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableResponseHeaders));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kIndexResponseHeadersName));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableResponseUrlList));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(kTableStorage));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->SetSchemaVersion(kLatestSchemaVersion);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->GetSchemaVersion(&schemaVersion);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  }
-
-  rv = Validate(aConn);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = trans.Commit();
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (needVacuum) {
-    // Unfortunately, this must be performed outside of the transaction.
-    aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("VACUUM"));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  }
-
-  return rv;
+  nsTArray<nsCString> tablesSql;
+  tablesSql.AppendElement(nsCString(kTableCaches));
+  tablesSql.AppendElement(nsCString(kTableSecurityInfo));
+  tablesSql.AppendElement(nsCString(kTableEntries));
+  tablesSql.AppendElement(nsCString(kTableRequestHeaders));
+  tablesSql.AppendElement(nsCString(kTableResponseHeaders));
+  tablesSql.AppendElement(nsCString(kTableResponseUrlList));
+  tablesSql.AppendElement(nsCString(kTableStorage));
+
+  nsTArray<Expect> expect;
+  expect.AppendElement(Expect("caches", "table", kTableCaches));
+  expect.AppendElement(Expect("sqlite_sequence", "table"));
+  expect.AppendElement(Expect("security_info", "table", kTableSecurityInfo));
+  expect.AppendElement(Expect("security_info_hash_index", "index",
+                       kIndexSecurityInfoHash));
+  expect.AppendElement(Expect("entries", "table", kTableEntries));
+  expect.AppendElement(Expect("entries_request_match_index", "index",
+                       kIndexEntriesRequest));
+  expect.AppendElement(Expect("request_headers", "table",
+                       kTableRequestHeaders));
+  expect.AppendElement(Expect("response_headers", "table",
+                       kTableResponseHeaders));
+  expect.AppendElement(Expect("response_headers_name_index", "index",
+                       kIndexResponseHeadersName));
+  expect.AppendElement(Expect("response_url_list", "table",
+                       kTableResponseUrlList));
+  expect.AppendElement(Expect("storage", "table", kTableStorage));
+  expect.AppendElement(Expect("sqlite_autoindex_storage_1", "index"));
+
+  nsTArray<Migration> migrationList;
+  migrationList.AppendElement(Migration(15, MigrateFrom15To16));
+  migrationList.AppendElement(Migration(16, MigrateFrom16To17));
+  migrationList.AppendElement(Migration(17, MigrateFrom17To18));
+  migrationList.AppendElement(Migration(18, MigrateFrom18To19));
+  migrationList.AppendElement(Migration(19, MigrateFrom19To20));
+  migrationList.AppendElement(Migration(20, MigrateFrom20To21));
+  migrationList.AppendElement(Migration(21, MigrateFrom21To22));
+
+  return storage::utils::CreateOrMigrateSchema(aConn,
+                                               kFirstShippedSchemaVersion,
+                                               kLatestSchemaVersion, tablesSql,
+                                               expect, migrationList);
 }
 
 nsresult
 InitializeConnection(mozIStorageConnection* aConn)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
-  // This function needs to perform per-connection initialization tasks that
-  // need to happen regardless of the schema.
-
-  nsPrintfCString pragmas(
-    // Use a smaller page size to improve perf/footprint; default is too large
-    "PRAGMA page_size = %u; "
-    // Enable auto_vacuum; this must happen after page_size and before WAL
-    "PRAGMA auto_vacuum = INCREMENTAL; "
-    "PRAGMA foreign_keys = ON; ",
-    kPageSize
-  );
-
-  // Note, the default encoding of UTF-8 is preferred.  mozStorage does all
-  // the work necessary to convert UTF-16 nsString values for us.  We don't
-  // need ordering and the binary equality operations are correct.  So, do
-  // NOT set PRAGMA encoding to UTF-16.
-
-  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Limit fragmentation by growing the database by many pages at once.
-  rv = aConn->SetGrowthIncrement(kGrowthSize, EmptyCString());
-  if (rv == NS_ERROR_FILE_TOO_BIG) {
-    NS_WARNING("Not enough disk space to set sqlite growth increment.");
-    rv = NS_OK;
-  }
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Enable WAL journaling.  This must be performed in a separate transaction
-  // after changing the page_size and enabling auto_vacuum.
-  nsPrintfCString wal(
-    // WAL journal can grow to given number of *pages*
-    "PRAGMA wal_autocheckpoint = %u; "
-    // Always truncate the journal back to given number of *bytes*
-    "PRAGMA journal_size_limit = %u; "
-    // WAL must be enabled at the end to allow page size to be changed, etc.
-    "PRAGMA journal_mode = WAL; ",
-    kWalAutoCheckpointPages,
-    kWalAutoCheckpointSize
-  );
-
-  rv = aConn->ExecuteSimpleSQL(wal);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Verify that we successfully set the vacuum mode to incremental.  It
-  // is very easy to put the database in a state where the auto_vacuum
-  // pragma above fails silently.
-#ifdef DEBUG
-  nsCOMPtr<mozIStorageStatement> state;
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA auto_vacuum;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  int32_t mode;
-  rv = state->GetInt32(0, &mode);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // integer value 2 is incremental mode
-  if (NS_WARN_IF(mode != 2)) { return NS_ERROR_UNEXPECTED; }
-#endif
-
-  return NS_OK;
+  return storage::utils::InitializeConnection(aConn, kPageSize, kGrowthSize,
+                                              kWalAutoCheckpointPages,
+                                              kWalAutoCheckpointSize);
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return storage::utils::IncrementalVacuum(aConn, kMaxFreePages);
 }
 
 nsresult
 CreateCacheId(mozIStorageConnection* aConn, CacheId* aCacheIdOut)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
   MOZ_ASSERT(aCacheIdOut);
@@ -2288,305 +2164,25 @@ HashCString(nsICryptoHash* aCrypto, cons
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   aOut = Substring(fullHash, 0, 8);
   return rv;
 }
 
 } // namespace
 
-nsresult
-IncrementalVacuum(mozIStorageConnection* aConn)
-{
-  // Determine how much free space is in the database.
-  nsCOMPtr<mozIStorageStatement> state;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA freelist_count;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  int32_t freePages = 0;
-  rv = state->GetInt32(0, &freePages);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // We have a relatively small page size, so we want to be careful to avoid
-  // fragmentation.  We already use a growth incremental which will cause
-  // sqlite to allocate and release multiple pages at the same time.  We can
-  // further reduce fragmentation by making our allocated chunks a bit
-  // "sticky".  This is done by creating some hysteresis where we allocate
-  // pages/chunks as soon as we need them, but we only release pages/chunks
-  // when we have a large amount of free space.  This helps with the case
-  // where a page is adding and remove resources causing it to dip back and
-  // forth across a chunk boundary.
-  //
-  // So only proceed with releasing pages if we have more than our constant
-  // threshold.
-  if (freePages <= kMaxFreePages) {
-    return NS_OK;
-  }
-
-  // Release the excess pages back to the sqlite VFS.  This may also release
-  // chunks of multiple pages back to the OS.
-  int32_t pagesToRelease = freePages - kMaxFreePages;
-
-  rv = aConn->ExecuteSimpleSQL(nsPrintfCString(
-    "PRAGMA incremental_vacuum(%d);", pagesToRelease
-  ));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Verify that our incremental vacuum actually did something
-#ifdef DEBUG
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA freelist_count;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  freePages = 0;
-  rv = state->GetInt32(0, &freePages);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  MOZ_ASSERT(freePages <= kMaxFreePages);
-#endif
-
-  return NS_OK;
-}
-
 namespace {
 
-#ifdef DEBUG
-struct Expect
-{
-  // Expect exact SQL
-  Expect(const char* aName, const char* aType, const char* aSql)
-    : mName(aName)
-    , mType(aType)
-    , mSql(aSql)
-    , mIgnoreSql(false)
-  { }
-
-  // Ignore SQL
-  Expect(const char* aName, const char* aType)
-    : mName(aName)
-    , mType(aType)
-    , mIgnoreSql(true)
-  { }
-
-  const nsCString mName;
-  const nsCString mType;
-  const nsCString mSql;
-  const bool mIgnoreSql;
-};
-#endif
-
-nsresult
-Validate(mozIStorageConnection* aConn)
-{
-  int32_t schemaVersion;
-  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (NS_WARN_IF(schemaVersion != kLatestSchemaVersion)) {
-    return NS_ERROR_FAILURE;
-  }
-
-#ifdef DEBUG
-  // This is the schema we expect the database at the latest version to
-  // contain.  Update this list if you add a new table or index.
-  Expect expect[] = {
-    Expect("caches", "table", kTableCaches),
-    Expect("sqlite_sequence", "table"), // auto-gen by sqlite
-    Expect("security_info", "table", kTableSecurityInfo),
-    Expect("security_info_hash_index", "index", kIndexSecurityInfoHash),
-    Expect("entries", "table", kTableEntries),
-    Expect("entries_request_match_index", "index", kIndexEntriesRequest),
-    Expect("request_headers", "table", kTableRequestHeaders),
-    Expect("response_headers", "table", kTableResponseHeaders),
-    Expect("response_headers_name_index", "index", kIndexResponseHeadersName),
-    Expect("response_url_list", "table", kTableResponseUrlList),
-    Expect("storage", "table", kTableStorage),
-    Expect("sqlite_autoindex_storage_1", "index"), // auto-gen by sqlite
-  };
-  const uint32_t expectLength = sizeof(expect) / sizeof(Expect);
-
-  // Read the schema from the sqlite_master table and compare.
-  nsCOMPtr<mozIStorageStatement> state;
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT name, type, sql FROM sqlite_master;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    nsAutoCString name;
-    rv = state->GetUTF8String(0, name);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    nsAutoCString type;
-    rv = state->GetUTF8String(1, type);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    nsAutoCString sql;
-    rv = state->GetUTF8String(2, sql);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    bool foundMatch = false;
-    for (uint32_t i = 0; i < expectLength; ++i) {
-      if (name == expect[i].mName) {
-        if (type != expect[i].mType) {
-          NS_WARNING(nsPrintfCString("Unexpected type for Cache schema entry %s",
-                     name.get()).get());
-          return NS_ERROR_FAILURE;
-        }
-
-        if (!expect[i].mIgnoreSql && sql != expect[i].mSql) {
-          NS_WARNING(nsPrintfCString("Unexpected SQL for Cache schema entry %s",
-                     name.get()).get());
-          return NS_ERROR_FAILURE;
-        }
-
-        foundMatch = true;
-        break;
-      }
-    }
-
-    if (NS_WARN_IF(!foundMatch)) {
-      NS_WARNING(nsPrintfCString("Unexpected schema entry %s in Cache database",
-                 name.get()).get());
-      return NS_ERROR_FAILURE;
-    }
-  }
-#endif
-
-  return rv;
-}
-
 // -----
 // Schema migration code
 // -----
 
-typedef nsresult (*MigrationFunc)(mozIStorageConnection*, bool&);
-struct Migration
-{
-  constexpr Migration(int32_t aFromVersion, MigrationFunc aFunc)
-    : mFromVersion(aFromVersion)
-    , mFunc(aFunc)
-  { }
-  int32_t mFromVersion;
-  MigrationFunc mFunc;
-};
-
-// Declare migration functions here.  Each function should upgrade
-// the version by a single increment.  Don't skip versions.
-nsresult MigrateFrom15To16(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom16To17(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom17To18(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom18To19(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom19To20(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom20To21(mozIStorageConnection* aConn, bool& aRewriteSchema);
-nsresult MigrateFrom21To22(mozIStorageConnection* aConn, bool& aRewriteSchema);
-
-// Configure migration functions to run for the given starting version.
-Migration sMigrationList[] = {
-  Migration(15, MigrateFrom15To16),
-  Migration(16, MigrateFrom16To17),
-  Migration(17, MigrateFrom17To18),
-  Migration(18, MigrateFrom18To19),
-  Migration(19, MigrateFrom19To20),
-  Migration(20, MigrateFrom20To21),
-  Migration(21, MigrateFrom21To22),
-};
-
-uint32_t sMigrationListLength = sizeof(sMigrationList) / sizeof(Migration);
-
-nsresult
-RewriteEntriesSchema(mozIStorageConnection* aConn)
-{
-  nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "PRAGMA writable_schema = ON"
-  ));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  nsCOMPtr<mozIStorageStatement> state;
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "UPDATE sqlite_master SET sql=:sql WHERE name='entries'"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("sql"),
-                                   nsDependentCString(kTableEntries));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = state->Execute();
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
-    "PRAGMA writable_schema = OFF"
-  ));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  return rv;
-}
-
-nsresult
-Migrate(mozIStorageConnection* aConn)
-{
-  MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-
-  int32_t currentVersion = 0;
-  nsresult rv = aConn->GetSchemaVersion(&currentVersion);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool rewriteSchema = false;
-
-  while (currentVersion < kLatestSchemaVersion) {
-    // Wiping old databases is handled in DBAction because it requires
-    // making a whole new mozIStorageConnection.  Make sure we don't
-    // accidentally get here for one of those old databases.
-    MOZ_ASSERT(currentVersion >= kFirstShippedSchemaVersion);
-
-    for (uint32_t i = 0; i < sMigrationListLength; ++i) {
-      if (sMigrationList[i].mFromVersion == currentVersion) {
-        bool shouldRewrite = false;
-        rv = sMigrationList[i].mFunc(aConn, shouldRewrite);
-        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-        if (shouldRewrite) {
-          rewriteSchema = true;
-        }
-        break;
-      }
-    }
-
-    DebugOnly<int32_t> lastVersion = currentVersion;
-    rv = aConn->GetSchemaVersion(&currentVersion);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-    MOZ_ASSERT(currentVersion > lastVersion);
-  }
-
-  MOZ_ASSERT(currentVersion == kLatestSchemaVersion);
-
-  if (rewriteSchema) {
-    // Now overwrite the master SQL for the entries table to remove the column
-    // default value.  This is also necessary for our Validate() method to
-    // pass on this database.
-    rv = RewriteEntriesSchema(aConn);
-  }
-
-  return rv;
-}
-
-nsresult MigrateFrom15To16(mozIStorageConnection* aConn, bool& aRewriteSchema)
+nsresult MigrateFrom15To16(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // Add the request_redirect column with a default value of "follow".  Note,
   // we only use a default value here because its required by ALTER TABLE and
   // we need to apply the default "follow" to existing records in the table.
   // We don't actually want to keep the default in the schema for future
@@ -2595,23 +2191,24 @@ nsresult MigrateFrom15To16(mozIStorageCo
     "ALTER TABLE entries "
     "ADD COLUMN request_redirect INTEGER NOT NULL DEFAULT 0"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->SetSchemaVersion(16);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  aRewriteSchema = true;
+  aSchemaRewriteTable = NS_LITERAL_CSTRING("entries");
+  aSchemaRewriteSql = kRewriteEntriesSchema;
 
   return rv;
 }
 
 nsresult
-MigrateFrom16To17(mozIStorageConnection* aConn, bool& aRewriteSchema)
+MigrateFrom16To17(mozIStorageConnection* aConn, nsACString&, nsACString&)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // This migration path removes the response_redirected and
   // response_redirected_url columns from the entries table.  sqlite doesn't
   // support removing a column from a table using ALTER TABLE, so we need to
   // create a new table without those columns, fill it up with the existing
@@ -2733,17 +2330,17 @@ MigrateFrom16To17(mozIStorageConnection*
 
   rv = aConn->SetSchemaVersion(17);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 nsresult
-MigrateFrom17To18(mozIStorageConnection* aConn, bool& aRewriteSchema)
+MigrateFrom17To18(mozIStorageConnection* aConn, nsACString&, nsACString&)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // This migration is needed in order to remove "only-if-cached" RequestCache
   // values from the database.  This enum value was removed from the spec in
   // https://github.com/whatwg/fetch/issues/39 but we unfortunately happily
   // accepted this value in the Request constructor.
@@ -2760,17 +2357,17 @@ MigrateFrom17To18(mozIStorageConnection*
 
   rv = aConn->SetSchemaVersion(18);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 nsresult
-MigrateFrom18To19(mozIStorageConnection* aConn, bool& aRewriteSchema)
+MigrateFrom18To19(mozIStorageConnection* aConn, nsACString&, nsACString&)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // This migration is needed in order to update the RequestMode values for
   // Request objects corresponding to a navigation content policy type to
   // "navigate".
 
@@ -2788,17 +2385,19 @@ MigrateFrom18To19(mozIStorageConnection*
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->SetSchemaVersion(19);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
-nsresult MigrateFrom19To20(mozIStorageConnection* aConn, bool& aRewriteSchema)
+nsresult MigrateFrom19To20(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // Add the request_referrer_policy column with a default value of
   // "no-referrer-when-downgrade".  Note, we only use a default value here
   // because its required by ALTER TABLE and we need to apply the default
   // "no-referrer-when-downgrade" to existing records in the table. We don't
@@ -2807,22 +2406,25 @@ nsresult MigrateFrom19To20(mozIStorageCo
     "ALTER TABLE entries "
     "ADD COLUMN request_referrer_policy INTEGER NOT NULL DEFAULT 2"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->SetSchemaVersion(20);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  aRewriteSchema = true;
+  aSchemaRewriteTable = NS_LITERAL_CSTRING("entries");
+  aSchemaRewriteSql = kRewriteEntriesSchema;
 
   return rv;
 }
 
-nsresult MigrateFrom20To21(mozIStorageConnection* aConn, bool& aRewriteSchema)
+nsresult MigrateFrom20To21(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // This migration creates response_url_list table to store response_url and
   // removes the response_url column from the entries table.
   // sqlite doesn't support removing a column from a table using ALTER TABLE,
   // so we need to create a new table without those columns, fill it up with the
@@ -2961,37 +2563,41 @@ nsresult MigrateFrom20To21(mozIStorageCo
   bool hasMoreData = false;
   rv = state->ExecuteStep(&hasMoreData);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   if (NS_WARN_IF(hasMoreData)) { return NS_ERROR_FAILURE; }
 
   rv = aConn->SetSchemaVersion(21);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  aRewriteSchema = true;
+  aSchemaRewriteTable = NS_LITERAL_CSTRING("entries");
+  aSchemaRewriteSql = kRewriteEntriesSchema;
 
   return rv;
 }
 
-nsresult MigrateFrom21To22(mozIStorageConnection* aConn, bool& aRewriteSchema)
+nsresult MigrateFrom21To22(mozIStorageConnection* aConn,
+                           nsACString& aSchemaRewriteTable,
+                           nsACString& aSchemaRewriteSql)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   // Add the request_integrity column.
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "ALTER TABLE entries "
     "ADD COLUMN request_integrity TEXT NULL"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->SetSchemaVersion(22);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-  aRewriteSchema = true;
+  aSchemaRewriteTable = NS_LITERAL_CSTRING("entries");
+  aSchemaRewriteSql = kRewriteEntriesSchema;
 
   return rv;
 }
 
 } // anonymous namespace
 
 } // namespace db
 } // namespace cache
diff --git a/dom/cache/DBSchema.h b/dom/cache/DBSchema.h
--- a/dom/cache/DBSchema.h
+++ b/dom/cache/DBSchema.h
@@ -116,14 +116,25 @@ StorageGetKeys(mozIStorageConnection* aC
 // Note, this works best when its NOT executed within a transaction.
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn);
 
 // We will wipe out databases with a schema versions less than this.  Newer
 // versions will be migrated on open to the latest schema version.
 extern const int32_t kFirstShippedSchemaVersion;
 
+const uint32_t kPageSize = 4 * 1024;
+
+// Grow the database in chunks to reduce fragmentation
+const uint32_t kGrowthSize = 32 * 1024;
+const uint32_t kGrowthPages = kGrowthSize / kPageSize;
+static_assert(kGrowthSize % kPageSize == 0,
+              "Growth size must be multiple of page size");
+
+// Only release free pages when we have more than this limit
+extern const int32_t kMaxFreePages = kGrowthPages;
+
 } // namespace db
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_DBSchema_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -14,17 +14,16 @@ EXPORTS.mozilla.dom.cache += [
     'CacheOpParent.h',
     'CacheParent.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlParent.h',
     'CacheWorkerHolder.h',
-    'Connection.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
     'PrincipalVerifier.h',
     'QuotaClient.h',
@@ -45,17 +44,16 @@ UNIFIED_SOURCES += [
     'CacheOpParent.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'CacheWorkerHolder.cpp',
-    'Connection.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'PrincipalVerifier.cpp',
     'QuotaClient.cpp',
     'ReadStream.cpp',
diff --git a/storage/mozStorageConnectionUtils.cpp b/storage/mozStorageConnectionUtils.cpp
--- a/storage/mozStorageConnectionUtils.cpp
+++ b/storage/mozStorageConnectionUtils.cpp
@@ -122,102 +122,109 @@ Validate(mozIStorageConnection* aConn,
   }
 #endif
 
   return rv;
 }
 
 nsresult
 RewriteSchema(mozIStorageConnection* aConn,
-              const SchemaRewrite& aSchemaRewrite)
+              SchemaRewrite* aSchemaRewrite)
 {
   nsresult rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "PRAGMA writable_schema = ON"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsCOMPtr<mozIStorageStatement> state;
   rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "UPDATE sqlite_master SET sql=:sql WHERE name=:name"
   ), getter_AddRefs(state));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("sql"),
-                                   aSchemaRewrite.mTableSql);
+                                   aSchemaRewrite->mSql);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("name"),
-                                   aSchemaRewrite.mTableName);
+                                   aSchemaRewrite->mTable);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = state->Execute();
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   rv = aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING(
     "PRAGMA writable_schema = OFF"
   ));
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   return rv;
 }
 
 nsresult
 Migrate(mozIStorageConnection* aConn,
+        const int32_t aFirstShippedSchemaVersion,
         const int32_t aLatestSchemaVersion,
-        const int32_t aFirstShippedSchemaVersion,
         const nsTArray<Migration>& aMigrationList)
 {
+  printf_stderr("Migrate\n");
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   int32_t currentVersion = 0;
   nsresult rv = aConn->GetSchemaVersion(&currentVersion);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
   nsClassHashtable<nsCStringHashKey, nsCString> schemaRewrites;
 
+  printf_stderr("currentVersion < aLatestSchemaVersion %d < %d\n",
+                 currentVersion, aLatestSchemaVersion);
   while (currentVersion < aLatestSchemaVersion) {
+    printf_stderr("currentVersion %d\n", currentVersion);
     // Wiping old database should be handled elsewhere because it requires
     // making a whole new mozIStorageConnection.  Make sure we don't
     // accidentally get here for one of those old databases.
     MOZ_ASSERT(currentVersion >= aFirstShippedSchemaVersion);
 
     for (uint32_t i = 0; i < aMigrationList.Length(); ++i) {
       if (aMigrationList[i].mFromVersion == currentVersion) {
-        SchemaRewrite schemaRewrite;
-        rv = aMigrationList[i].mFunc(aConn, schemaRewrite);
-        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-        if (!schemaRewrite.mTableName.IsEmpty() &&
-            !schemaRewrite.mTableSql.IsEmpty() &&
-            !schemaRewrites.Contains(schemaRewrite.mTableName)) {
-          schemaRewrites.Put(schemaRewrite.mTableName, &schemaRewrite.mTableSql);
+        nsAutoCString name, sql;
+        rv = aMigrationList[i].mFunc(aConn, name, sql);
+        RefPtr<SchemaRewrite> schemaRewrite = new SchemaRewrite(name, sql);
+        if (!schemaRewrite->mTable.IsEmpty() &&
+            !schemaRewrites.Contains(schemaRewrite->mTable)) {
+          printf_stderr("Adding schemarewrite\n");
+          schemaRewrites.Put(schemaRewrite->mTable, &schemaRewrite->mSql);
         }
         break;
       }
     }
 
     DebugOnly<int32_t> lastVersion = currentVersion;
     rv = aConn->GetSchemaVersion(&currentVersion);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
     MOZ_ASSERT(currentVersion > lastVersion);
   }
 
+  printf_stderr("currentVersion == aLatestSchemaVersion %d == %d\n", currentVersion, aLatestSchemaVersion);
   MOZ_ASSERT(currentVersion == aLatestSchemaVersion);
 
   // Now overwrite the master SQL for each table that requires so.
   for (auto iter = schemaRewrites.Iter(); !iter.Done(); iter.Next()) {
-    SchemaRewrite rewrite;
-    rewrite.mTableName = iter.Key();
-    rewrite.mTableSql = *schemaRewrites.Get(iter.Key());
+    printf_stderr("Schema rewrite\n");
+    RefPtr<SchemaRewrite> rewrite;
+    rewrite->mTable = iter.Key();
+    rewrite->mSql = *schemaRewrites.Get(iter.Key());
     rv = RewriteSchema(aConn, rewrite);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
   }
 
   schemaRewrites.Clear();
 
+  printf_stderr("return\n");
   return rv;
 }
 
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn,
                       const int32_t aFirstShippedSchemaVersion,
                       const int32_t aLatestSchemaVersion,
                       const nsTArray<nsCString>& aTablesSql,
@@ -226,16 +233,18 @@ CreateOrMigrateSchema(mozIStorageConnect
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
 
   int32_t schemaVersion;
   nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
   if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
+  printf_stderr("SchemaVersion %d == aLatestSchemaVersion %d\n", schemaVersion, aLatestSchemaVersion);
+
   if (schemaVersion == aLatestSchemaVersion) {
     // We already have the correct schema version.  Validate it matches
     // our expected schema and then proceed.
     rv = Validate(aConn, aLatestSchemaVersion, aExpectedSchema);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
@@ -243,16 +252,17 @@ CreateOrMigrateSchema(mozIStorageConnect
   // Turn off checking foreign keys before starting a transaction, and restore
   // it once we're done.
   AutoDisableForeignKeyChecking restoreForeignKeyChecking(aConn);
   mozStorageTransaction trans(aConn, false,
                               mozIStorageConnection::TRANSACTION_IMMEDIATE);
   bool needVacuum = false;
 
   if (schemaVersion) {
+    printf_stderr("Calling Migrate\n");
     // A schema exists, but its not the current version.  Attempt to
     // migrate it to our new schema.
     rv = Migrate(aConn, aFirstShippedSchemaVersion, aLatestSchemaVersion,
                  aMigrationList);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // Migrations happen infrequently and reflect a chance in DB structure.
     // This is a good time to rebuild the database.  It also helps catch
diff --git a/storage/mozStorageConnectionUtils.h b/storage/mozStorageConnectionUtils.h
--- a/storage/mozStorageConnectionUtils.h
+++ b/storage/mozStorageConnectionUtils.h
@@ -36,21 +36,32 @@ struct Expect
   const nsCString mName;
   const nsCString mType;
   const nsCString mSql;
   const bool mIgnoreSql;
 };
 
 struct SchemaRewrite
 {
-  nsCString mTableName;
-  nsCString mTableSql;
+  NS_INLINE_DECL_REFCOUNTING(SchemaRewrite)
+
+  SchemaRewrite(const nsCString aTable, const nsCString aSql)
+    : mTable(aTable)
+    , mSql(aSql)
+  {}
+
+  nsCString mTable;
+  nsCString mSql;
+
+private:
+  ~SchemaRewrite() {}
 };
 
-typedef nsresult (*MigrationFunc)(mozIStorageConnection*, SchemaRewrite&);
+typedef nsresult (*MigrationFunc)(mozIStorageConnection*, nsACString&,
+                                  nsACString&);
 
 struct Migration
 {
   constexpr Migration(int32_t aFromVersion, MigrationFunc aFunc)
     : mFromVersion(aFromVersion)
     , mFunc(aFunc)
   { }
   int32_t mFromVersion;
