# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  c35f352400054fbbcf3bb907ab66042c5c3f5b5d
Bug 1217544 - Implement one-off BackgroundSync API. Part 4: Sync event. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -143,29 +143,32 @@ private:
 };
 
 // BackgroundSync
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnMainThread(nsIGlobalObject* aGlobal,
                                    nsIPrincipal* aPrincipal,
+                                   const nsAString& aScope,
                                    ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(!aScope.IsEmpty());
   MOZ_ASSERT(NS_IsMainThread());
 
   PrincipalInfo principalInfo;
   aRv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
+  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo,
+                                                  aScope);
 
   // Register as observer for inner-window-destroyed.
   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
   if (obs) {
     aRv = obs->AddObserver(ref, "inner-window-destroyed",
                            false /* ownsWeak */);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
@@ -181,41 +184,46 @@ BackgroundSync::CreateOnMainThread(nsIGl
   ref->mInnerID = window->WindowID();
 
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
-                               WorkerPrivate* aWorkerPrivate)
+                               WorkerPrivate* aWorkerPrivate,
+                               const nsAString& aScope)
 {
   MOZ_ASSERT(aWorkerPrivate);
+  MOZ_ASSERT(!aScope.IsEmpty());
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal,
-                                                  principalInfo);
+                                                  principalInfo,
+                                                  aScope);
 
   ref->mWorkerFeature = new BackgroundSyncFeature(ref);
   if (NS_WARN_IF(!aWorkerPrivate->AddFeature(ref->mWorkerFeature))) {
     ref->mWorkerFeature = nullptr;
     return nullptr;
   }
 
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
-                               const PrincipalInfo& aPrincipalInfo)
+                               const PrincipalInfo& aPrincipalInfo,
+                               const nsAString& aScope)
   : mInnerID(0)
   , mGlobal(aGlobal)
   , mShuttingDown(false)
   , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
+  , mScope(aScope)
 {
 #ifdef DEBUG
   mThread = do_GetCurrentThread();
 #endif
 
   MOZ_ASSERT(aGlobal);
 
   // Register this component to PBackground.
@@ -390,17 +398,17 @@ BackgroundSync::ExecuteOp(const SyncOpAr
 
 // WebIDL interface methods.
 
 already_AddRefed<Promise>
 BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
-  const SyncRegisterArgs args((nsString(aTag)));
+  const SyncRegisterArgs args(mScope, (nsString(aTag)));
   return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -47,22 +47,24 @@ class BackgroundSync final : public nsII
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
       BackgroundSync, nsIIPCBackgroundChildCreateCallback)
 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
+                     const nsAString& aScope,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
   CreateOnWorker(nsIGlobalObject* aGlobal,
-                 workers::WorkerPrivate* aWorkerPrivate);
-
+                 workers::WorkerPrivate* aWorkerPrivate,
+                 const nsAString& aScope);
+ 
   // Binding methods.
 
   nsIGlobalObject*
   GetParentObject() const
   {
     return mGlobal;
   }
 
@@ -77,17 +79,18 @@ public:
   Register(const nsAString& aTag, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetTags(ErrorResult& aRv);
 
   void Shutdown();
 private:
   BackgroundSync(nsIGlobalObject* aGlobal,
-                 const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
+                 const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
+                 const nsAString& aScope);
 
   ~BackgroundSync();
 
   bool IsBackgroundSyncThread();
 
   already_AddRefed<Promise>
   ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
 
@@ -100,15 +103,17 @@ private:
   RefPtr<BackgroundSyncChild> mActor;
 
   bool mShuttingDown;
 
   UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
 
   nsCOMPtr<nsIThread> mThread;
 
+  nsString mScope;
+
   nsTArray<RefPtr<SyncOpRunnable>> mPendingOperations;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSync_h
diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
--- a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -4,16 +4,17 @@
 
 include PBackgroundSharedTypes;
 
 namespace mozilla {
 namespace dom {
 
 struct SyncRegisterArgs
 {
+  nsString mScope;
   nsString mTag;
 };
 
 struct SyncGetTagsArgs
 {
 };
 
 union SyncOpArgs
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -126,16 +126,22 @@ DOMInterfaces = {
 'AudioNode' : {
     'concrete': False,
     'binaryNames': {
         'channelCountMode': 'channelCountModeValue',
         'channelInterpretation': 'channelInterpretationValue',
     },
 },
 
+'BackgroundSyncEvent': {
+    'headerFile': 'mozilla/dom/ServiceWorkerEvents.h',
+    'nativeType': 'mozilla::dom::workers::BackgroundSyncEvent',
+    'workers': True
+},
+
 'BarProp': {
     'headerFile': 'mozilla/dom/BarProps.h',
 },
 
 'Blob': {
     'headerFile': 'mozilla/dom/File.h',
 },
 
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -186,19 +186,23 @@ interface nsIServiceWorkerManager : nsIS
                                   in AString aData,
                                   in AString aBehavior);
   [optional_argc] void sendPushEvent(in ACString aOriginAttributes,
                                      in ACString aScope,
                                      [optional] in uint32_t aDataLength,
                                      [optional, array, size_is(aDataLength)] in uint8_t aDataBytes);
   void sendPushSubscriptionChangeEvent(in ACString aOriginAttributes,
                                        in ACString scope);
-
   void addListener(in nsIServiceWorkerManagerListener aListener);
 
   void removeListener(in nsIServiceWorkerManagerListener aListener);
 
   bool shouldReportToWindow(in mozIDOMWindowProxy aWindow, in ACString aScope);
+
+  void sendBackgroundSyncEvent(in ACString aOriginAttributes,
+                               in ACString scope,
+                               in AString aTag,
+                               in boolean aLastChance);
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/webidl/BackgroundSyncEvent.webidl b/dom/webidl/BackgroundSyncEvent.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/BackgroundSyncEvent.webidl
@@ -0,0 +1,20 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * https://wicg.github.io/BackgroundSync/spec/
+ */
+
+[Constructor(DOMString type, optional BackgroundSyncEventInit eventInitDict),
+ Exposed=ServiceWorker]
+interface BackgroundSyncEvent : ExtendableEvent {
+  readonly attribute DOMString tag;
+  readonly attribute boolean lastChance;
+};
+
+dictionary BackgroundSyncEventInit : ExtendableEventInit {
+  required DOMString tag;
+  boolean lastChance = false;
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -46,16 +46,17 @@ WEBIDL_FILES = [
     'AudioParam.webidl',
     'AudioProcessingEvent.webidl',
     'AudioStreamTrack.webidl',
     'AudioTrack.webidl',
     'AudioTrackList.webidl',
     'AutocompleteInfo.webidl',
     'AVInputPort.webidl',
     'BackgroundSync.webidl',
+    'BackgroundSyncEvent.webidl',
     'BarProp.webidl',
     'BaseKeyframeTypes.webidl',
     'BatteryManager.webidl',
     'BeforeAfterKeyboardEvent.webidl',
     'BeforeUnloadEvent.webidl',
     'BiquadFilterNode.webidl',
     'Blob.webidl',
     'BoxObject.webidl',
diff --git a/dom/workers/PServiceWorkerManager.ipdl b/dom/workers/PServiceWorkerManager.ipdl
--- a/dom/workers/PServiceWorkerManager.ipdl
+++ b/dom/workers/PServiceWorkerManager.ipdl
@@ -28,18 +28,22 @@ parent:
   async PropagateRemove(nsCString host);
 
   async PropagateRemoveAll();
 
   async Shutdown();
 
 child:
   async NotifyRegister(ServiceWorkerRegistrationData data);
-  async NotifySoftUpdate(PrincipalOriginAttributes originAttributes, nsString scope);
+  async NotifySoftUpdate(PrincipalOriginAttributes originAttributes,
+                         nsString scope);
   async NotifyUnregister(PrincipalInfo principalInfo, nsString scope);
   async NotifyRemove(nsCString host);
   async NotifyRemoveAll();
-
+  async NotifyBackgroundSyncEvent(PrincipalInfo principalInfo,
+                                  nsString scope,
+                                  nsString tag,
+                                  bool lastChance);
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -1008,17 +1008,17 @@ ExtractBytesFromData(const OwningArrayBu
     return NS_OK;
   }
   if (aDataInit.IsUSVString()) {
     return ExtractBytesFromUSVString(aDataInit.GetAsUSVString(), aBytes);
   }
   NS_NOTREACHED("Unexpected push message data");
   return NS_ERROR_FAILURE;
 }
-}
+} // anonymous namespace
 
 PushMessageData::PushMessageData(nsISupports* aOwner,
                                  nsTArray<uint8_t>&& aBytes)
   : mOwner(aOwner), mBytes(Move(aBytes)) {}
 
 PushMessageData::~PushMessageData()
 {
 }
@@ -1151,16 +1151,50 @@ NS_IMPL_CYCLE_COLLECTION_INHERITED(PushE
 JSObject*
 PushEvent::WrapObjectInternal(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return mozilla::dom::PushEventBinding::Wrap(aCx, this, aGivenProto);
 }
 
 #endif /* ! MOZ_SIMPLEPUSH */
 
+// Background Sync
+
+BackgroundSyncEvent::BackgroundSyncEvent(EventTarget* aOwner)
+  : ExtendableEvent(aOwner)
+{
+}
+
+already_AddRefed<BackgroundSyncEvent>
+BackgroundSyncEvent::Constructor(mozilla::dom::EventTarget* aOwner,
+                       const nsAString& aType,
+                       const BackgroundSyncEventInit& aOptions,
+                       ErrorResult& aRv)
+{
+  RefPtr<BackgroundSyncEvent> e = new BackgroundSyncEvent(aOwner);
+  bool trusted = e->Init(aOwner);
+  e->InitEvent(aType, aOptions.mBubbles, aOptions.mCancelable);
+  e->SetTrusted(trusted);
+  e->mTag = aOptions.mTag;
+  e->mLastChance = aOptions.mLastChance;
+  return e.forget();
+}
+
+NS_IMPL_ADDREF_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_RELEASE_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(BackgroundSyncEvent)
+NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(BackgroundSyncEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
 ExtendableMessageEvent::ExtendableMessageEvent(EventTarget* aOwner)
   : ExtendableEvent(aOwner)
   , mData(JS::UndefinedValue())
 {
   mozilla::HoldJSObjects(this);
 }
 
 ExtendableMessageEvent::~ExtendableMessageEvent()
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -14,16 +14,18 @@
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
 #ifndef MOZ_SIMPLEPUSH
 #include "mozilla/dom/File.h"
 #endif
 
+#include "mozilla/dom/BackgroundSyncEventBinding.h"
+
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
 class Blob;
@@ -317,11 +319,61 @@ public:
 
   void SetPorts(MessagePortList* aPorts);
 
   void SetSource(ServiceWorkerClient* aClient);
 
   void SetSource(ServiceWorker* aServiceWorker);
 };
 
+class BackgroundSyncEvent final : public ExtendableEvent
+{
+  nsString mTag;
+  bool mLastChance;
+
+protected:
+  explicit BackgroundSyncEvent(mozilla::dom::EventTarget* aOwner);
+  ~BackgroundSyncEvent() {}
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+  NS_FORWARD_TO_EVENT
+
+  virtual JSObject* WrapObjectInternal(JSContext* aCx,
+                                       JS::Handle<JSObject*> aGivenProto) override
+  {
+    return mozilla::dom::BackgroundSyncEventBinding_workers::Wrap(aCx, this,
+                                                                  aGivenProto);
+  }
+
+  static already_AddRefed<BackgroundSyncEvent>
+  Constructor(mozilla::dom::EventTarget* aOwner,
+              const nsAString& aType,
+              const BackgroundSyncEventInit& aOptions,
+              ErrorResult& aRv);
+
+  static already_AddRefed<BackgroundSyncEvent>
+  Constructor(const GlobalObject& aGlobal,
+              const nsAString& aType,
+              const BackgroundSyncEventInit& aOptions,
+              ErrorResult& aRv)
+  {
+    nsCOMPtr<EventTarget> owner = do_QueryInterface(aGlobal.GetAsSupports());
+    return Constructor(owner, aType, aOptions, aRv);
+  }
+
+  void
+  GetTag(nsAString& aTag)
+  {
+    aTag = mTag;
+  }
+
+  bool
+  LastChance()
+  {
+    return mLastChance;
+  }
+};
+
 END_WORKERS_NAMESPACE
 
 #endif /* mozilla_dom_workers_serviceworkerevents_h__ */
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -985,16 +985,41 @@ ServiceWorkerManager::SendNotificationCl
   ServiceWorkerPrivate* workerPrivate = info->WorkerPrivate();
   return workerPrivate->SendNotificationClickEvent(aID, aTitle, aDir,
                                                    aLang, aBody, aTag,
                                                    aIcon, aData, aBehavior,
                                                    NS_ConvertUTF8toUTF16(aScope));
 }
 
 NS_IMETHODIMP
+ServiceWorkerManager::SendBackgroundSyncEvent(const nsACString& aOriginAttributes,
+                                              const nsACString& aScope,
+                                              const nsAString& aTag,
+                                              const bool aLastChance)
+{
+  PrincipalOriginAttributes attrs;
+  if (!attrs.PopulateFromSuffix(aOriginAttributes)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  ServiceWorkerInfo* serviceWorker =
+    GetActiveWorkerInfoForScope(attrs, aScope);
+  if (NS_WARN_IF(!serviceWorker)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(serviceWorker->GetPrincipal(), aScope);
+
+  return serviceWorker->WorkerPrivate()->SendBackgroundSyncEvent(aTag,
+                                                                 aLastChance,
+                                                                 registration);
+}
+
+NS_IMETHODIMP
 ServiceWorkerManager::GetReadyPromise(mozIDOMWindow* aWindow,
                                       nsISupports** aPromise)
 {
   AssertIsOnMainThread();
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
diff --git a/dom/workers/ServiceWorkerManagerChild.cpp b/dom/workers/ServiceWorkerManagerChild.cpp
--- a/dom/workers/ServiceWorkerManagerChild.cpp
+++ b/dom/workers/ServiceWorkerManagerChild.cpp
@@ -90,11 +90,40 @@ ServiceWorkerManagerChild::RecvNotifyRem
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
   swm->RemoveAll();
   return true;
 }
 
+bool
+ServiceWorkerManagerChild::RecvNotifyBackgroundSyncEvent(
+    const PrincipalInfo& aPrincipalInfo, const nsString& aScope,
+    const nsString& aTag, const bool& aLastChance)
+{
+  if (mShuttingDown) {
+    return true;
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo);
+  if (NS_WARN_IF(!principal)) {
+    return true;
+  }
+
+  nsAutoCString originSuffix;
+  nsresult rv = principal->GetOriginSuffix(originSuffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return true;
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  swm->SendBackgroundSyncEvent(originSuffix,
+                               NS_ConvertUTF16toUTF8(aScope),
+                               aTag, aLastChance);
+  return true;
+}
+
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManagerChild.h b/dom/workers/ServiceWorkerManagerChild.h
--- a/dom/workers/ServiceWorkerManagerChild.h
+++ b/dom/workers/ServiceWorkerManagerChild.h
@@ -41,16 +41,21 @@ public:
 
   virtual bool RecvNotifyUnregister(const PrincipalInfo& aPrincipalInfo,
                                     const nsString& aScope) override;
 
   virtual bool RecvNotifyRemove(const nsCString& aHost) override;
 
   virtual bool RecvNotifyRemoveAll() override;
 
+  virtual bool RecvNotifyBackgroundSyncEvent(const PrincipalInfo& aPrincipalInfo,
+                                             const nsString& aScope,
+                                             const nsString& aTag,
+                                             const bool& aLastChance) override;
+
 private:
   ServiceWorkerManagerChild()
     : mShuttingDown(false)
   {}
 
   ~ServiceWorkerManagerChild() {}
 
   bool mShuttingDown;
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -79,17 +79,17 @@ private:
 
   RefPtr<ServiceWorkerPrivate> mPrivate;
 };
 
 NS_IMPL_ISUPPORTS0(KeepAliveToken)
 
 ServiceWorkerPrivate::ServiceWorkerPrivate(ServiceWorkerInfo* aInfo)
   : mInfo(aInfo)
-  , mIsPushWorker(false)
+  , mIsPushOrSyncWorker(false)
   , mDebuggerCount(0)
   , mTokenCount(0)
 {
   AssertIsOnMainThread();
   MOZ_ASSERT(aInfo);
 
   mIdleWorkerTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
   MOZ_ASSERT(mIdleWorkerTimer);
@@ -1496,16 +1496,102 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
 
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
+namespace {
+class SendSyncEventRunnable final : public ExtendableFunctionalEventWorkerRunnable
+{
+  nsString mTag;
+  bool mLastChance;
+
+public:
+  SendSyncEventRunnable(WorkerPrivate* aWorkerPrivate,
+                        KeepAliveToken* aKeepAliveToken,
+                        const nsAString& aTag,
+                        const bool aLastChance,
+                        nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> aRegistration)
+    : ExtendableFunctionalEventWorkerRunnable(
+        aWorkerPrivate, aKeepAliveToken, aRegistration)
+    , mTag(aTag)
+    , mLastChance(aLastChance)
+  {
+    AssertIsOnMainThread();
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    GlobalObject globalObj(aCx, aWorkerPrivate->GlobalScope()->GetWrapper());
+
+    BackgroundSyncEventInit sei;
+    sei.mTag = mTag;
+    sei.mLastChance = mLastChance;
+    sei.mBubbles = false;
+    sei.mCancelable = false;
+
+    ErrorResult result;
+    RefPtr<BackgroundSyncEvent> event =
+      BackgroundSyncEvent::Constructor(globalObj, NS_LITERAL_STRING("sync"),
+                                       sei, result);
+    if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
+      return false;
+    }
+    event->SetTrusted(true);
+
+    DispatchExtendableEventOnWorkerScope(aCx, aWorkerPrivate->GlobalScope(),
+                                         event, nullptr);
+
+    return true;
+  }
+};
+} // anonymous namespace
+
+nsresult
+ServiceWorkerPrivate::SendBackgroundSyncEvent(const nsAString& aTag,
+                                              const bool aLastChance,
+                                              ServiceWorkerRegistrationInfo* aRegistration)
+{
+  nsresult rv = SpawnWorkerIfNeeded(BackgroundSyncEvent, nullptr);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  MOZ_ASSERT(mKeepAliveToken);
+
+  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> regInfo(
+      new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(aRegistration, false));
+
+
+  RefPtr<WorkerRunnable> runnable = new SendSyncEventRunnable(mWorkerPrivate,
+                                                              mKeepAliveToken,
+                                                              aTag,
+                                                              aLastChance,
+                                                              regInfo);
+
+  if (mInfo->State() == ServiceWorkerState::Activating) {
+    mPendingFunctionalEvents.AppendElement(runnable.forget());
+    return NS_OK;
+  }
+
+  MOZ_ASSERT(mInfo->State() == ServiceWorkerState::Activated);
+
+  if (NS_WARN_IF(!runnable->Dispatch())) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 nsresult
 ServiceWorkerPrivate::SpawnWorkerIfNeeded(WakeUpReason aWhy,
                                           nsIRunnable* aLoadFailedRunnable,
                                           nsILoadGroup* aLoadGroup)
 {
   AssertIsOnMainThread();
 
   // XXXcatalinb: We need to have a separate load group that's linked to
@@ -1590,17 +1676,17 @@ ServiceWorkerPrivate::SpawnWorkerIfNeede
   mWorkerPrivate = WorkerPrivate::Constructor(jsapi.cx(),
                                               scriptSpec,
                                               false, WorkerTypeService,
                                               mInfo->Scope(), &info, error);
   if (NS_WARN_IF(error.Failed())) {
     return error.StealNSResult();
   }
 
-  mIsPushWorker = false;
+  mIsPushOrSyncWorker = false;
   RenewKeepAliveToken(aWhy);
 
   return NS_OK;
 }
 
 void
 ServiceWorkerPrivate::StoreISupports(nsISupports* aSupports)
 {
@@ -1655,17 +1741,17 @@ ServiceWorkerPrivate::NoteDeadServiceWor
   mInfo = nullptr;
   TerminateWorker();
 }
 
 void
 ServiceWorkerPrivate::NoteStoppedControllingDocuments()
 {
   AssertIsOnMainThread();
-  if (mIsPushWorker || mDebuggerCount) {
+  if (mIsPushOrSyncWorker || mDebuggerCount) {
     return;
   }
 
   TerminateWorker();
 }
 
 void
 ServiceWorkerPrivate::Activated()
@@ -1793,18 +1879,19 @@ ServiceWorkerPrivate::TerminateWorkerCal
 }
 
 void
 ServiceWorkerPrivate::RenewKeepAliveToken(WakeUpReason aWhy)
 {
   // We should have an active worker if we're renewing the keep alive token.
   MOZ_ASSERT(mWorkerPrivate);
 
-  if (aWhy == PushEvent || aWhy == PushSubscriptionChangeEvent) {
-    mIsPushWorker = true;
+  if (aWhy == PushEvent || aWhy == PushSubscriptionChangeEvent ||
+      aWhy == BackgroundSyncEvent) {
+    mIsPushOrSyncWorker = true;
   }
 
   // If there is at least one debugger attached to the worker, the idle worker
   // timeout was canceled when the first debugger attached to the worker. It
   // should not be reset until the last debugger detaches from the worker.
   if (!mDebuggerCount) {
     ResetIdleTimeout();
   }
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -105,16 +105,21 @@ public:
                              const nsAString& aScope);
 
   nsresult
   SendFetchEvent(nsIInterceptedChannel* aChannel,
                  nsILoadGroup* aLoadGroup,
                  const nsAString& aDocumentId,
                  bool aIsReload);
 
+  nsresult
+  SendBackgroundSyncEvent(const nsAString& aTag,
+                          const bool aLastChance,
+                          ServiceWorkerRegistrationInfo* aRegistration);
+
   void
   StoreISupports(nsISupports* aSupports);
 
   void
   RemoveISupports(nsISupports* aSupports);
 
   // This will terminate the current running worker thread and drop the
   // workerPrivate reference.
@@ -145,17 +150,18 @@ public:
 private:
   enum WakeUpReason {
     FetchEvent = 0,
     PushEvent,
     PushSubscriptionChangeEvent,
     MessageEvent,
     NotificationClickEvent,
     LifeCycleEvent,
-    AttachEvent
+    AttachEvent,
+    BackgroundSyncEvent
   };
 
   // Timer callbacks
   static void
   NoteIdleWorkerCallback(nsITimer* aTimer, void* aPrivate);
 
   static void
   TerminateWorkerCallback(nsITimer* aTimer, void *aPrivate);
@@ -188,20 +194,20 @@ private:
 
   // The WorkerPrivate object can only be closed by this class or by the
   // RuntimeService class if gecko is shutting down. Closing the worker
   // multiple times is OK, since the second attempt will be a no-op.
   RefPtr<WorkerPrivate> mWorkerPrivate;
 
   nsCOMPtr<nsITimer> mIdleWorkerTimer;
 
-  // We keep track if this worker received any push events since it was last
-  // woken up. The flag is reset to false every time a new WorkerPrivate
-  // is created.
-  bool mIsPushWorker;
+  // We keep track if this worker received any push or sync events since it
+  // was last woken up. The flag is reset to false every time a new
+  // WorkerPrivate is created.
+  bool mIsPushOrSyncWorker;
 
   // We keep a token for |dom.serviceWorkers.idle_timeout| seconds to give the
   // worker a grace period after each event.
   RefPtr<KeepAliveToken> mKeepAliveToken;
 
   uint64_t mDebuggerCount;
 
   uint64_t mTokenCount;
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -807,17 +807,17 @@ ServiceWorkerRegistrationMainThread::Get
 
     nsCOMPtr<nsIPrincipal> principal = document->NodePrincipal();
     if (!principal) {
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
 
     mBackgroundSync = BackgroundSync::CreateOnMainThread(globalObject, principal,
-                                                   aRv);
+                                                         mScope, aRv);
   }
 
   return mBackgroundSync;
 }
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 class WorkerListener final : public ServiceWorkerRegistrationListener
@@ -1259,16 +1259,17 @@ ServiceWorkerRegistrationWorkerThread::G
 #endif /* ! MOZ_SIMPLEPUSH */
 }
 
 BackgroundSync*
 ServiceWorkerRegistrationWorkerThread::GetSync(ErrorResult& aRv)
 {
   if (!mBackgroundSync) {
     mBackgroundSync = BackgroundSync::CreateOnWorker(mWorkerPrivate->GlobalScope(),
-                                                     mWorkerPrivate);
+                                                     mWorkerPrivate,
+                                                     mScope);
   }
 
   return mBackgroundSync;
 }
 
 } // dom namespace
 } // mozilla namespace
