# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  34300d528cbe25f6703e82b6f759f17b72578be7
Bug 1217544 - Implement one-off BackgroundSync API. Part 3: IPC. r=baku

diff --git a/dom/sync/PSyncManager.ipdl b/dom/sync/PSyncManager.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/sync/PSyncManager.ipdl
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+include SyncIPCTypes;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+
+protocol PSyncManager
+{
+  manager PBackground;
+
+parent: // child -> parent messages
+  async Request(nsID aRequestId, SyncOp aOp);
+  async Shutdown();
+
+child: // parent -> child messages
+  async Response(nsID requestId, SyncOpResponse aResponse);
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/SyncIPCTypes.ipdlh b/dom/sync/SyncIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncIPCTypes.ipdlh
@@ -0,0 +1,54 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+
+namespace mozilla {
+namespace dom {
+
+struct SyncRegisterArgs
+{
+  nsString mTag;
+};
+
+struct SyncGetTagsArgs
+{
+};
+
+union SyncOpArgs
+{
+  SyncRegisterArgs;
+  SyncGetTagsArgs;
+};
+
+struct SyncOp
+{
+  PrincipalInfo mPrincipal;
+  SyncOpArgs mArgs;
+};
+
+struct SyncRegisterResponse
+{
+  bool mSuccess;
+};
+
+struct SyncGetTagsResponse
+{
+  nsString[] mTags;
+};
+
+struct SyncOpError
+{
+  uint32_t mCode;
+};
+
+union SyncOpResponse
+{
+  SyncRegisterResponse;
+  SyncGetTagsResponse;
+  SyncOpError;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/SyncManager.cpp b/dom/sync/SyncManager.cpp
--- a/dom/sync/SyncManager.cpp
+++ b/dom/sync/SyncManager.cpp
@@ -1,92 +1,288 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "SyncManager.h"
+#include "SyncManagerChild.h"
 
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
+#include "mozilla/dom/SyncIPCTypes.h"
 #include "mozilla/dom/SyncManagerBinding.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/Preferences.h"
+#include "mozilla/unused.h"
 #include "nsIGlobalObject.h"
+#include "nsISupportsPrimitives.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
 using namespace workers;
 
+// Helpers
+
+class SyncOpRunnable final : public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  SyncOpRunnable(Promise* aPromise, nsAutoPtr<SyncOp>& aOp)
+    : mPromise(aPromise)
+    , mOp(aOp)
+  {
+    MOZ_ASSERT(mPromise);
+    MOZ_ASSERT(mOp);
+  }
+
+  void SetActor(SyncManagerChild* aActor)
+  {
+    MOZ_ASSERT(!mActor);
+    MOZ_ASSERT(aActor);
+    mActor = aActor;
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (mActor->IsActorDestroyed()) {
+      return NS_OK;
+    }
+
+    return mActor->ExecuteOp(mPromise, mOp);
+  }
+
+  NS_IMETHODIMP Cancel() override
+  {
+    mActor = nullptr;
+    mPromise = nullptr;
+    mOp = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~SyncOpRunnable() {}
+
+  RefPtr<Promise> mPromise;
+  nsAutoPtr<SyncOp> mOp;
+  RefPtr<SyncManagerChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(SyncOpRunnable, nsICancelableRunnable, nsIRunnable)
+
+class TeardownRunnable final : public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  explicit TeardownRunnable(SyncManagerChild* aActor)
+    : mActor(aActor)
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (!mActor->IsActorDestroyed()) {
+      mActor->SendShutdown();
+    }
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP Cancel() override
+  {
+    mActor = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~TeardownRunnable() {};
+
+  RefPtr<SyncManagerChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(TeardownRunnable, nsICancelableRunnable, nsIRunnable)
+
+class SyncManagerFeature final : public workers::WorkerFeature
+{
+  // The manager keeps alive this feature.
+  SyncManager* MOZ_NON_OWNING_REF mManager;
+
+public:
+  explicit SyncManagerFeature(SyncManager* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(aManager);
+    MOZ_COUNT_CTOR(SyncManagerFeature);
+  }
+
+  virtual bool Notify(JSContext* aCtx, workers::Status aStatus) override
+  {
+    if (aStatus >= Closing) {
+      mManager->Shutdown();
+    }
+    return true;
+  }
+
+private:
+  ~SyncManagerFeature()
+  {
+    MOZ_COUNT_CTOR(SyncManagerFeature);
+  }
+};
+
 // SyncManager
 
 // static
 already_AddRefed<SyncManager>
 SyncManager::CreateOnMainThread(nsIGlobalObject* aGlobal,
                                 nsIPrincipal* aPrincipal,
                                 ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   PrincipalInfo principalInfo;
-  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
+  aRv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   RefPtr<SyncManager> ref = new SyncManager(aGlobal, principalInfo);
+
+  // Register as observer for inner-window-destroyed.
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    aRv = obs->AddObserver(ref, "inner-window-destroyed",
+                           false /* ownsWeak */);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+  } else {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  MOZ_ASSERT(window);
+  MOZ_ASSERT(window->IsInnerWindow());
+  ref->mInnerID = window->WindowID();
+
   return ref.forget();
 }
 
 // static
 already_AddRefed<SyncManager>
 SyncManager::CreateOnWorker(nsIGlobalObject* aGlobal,
                             WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
   RefPtr<SyncManager> ref = new SyncManager(aGlobal, principalInfo);
+
+  ref->mWorkerFeature = new SyncManagerFeature(ref);
+  if (NS_WARN_IF(!aWorkerPrivate->AddFeature(ref->mWorkerFeature))) {
+    ref->mWorkerFeature = nullptr;
+    return nullptr;
+  }
+
   return ref.forget();
 }
 
 SyncManager::SyncManager(nsIGlobalObject* aGlobal,
                          const PrincipalInfo& aPrincipalInfo)
-  : mGlobal(aGlobal)
-  , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
-{}
+  : mInnerID(0)
+  , mGlobal(aGlobal)
+  , mShuttingDown(false)
+  , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
+{
+#ifdef DEBUG
+  mThread = PR_GetCurrentThread();
+#endif
+
+  MOZ_ASSERT(aGlobal);
+
+  // Register this component to PBackground.
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    ActorCreated(actor);
+  } else {
+    MOZ_ALWAYS_TRUE(BackgroundChild::GetOrCreateForCurrentThread(this));
+  }
+}
 
 SyncManager::~SyncManager()
-{}
+{
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+  Shutdown();
+  MOZ_ASSERT(!mWorkerFeature);
+  MOZ_ASSERT(!mActor);
+}
+
+void
+SyncManager::Shutdown()
+{
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+
+  mShuttingDown = true;
+
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    obs->RemoveObserver(this, "inner-window-destroyed");
+  }
+
+  if (mWorkerFeature) {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+    workerPrivate->AssertIsOnWorkerThread();
+    workerPrivate->RemoveFeature(mWorkerFeature);
+    mWorkerFeature = nullptr;
+  }
+
+  if (mActor) {
+    RefPtr<TeardownRunnable> runnable = new TeardownRunnable(mActor);
+    NS_DispatchToCurrentThread(runnable);
+    Unused << NS_WARN_IF(NS_FAILED(rv));
+    mActor = nullptr;
+  }
+
+  mPendingOperations.Clear();
+}
 
 // Bindings methods.
 
 JSObject*
 SyncManager::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+
   return SyncManagerBinding::Wrap(aCx, this, aGivenProto);
 }
 
 // static
 bool
 SyncManager::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+
   using mozilla::dom::workers::WorkerPrivate;
   using mozilla::dom::workers::GetWorkerPrivateFromContext;
 
   // If we are on the main thread, then check the pref directly.
   if (NS_IsMainThread()) {
     bool enabled = false;
     Preferences::GetBool("dom.background.sync.enabled", &enabled);
     return enabled;
@@ -96,42 +292,126 @@ SyncManager::PrefEnabled(JSContext* aCx,
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
   if (!workerPrivate) {
     return false;
   }
 
   return workerPrivate->BackgroundSyncEnabled();
 }
 
-// WebIDL interace methods.
+// nsIIPCBackgroundChildCreateCallback methods.
+
+void
+SyncManager::ActorFailed()
+{
+  MOZ_CRASH("Failed to create a PBackgroundChild actor!");
+}
+
+void
+SyncManager::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+  MOZ_ASSERT(aActor);
+  MOZ_ASSERT(!mActor);
+
+  PSyncManagerChild* actor = aActor->SendPSyncManagerConstructor();
+  mActor = static_cast<SyncManagerChild*>(actor);
+  MOZ_ASSERT(mActor);
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
+    RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
+    MOZ_ASSERT(runnable);
+    runnable->SetActor(mActor);
+    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+      NS_WARNING("Failed to dispatch to the current thread");
+      mPendingOperations.Clear();
+      return;
+    }
+  }
+  mPendingOperations.Clear();
+}
+
+// nsIObserver
+
+NS_IMETHODIMP
+SyncManager::Observe(nsISupports* aSubject,
+                     const char* aTopic,
+                     const char16_t* aData)
+{
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!strcmp(aTopic, "inner-window-destroyed"));
+
+  nsCOMPtr<nsISupportsPRUint64> wrapper = do_QueryInterface(aSubject);
+  NS_ENSURE_TRUE(wrapper, NS_ERROR_FAILURE);
+
+  uint64_t innerID;
+  nsresult rv = wrapper->GetData(&innerID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (innerID != mInnerID) {
+    return NS_OK;
+  }
+
+  Shutdown();
+
+  return NS_OK;
+}
 
 already_AddRefed<Promise>
-SyncManager::Register(const nsAString& aName, ErrorResult& aRv)
+SyncManager::ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv)
 {
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+
   RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
+  nsAutoPtr<SyncOp> op(new SyncOp(*mPrincipalInfo, aArgs));
+  RefPtr<SyncOpRunnable> runnable = new SyncOpRunnable(p, op);
+
+  if (!mActor) {
+    mPendingOperations.AppendElement(runnable);
+    return p.forget();
+  }
+
+  runnable->SetActor(mActor);
+  nsresult rv = NS_DispatchToCurrentThread(runnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    p->MaybeReject(rv);
+  }
+
   return p.forget();
 }
 
+// WebIDL interface methods.
+
+already_AddRefed<Promise>
+SyncManager::Register(const nsAString& aTag, ErrorResult& aRv)
+{
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
+
+  const SyncRegisterArgs args((nsString(aTag)));
+  return ExecuteOp(SyncOpArgs(args), aRv);
+}
+
 already_AddRefed<Promise>
 SyncManager::GetTags(ErrorResult& aRv)
 {
-  RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
-  if (NS_WARN_IF(aRv.Failed())) {
-    return nullptr;
-  }
+  MOZ_ASSERT(mThread == PR_GetCurrentThread());
 
-  return p.forget();
+  const SyncGetTagsArgs args;
+  return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(SyncManager, mGlobal)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(SyncManager)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(SyncManager)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(SyncManager)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
+  NS_INTERFACE_MAP_ENTRY(nsIObserver)
 NS_INTERFACE_MAP_END
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/sync/SyncManager.h b/dom/sync/SyncManager.h
--- a/dom/sync/SyncManager.h
+++ b/dom/sync/SyncManager.h
@@ -2,48 +2,60 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_SyncManager_h
 #define mozilla_dom_SyncManager_h
 
+#include "mozilla/dom/SyncIPCTypes.h"
+
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIObserver.h"
 #include "nsIPrincipal.h"
 #include "nsWrapperCache.h"
 
 #include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/ErrorResult.h"
-#include "mozilla/dom/BindingDeclarations.h"
 
 #include "nsCOMPtr.h"
 #include "jsapi.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 
 namespace ipc {
   class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 namespace workers {
+  class WorkerFeature;
   class WorkerPrivate;
 } // namespace workers
 
 class Promise;
+class SyncManagerChild;
+class SyncOpRunnable;
 
-class SyncManager final : public nsISupports
+class SyncManager final : public nsIIPCBackgroundChildCreateCallback
+                        , public nsIObserver
                         , public nsWrapperCache
 {
+  NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
+  NS_DECL_NSIOBSERVER
+
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(SyncManager)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
+      SyncManager, nsIIPCBackgroundChildCreateCallback)
 
   static already_AddRefed<SyncManager>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<SyncManager>
   CreateOnWorker(nsIGlobalObject* aGlobal,
@@ -60,28 +72,44 @@ public:
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
   // WebIDL interface methods.
 
   already_AddRefed<Promise>
-  Register(const nsAString& aName, ErrorResult& aRv);
+  Register(const nsAString& aTag, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetTags(ErrorResult& aRv);
 
+  void Shutdown();
 private:
   SyncManager(nsIGlobalObject* aGlobal,
               const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
   ~SyncManager();
 
+  already_AddRefed<Promise>
+  ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
+
+  uint64_t mInnerID;
+
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
-  nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+  nsAutoPtr<workers::WorkerFeature> mWorkerFeature;
+
+  RefPtr<SyncManagerChild> mActor;
+
+  bool mShuttingDown;
+
+  UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+
+  RefPtr<nsThread> mThread;
+
+  nsTArray<RefPtr<SyncOpRunnable>> mPendingOperations;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_SyncManager_h
diff --git a/dom/sync/SyncManagerChild.cpp b/dom/sync/SyncManagerChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncManagerChild.cpp
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SyncManagerChild.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+
+struct SyncManagerChild::PendingRequest final
+{
+  explicit PendingRequest(Promise* aPromise)
+    : mPromise(aPromise)
+  {}
+
+  RefPtr<Promise> mPromise;
+};
+
+SyncManagerChild::SyncManagerChild()
+  : mActorDestroyed(false)
+{
+}
+
+SyncManagerChild::~SyncManagerChild()
+{
+}
+
+void
+SyncManagerChild::ActorDestroy(ActorDestroyReason aWhy)
+{
+  mActorDestroyed = true;
+
+  // Reject pending requests.
+  for (auto iter = mPendingRequests.Iter(); !iter.Done(); iter.Next()) {
+    PendingRequest* request = mPendingRequests.Get(iter.Get()->GetKey());
+    if (NS_WARN_IF(!request)) {
+      continue;
+    }
+    request->mPromise->MaybeReject();
+  }
+
+  mPendingRequests.Clear();
+}
+
+nsresult
+SyncManagerChild::StorePendingRequest(Promise* aPromise, nsID& aID)
+{
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> uuidGenerator =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsID id;
+  rv = uuidGenerator->GenerateUUIDInPlace(&id);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PendingRequest* request = new PendingRequest(aPromise);
+  mPendingRequests.Put(id, request);
+
+  aID = id;
+
+  return NS_OK;
+}
+
+Promise*
+SyncManagerChild::GetPendingRequest(const nsID& aID)
+{
+  PendingRequest* request = mPendingRequests.Get(aID);
+  if (NS_WARN_IF(!request)) {
+    return nullptr;
+  }
+
+  RefPtr<Promise> promise = request->mPromise;
+
+  mPendingRequests.Remove(const_cast<nsID&>(aID));
+  return promise;
+}
+
+nsresult
+SyncManagerChild::ExecuteOp(Promise* aPromise, SyncOp* aOp)
+{
+  if (mActorDestroyed) {
+    return NS_OK;
+  }
+
+  nsID requestId;
+  nsresult rv = StorePendingRequest(aPromise, requestId);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Unused << SendRequest(requestId, *aOp);
+
+  return NS_OK;
+}
+
+bool
+SyncManagerChild::RecvResponse(const nsID& aRequestId,
+                               const SyncOpResponse& aResponse)
+{
+  Promise* p = GetPendingRequest(aRequestId);
+  if (!p) {
+    return false;
+  }
+
+  switch(aResponse.type()) {
+    case SyncOpResponse::TSyncRegisterResponse:
+      p->MaybeResolve(true);
+      return true;
+    case SyncOpResponse::TSyncGetTagsResponse:
+      p->MaybeResolve(aResponse.get_SyncGetTagsResponse().mTags());
+      return true;
+    case SyncOpResponse::TSyncOpError:
+      p->MaybeReject(
+          static_cast<nsresult>(aResponse.get_SyncOpError().mCode()));
+      return true;
+    default:
+      MOZ_CRASH("Unknown BackgroundSync response");
+      return false;
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/SyncManagerChild.h b/dom/sync/SyncManagerChild.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncManagerChild.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_SyncManagerChild_h
+#define mozilla_dom_SyncManagerChild_h
+
+#include "SyncManager.h"
+
+#include "mozilla/dom/PSyncManagerChild.h"
+
+#include "nsID.h"
+#include "nsClassHashtable.h"
+
+namespace mozilla {
+
+namespace ipc {
+class BackgroundChildImpl;
+} // namespace ipc
+
+namespace dom {
+
+class SyncManager;
+
+class SyncManagerChild final : public PSyncManagerChild
+{
+  friend class mozilla::ipc::BackgroundChildImpl;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(SyncManagerChild)
+
+  bool IsActorDestroyed() const
+  {
+    return mActorDestroyed;
+  }
+
+  nsresult ExecuteOp(Promise* aPromise, SyncOp* aOp);
+
+  virtual bool RecvResponse(const nsID& aRequestId,
+                            const SyncOpResponse& aResponse) override;
+
+private:
+  SyncManagerChild();
+  ~SyncManagerChild();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  nsresult StorePendingRequest(Promise* aPromise, nsID& aID);
+  Promise* GetPendingRequest(const nsID& aID);
+
+  bool mActorDestroyed;
+
+  struct PendingRequest;
+  nsClassHashtable<nsIDHashKey, PendingRequest> mPendingRequests;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncManagerChild_h
diff --git a/dom/sync/SyncManagerParent.cpp b/dom/sync/SyncManagerParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncManagerParent.cpp
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "SyncManagerParent.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/BackgroundParent.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+
+SyncManagerParent::SyncManagerParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+SyncManagerParent::~SyncManagerParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+void SyncManagerParent::ActorDestroy(ActorDestroyReason aWhy)
+{
+  AssertIsOnBackgroundThread();
+}
+
+bool SyncManagerParent::RecvRequest(const nsID& aRequestId,
+                                    const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  switch(aOp.mArgs().type()) {
+    case SyncOpArgs::TSyncRegisterArgs:
+    {
+      // XXX Do registration.
+      const SyncRegisterResponse response(true);
+      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    case SyncOpArgs::TSyncGetTagsArgs:
+    {
+      //XXX Do GetTags.
+      nsTArray<nsString> tags;
+      const SyncGetTagsResponse response(tags);
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync request");
+    }
+  }
+  return true;
+}
+
+bool SyncManagerParent::RecvShutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  Unused << Send__delete__(this);
+
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/SyncManagerParent.h b/dom/sync/SyncManagerParent.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncManagerParent.h
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_SyncManagerParent_h
+#define mozilla_dom_SyncManagerParent_h
+
+#include "mozilla/dom/PSyncManagerParent.h"
+#include "mozilla/dom/SyncIPCTypes.h"
+
+#include "nsID.h"
+
+namespace mozilla {
+
+namespace ipc {
+class BackgroundParentImpl;
+} // namespace ipc
+
+namespace dom {
+
+class SyncManagerParent final : public PSyncManagerParent
+{
+  friend class mozilla::ipc::BackgroundParentImpl;
+
+public:
+  virtual bool RecvRequest(const nsID& aRequestId,
+                           const SyncOp& aOp) override;
+
+  virtual bool RecvShutdown() override;
+private:
+  SyncManagerParent();
+  ~SyncManagerParent();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncManagerParent_h
+
+
diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -3,17 +3,24 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
     'SyncManager.h'
 ]
 
 UNIFIED_SOURCES += [
-    'SyncManager.cpp'
+    'SyncManager.cpp',
+    'SyncManagerChild.cpp',
+    'SyncManagerParent.cpp'
+]
+
+IPDL_SOURCES += [
+    'PSyncManager.ipdl',
+    'SyncIPCTypes.ipdlh'
 ]
 
 LOCAL_INCLUDES += [
     '/dom/workers'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
 #include "ActorsChild.h" // IndexedDB
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
+#include "SyncManagerChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
@@ -62,16 +63,17 @@ namespace ipc {
 using mozilla::dom::UDPSocketChild;
 using mozilla::net::PUDPSocketChild;
 
 using mozilla::dom::asmjscache::PAsmJSCacheEntryChild;
 using mozilla::dom::cache::PCacheChild;
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::PCacheStreamControlChild;
 using mozilla::dom::PNuwaChild;
+using mozilla::dom::SyncManagerChild;
 
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl::ThreadLocal
 // -----------------------------------------------------------------------------
 
 BackgroundChildImpl::
 ThreadLocal::ThreadLocal()
   : mCurrentFileHandle(nullptr)
@@ -444,16 +446,36 @@ bool
 BackgroundChildImpl::DeallocPQuotaChild(PQuotaChild* aActor)
 {
   MOZ_ASSERT(aActor);
 
   delete aActor;
   return true;
 }
 
+// -----------------------------------------------------------------------------
+// Background Sync API
+// -----------------------------------------------------------------------------
+
+dom::PSyncManagerChild*
+BackgroundChildImpl::AllocPSyncManagerChild()
+{
+  RefPtr<SyncManagerChild> agent = new SyncManagerChild();
+  return agent.forget().take();
+}
+
+bool
+BackgroundChildImpl::DeallocPSyncManagerChild(PSyncManagerChild* aActor)
+{
+  RefPtr<SyncManagerChild> child =
+    dont_AddRef(static_cast<SyncManagerChild*>(aActor));
+  MOZ_ASSERT(child);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -153,16 +153,22 @@ protected:
   virtual bool
   DeallocPAsmJSCacheEntryChild(PAsmJSCacheEntryChild* aActor) override;
 
   virtual PQuotaChild*
   AllocPQuotaChild() override;
 
   virtual bool
   DeallocPQuotaChild(PQuotaChild* aActor) override;
+
+  virtual PSyncManagerChild*
+  AllocPSyncManagerChild() override;
+
+  virtual bool
+  DeallocPSyncManagerChild(PSyncManagerChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -32,32 +32,34 @@
 #include "nsIAppsService.h"
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "mozilla/RefPtr.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 #include "ServiceWorkerManagerParent.h"
+#include "SyncManagerParent.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
 #else
 #define ASSERT_UNLESS_FUZZING(...) MOZ_ASSERT(false)
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
 using mozilla::dom::asmjscache::PAsmJSCacheEntryParent;
 using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::PCacheStorageParent;
 using mozilla::dom::cache::PCacheStreamControlParent;
 using mozilla::dom::MessagePortParent;
 using mozilla::dom::PMessagePortParent;
 using mozilla::dom::PNuwaParent;
 using mozilla::dom::NuwaParent;
+using mozilla::dom::SyncManagerParent;
 using mozilla::dom::UDPSocketParent;
 
 namespace {
 
 void
 AssertIsOnMainThread()
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -86,16 +88,17 @@ public:
 } // namespace
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::BroadcastChannelParent;
 using mozilla::dom::ServiceWorkerRegistrationData;
+using mozilla::dom::SyncManagerParent;
 using mozilla::dom::workers::ServiceWorkerManagerParent;
 
 BackgroundParentImpl::BackgroundParentImpl()
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
 
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundParentImpl);
@@ -735,16 +738,36 @@ BackgroundParentImpl::DeallocPQuotaParen
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
   return mozilla::dom::quota::DeallocPQuotaParent(aActor);
 }
 
+mozilla::dom::PSyncManagerParent*
+BackgroundParentImpl::AllocPSyncManagerParent()
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+
+  return new SyncManagerParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPSyncManagerParent(PSyncManagerParent* aActor)
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aActor);
+
+  delete static_cast<SyncManagerParent*>(aActor);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -181,14 +181,20 @@ protected:
   virtual bool
   DeallocPAsmJSCacheEntryParent(PAsmJSCacheEntryParent* aActor) override;
 
   virtual PQuotaParent*
   AllocPQuotaParent() override;
 
   virtual bool
   DeallocPQuotaParent(PQuotaParent* aActor) override;
+
+  virtual PSyncManagerParent*
+  AllocPSyncManagerParent() override;
+
+  virtual bool
+  DeallocPSyncManagerParent(PSyncManagerParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -12,16 +12,17 @@ include protocol PCache;
 include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PNuwa;
 include protocol PQuota;
 include protocol PServiceWorkerManager;
+include protocol PSyncManager;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 
 include "mozilla/dom/cache/IPCUtils.h";
@@ -50,16 +51,17 @@ sync protocol PBackground
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PMessagePort;
   manages PCameras;
   manages PNuwa;
   manages PQuota;
   manages PServiceWorkerManager;
+  manages PSyncManager;
   manages PUDPSocket;
   manages PVsync;
 
 parent:
   // Only called at startup during mochitests to check the basic infrastructure.
   async PBackgroundTest(nsCString testArg);
 
   async PBackgroundIDBFactory(LoggingInfo loggingInfo);
@@ -90,16 +92,18 @@ parent:
   async MessagePortForceClose(nsID uuid, nsID destinationUuid, uint32_t sequenceId);
 
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
+  async PSyncManager();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
   async PFileDescriptorSet(FileDescriptor fd);
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -135,16 +135,17 @@ SOURCES += [
     'GeckoChildProcessHost.cpp',
     'URIUtils.cpp',
 ]
 
 LOCAL_INCLUDES += [
     '/caps',
     '/dom/broadcastchannel',
     '/dom/indexedDB',
+    '/dom/sync',
     '/dom/workers',
     '/media/webrtc/trunk',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
