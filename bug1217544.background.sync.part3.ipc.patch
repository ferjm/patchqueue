# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  3b3e0c1fb59ac01e76906db1621882268a90ae0b
Bug 1217544 - Implement one-off BackgroundSync API. Part 3: IPC. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -1,88 +1,299 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSync.h"
+#include "BackgroundSyncChild.h"
 
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BackgroundSyncBinding.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/unused.h"
 #include "mozilla/Preferences.h"
+#include "nsISupportsPrimitives.h"
 #include "nsIGlobalObject.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
 using namespace workers;
 
 namespace backgroundsync {
 
+// Helpers
+
+class SyncOpRunnable final : public nsIRunnable,
+                             public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  SyncOpRunnable(Promise* aPromise, nsAutoPtr<SyncOp>& aOp)
+    : mPromise(aPromise)
+    , mOp(aOp)
+  {
+    MOZ_ASSERT(mPromise);
+    MOZ_ASSERT(mOp);
+  }
+
+  void SetActor(BackgroundSyncChild* aActor)
+  {
+    MOZ_ASSERT(!mActor);
+    MOZ_ASSERT(aActor);
+    mActor = aActor;
+  }
+
+  NS_IMETHOD Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (mActor->IsActorDestroyed()) {
+      return NS_OK;
+    }
+
+    return mActor->ExecuteOp(mPromise, mOp);
+  }
+
+  NS_IMETHOD Cancel() override
+  {
+    mActor = nullptr;
+    mPromise = nullptr;
+    mOp = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~SyncOpRunnable() {}
+
+  RefPtr<Promise> mPromise;
+  nsAutoPtr<SyncOp> mOp;
+  RefPtr<BackgroundSyncChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(SyncOpRunnable, nsICancelableRunnable, nsIRunnable)
+
+class TeardownRunnable final : public nsIRunnable,
+                               public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  explicit TeardownRunnable(BackgroundSyncChild* aActor)
+    : mActor(aActor)
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHOD Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (!mActor->IsActorDestroyed()) {
+      mActor->SendShutdown();
+    }
+    return NS_OK;
+  }
+
+  NS_IMETHOD Cancel() override
+  {
+    mActor = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~TeardownRunnable() {};
+
+  RefPtr<BackgroundSyncChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(TeardownRunnable, nsICancelableRunnable, nsIRunnable)
+
+class BackgroundSyncHolder final : public workers::WorkerHolder
+{
+  // The manager keeps the WorkerHolder alive.
+  BackgroundSync* MOZ_NON_OWNING_REF mManager;
+
+public:
+  explicit BackgroundSyncHolder(BackgroundSync* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(aManager);
+    MOZ_COUNT_CTOR(BackgroundSyncHolder);
+  }
+
+  virtual bool Notify(workers::Status aStatus) override
+  {
+    if (aStatus >= Closing) {
+      mManager->Shutdown();
+    }
+    return true;
+  }
+
+private:
+  ~BackgroundSyncHolder()
+  {
+    MOZ_COUNT_CTOR(BackgroundSyncHolder);
+  }
+};
+
 // BackgroundSync
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnMainThread(nsIGlobalObject* aGlobal,
                                    nsIPrincipal* aPrincipal,
                                    ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   PrincipalInfo principalInfo;
-  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
+  aRv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
+
+  // Register as observer for inner-window-destroyed.
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    aRv = obs->AddObserver(ref, "inner-window-destroyed",
+                           false /* ownsWeak */);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+
+    aRv = obs->AddObserver(ref, "xpcom-shutdown",
+                           false /* ownsWeak */);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+  } else {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  MOZ_ASSERT(window);
+  MOZ_ASSERT(window->IsInnerWindow());
+  ref->mInnerID = window->WindowID();
+
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
                                WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal,
                                                   principalInfo);
+
+  ref->mWorkerHolder = new BackgroundSyncHolder(ref);
+  if (NS_WARN_IF(!ref->mWorkerHolder->HoldWorker(aWorkerPrivate))) {
+    ref->mWorkerHolder = nullptr;
+    return nullptr;
+  }
+
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
                                const PrincipalInfo& aPrincipalInfo)
-  : mGlobal(aGlobal)
-  , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
-{}
+  : mInnerID(0)
+  , mGlobal(aGlobal)
+  , mShuttingDown(false)
+  , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
+{
+#ifdef DEBUG
+  mThread = do_GetCurrentThread();
+#endif
+
+  MOZ_ASSERT(aGlobal);
+
+  // Register this component to PBackground.
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    ActorCreated(actor);
+  } else {
+    MOZ_ALWAYS_TRUE(BackgroundChild::GetOrCreateForCurrentThread(this));
+  }
+}
 
 BackgroundSync::~BackgroundSync()
-{}
+{
+  Shutdown();
+  MOZ_ASSERT(!mWorkerHolder);
+  MOZ_ASSERT(!mActor);
+}
+
+#ifdef DEBUG
+bool
+BackgroundSync::IsBackgroundSyncThread() {
+  return mThread == nsCOMPtr<nsIThread>(do_GetCurrentThread());
+};
+#endif
+
+void
+BackgroundSync::Shutdown()
+{
+  if (mShuttingDown) {
+    return;
+  }
+
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  mShuttingDown = true;
+
+  if (NS_IsMainThread()) {
+    nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+    if (obs) {
+      obs->RemoveObserver(this, "inner-window-destroyed");
+      obs->RemoveObserver(this, "xpcom-shutdown");
+    }
+  }
+
+  if (mWorkerHolder) {
+    // The DTOR of this WorkerHolder will release the worker for us.
+    mWorkerHolder = nullptr;
+  }
+
+  if (mActor) {
+    RefPtr<TeardownRunnable> runnable = new TeardownRunnable(mActor);
+    Unused << NS_WARN_IF(NS_FAILED(NS_DispatchToCurrentThread(runnable)));
+    mActor = nullptr;
+  }
+
+  mPendingOperations.Clear();
+}
 
 // Bindings methods.
 
 JSObject*
 BackgroundSync::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
   return mozilla::dom::BackgroundSyncBinding::Wrap(aCx, this, aGivenProto);
 }
 
 // static
 bool
 BackgroundSync::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   using mozilla::dom::workers::WorkerPrivate;
@@ -97,43 +308,138 @@ BackgroundSync::PrefEnabled(JSContext* a
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
   if (!workerPrivate) {
     return false;
   }
 
   return workerPrivate->BackgroundSyncEnabled();
 }
 
-// WebIDL interace methods.
+// nsIIPCBackgroundChildCreateCallback methods.
+
+void
+BackgroundSync::ActorFailed()
+{
+  MOZ_CRASH("Failed to create a PBackgroundChild actor!");
+}
+
+void
+BackgroundSync::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+  MOZ_ASSERT(aActor);
+  MOZ_ASSERT(!mActor);
+
+  if (mShuttingDown) {
+    return;
+  }
+
+  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  mActor = static_cast<BackgroundSyncChild*>(actor);
+  MOZ_ASSERT(mActor);
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
+    RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
+    MOZ_ASSERT(runnable);
+    runnable->SetActor(mActor);
+    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+      NS_WARNING("Failed to dispatch to the current thread");
+      mPendingOperations.Clear();
+      return;
+    }
+  }
+  mPendingOperations.Clear();
+}
+
+// nsIObserver
+
+NS_IMETHODIMP
+BackgroundSync::Observe(nsISupports* aSubject,
+                        const char* aTopic,
+                        const char16_t* aData)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!strcmp(aTopic, "inner-window-destroyed") ||
+             !strcmp(aTopic, "xpcom-shutdown"));
+
+  if (!strcmp(aTopic, "inner-window-destroyed")) {
+    nsCOMPtr<nsISupportsPRUint64> wrapper = do_QueryInterface(aSubject);
+    NS_ENSURE_TRUE(wrapper, NS_ERROR_FAILURE);
+
+    uint64_t innerID;
+    nsresult rv = wrapper->GetData(&innerID);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    if (innerID != mInnerID) {
+      return NS_OK;
+    }
+  }
+
+  Shutdown();
+
+  return NS_OK;
+}
 
 already_AddRefed<Promise>
-BackgroundSync::Register(const nsAString& aName, ErrorResult& aRv)
+BackgroundSync::ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv)
 {
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  if (mShuttingDown) {
+    return nullptr;
+  }
+
   RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
+  nsAutoPtr<SyncOp> op(new SyncOp(*mPrincipalInfo, aArgs));
+  RefPtr<SyncOpRunnable> runnable = new SyncOpRunnable(p, op);
+
+  if (!mActor) {
+    mPendingOperations.AppendElement(runnable);
+    return p.forget();
+  }
+
+  runnable->SetActor(mActor);
+  nsresult rv = NS_DispatchToCurrentThread(runnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    p->MaybeReject(rv);
+  }
+
   return p.forget();
 }
 
+// WebIDL interface methods.
+
+already_AddRefed<Promise>
+BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  const SyncRegisterArgs args((nsString(aTag)));
+  return ExecuteOp(SyncOpArgs(args), aRv);
+}
+
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
-  RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
-  if (NS_WARN_IF(aRv.Failed())) {
-    return nullptr;
-  }
+  MOZ_ASSERT(IsBackgroundSyncThread());
 
-  return p.forget();
+  const SyncGetTagsArgs args;
+  return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(BackgroundSync, mGlobal)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(BackgroundSync)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(BackgroundSync)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(BackgroundSync)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
+  NS_INTERFACE_MAP_ENTRY(nsIObserver)
 NS_INTERFACE_MAP_END
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -5,45 +5,57 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSync_h
 #define mozilla_dom_BackgroundSync_h
 
 #include "jsapi.h"
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/ErrorResult.h"
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "nsCOMPtr.h"
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIObserver.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 class nsIPrincipal;
 
 namespace mozilla {
 
 namespace ipc {
   class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 namespace workers {
+  class WorkerHolder;
   class WorkerPrivate;
 } // namespace workers
 
 class Promise;
 
 namespace backgroundsync {
 
-class BackgroundSync final : public nsISupports
+class BackgroundSyncChild;
+class SyncOpRunnable;
+
+class BackgroundSync final : public nsIIPCBackgroundChildCreateCallback
+                           , public nsIObserver
                            , public nsWrapperCache
 {
+  NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
+  NS_DECL_NSIOBSERVER
+
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(BackgroundSync)
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
+      BackgroundSync, nsIIPCBackgroundChildCreateCallback)
 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
   CreateOnWorker(nsIGlobalObject* aGlobal,
@@ -60,29 +72,49 @@ public:
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
   // WebIDL interface methods.
 
   already_AddRefed<Promise>
-  Register(const nsAString& aName, ErrorResult& aRv);
+  Register(const nsAString& aTag, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetTags(ErrorResult& aRv);
 
+  void Shutdown();
 private:
   BackgroundSync(nsIGlobalObject* aGlobal,
                  const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
   ~BackgroundSync();
 
+  already_AddRefed<Promise>
+  ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
+
+  uint64_t mInnerID;
+
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
-  nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+  nsAutoPtr<workers::WorkerHolder> mWorkerHolder;
+
+  RefPtr<BackgroundSyncChild> mActor;
+
+  bool mShuttingDown;
+
+  UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+
+  nsCOMPtr<nsIThread> mThread;
+
+  nsTArray<RefPtr<SyncOpRunnable>> mPendingOperations;
+
+#ifdef DEBUG
+  bool IsBackgroundSyncThread();
+#endif
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSync_h
diff --git a/dom/backgroundsync/BackgroundSyncChild.cpp b/dom/backgroundsync/BackgroundSyncChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncChild.cpp
@@ -0,0 +1,129 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BackgroundSyncChild.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+#include "nsContentUtils.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+namespace backgroundsync {
+
+struct BackgroundSyncChild::PendingRequest final
+{
+  explicit PendingRequest(Promise* aPromise)
+    : mPromise(aPromise)
+  {}
+
+  RefPtr<Promise> mPromise;
+};
+
+BackgroundSyncChild::BackgroundSyncChild()
+  : mActorDestroyed(false)
+{
+}
+
+BackgroundSyncChild::~BackgroundSyncChild()
+{
+}
+
+void
+BackgroundSyncChild::ActorDestroy(ActorDestroyReason aWhy)
+{
+  mActorDestroyed = true;
+
+  for (auto iter = mPendingRequests.Iter(); !iter.Done(); iter.Next()) {
+    PendingRequest* request;
+    mPendingRequests.Get(iter.Key(), &request);
+    if (NS_WARN_IF(!request)) {
+      continue;
+    }
+    request->mPromise->MaybeReject(NS_ERROR_NOT_AVAILABLE);
+  }
+
+  mPendingRequests.Clear();
+}
+
+nsresult
+BackgroundSyncChild::StorePendingRequest(Promise* aPromise, nsID& aID)
+{
+  nsID id;
+  nsresult rv = nsContentUtils::GenerateUUIDInPlace(id);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PendingRequest* request = new PendingRequest(aPromise);
+  mPendingRequests.Put(id, request);
+
+  aID = id;
+
+  return NS_OK;
+}
+
+Promise*
+BackgroundSyncChild::GetPendingRequest(const nsID& aID)
+{
+  PendingRequest* request = mPendingRequests.Get(aID);
+  if (NS_WARN_IF(!request)) {
+    return nullptr;
+  }
+
+  RefPtr<Promise> promise = request->mPromise;
+
+  mPendingRequests.Remove(const_cast<nsID&>(aID));
+  return promise;
+}
+
+nsresult
+BackgroundSyncChild::ExecuteOp(Promise* aPromise, SyncOp* aOp)
+{
+  if (mActorDestroyed) {
+    return NS_OK;
+  }
+
+  nsID requestId;
+  nsresult rv = StorePendingRequest(aPromise, requestId);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Unused << SendRequest(requestId, *aOp);
+
+  return NS_OK;
+}
+
+bool
+BackgroundSyncChild::RecvResponse(const nsID& aRequestId,
+                                  const SyncOpResponse& aResponse)
+{
+  Promise* p = GetPendingRequest(aRequestId);
+  if (NS_WARN_IF(!p)) {
+    // This should never happen.
+    return false;
+  }
+
+  switch(aResponse.type()) {
+    case SyncOpResponse::TSyncRegisterResponse:
+      p->MaybeResolve(true);
+      return true;
+    case SyncOpResponse::TSyncGetTagsResponse:
+      p->MaybeResolve(aResponse.get_SyncGetTagsResponse().mTags());
+      return true;
+    case SyncOpResponse::TSyncOpError:
+      p->MaybeReject(
+          static_cast<nsresult>(aResponse.get_SyncOpError().mCode()));
+      return true;
+    default:
+      MOZ_CRASH("Unknown BackgroundSync response");
+      return false;
+  }
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncChild_h
+#define mozilla_dom_BackgroundSyncChild_h
+
+#include "BackgroundSync.h"
+
+#include "mozilla/dom/PBackgroundSyncChild.h"
+
+#include "nsID.h"
+#include "nsClassHashtable.h"
+
+namespace mozilla {
+
+namespace ipc {
+class BackgroundChildImpl;
+} // namespace ipc
+
+namespace dom {
+namespace backgroundsync {
+
+class BackgroundSync;
+
+class BackgroundSyncChild final : public PBackgroundSyncChild
+{
+  friend class mozilla::ipc::BackgroundChildImpl;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncChild)
+
+  bool IsActorDestroyed() const
+  {
+    return mActorDestroyed;
+  }
+
+  nsresult ExecuteOp(Promise* aPromise, SyncOp* aOp);
+
+  virtual bool RecvResponse(const nsID& aRequestId,
+                            const SyncOpResponse& aResponse) override;
+
+private:
+  BackgroundSyncChild();
+  ~BackgroundSyncChild();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  nsresult StorePendingRequest(Promise* aPromise, nsID& aID);
+  Promise* GetPendingRequest(const nsID& aID);
+
+  bool mActorDestroyed;
+
+  struct PendingRequest;
+  nsClassHashtable<nsIDHashKey, PendingRequest> mPendingRequests;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncChild_h
diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -0,0 +1,54 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+
+namespace mozilla {
+namespace dom {
+
+struct SyncRegisterArgs
+{
+  nsString mTag;
+};
+
+struct SyncGetTagsArgs
+{
+};
+
+union SyncOpArgs
+{
+  SyncRegisterArgs;
+  SyncGetTagsArgs;
+};
+
+struct SyncOp
+{
+  PrincipalInfo mPrincipal;
+  SyncOpArgs mArgs;
+};
+
+struct SyncRegisterResponse
+{
+  bool mSuccess;
+};
+
+struct SyncGetTagsResponse
+{
+  nsString[] mTags;
+};
+
+struct SyncOpError
+{
+  uint32_t mCode;
+};
+
+union SyncOpResponse
+{
+  SyncRegisterResponse;
+  SyncGetTagsResponse;
+  SyncOpError;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BackgroundSyncParent.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/BackgroundParent.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+namespace backgroundsync {
+
+BackgroundSyncParent::BackgroundSyncParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+BackgroundSyncParent::~BackgroundSyncParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+{
+  AssertIsOnBackgroundThread();
+}
+
+bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                       const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  switch(aOp.mArgs().type()) {
+    case SyncOpArgs::TSyncRegisterArgs:
+    {
+      // XXX Do registration.
+      const SyncRegisterResponse response(true);
+      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    case SyncOpArgs::TSyncGetTagsArgs:
+    {
+      //XXX Do GetTags.
+      nsTArray<nsString> tags;
+      const SyncGetTagsResponse response(tags);
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync request");
+    }
+  }
+  return true;
+}
+
+bool BackgroundSyncParent::RecvShutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  Unused << Send__delete__(this);
+
+  return true;
+}
+
+void
+BackgroundSyncParent::NotifyResponse(const nsID& aRequestId,
+                                     const SyncOpResponse& aResponse)
+{
+  AssertIsOnBackgroundThread();
+
+  Unused << SendResponse(aRequestId, aResponse);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -0,0 +1,48 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncParent_h
+#define mozilla_dom_BackgroundSyncParent_h
+
+#include "mozilla/dom/PBackgroundSyncParent.h"
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+
+#include "nsID.h"
+
+namespace mozilla {
+
+namespace ipc {
+  class BackgroundParentImpl;
+} // namespace ipc
+
+namespace dom {
+namespace backgroundsync {
+
+class BackgroundSyncParent final : public PBackgroundSyncParent
+{
+  friend class mozilla::ipc::BackgroundParentImpl;
+
+public:
+  virtual bool RecvRequest(const nsID& aRequestId,
+                           const SyncOp& aOp) override;
+
+  virtual bool RecvShutdown() override;
+
+  void NotifyResponse(const nsID& aRequestId,
+                      const SyncOpResponse& aResponse);
+
+private:
+  BackgroundSyncParent();
+  ~BackgroundSyncParent();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncParent_h
diff --git a/dom/backgroundsync/PBackgroundSync.ipdl b/dom/backgroundsync/PBackgroundSync.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/PBackgroundSync.ipdl
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+include BackgroundSyncIPCTypes;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+
+protocol PBackgroundSync
+{
+  manager PBackground;
+
+parent: // child -> parent messages
+  async Request(nsID aRequestId, SyncOp aOp);
+  async Shutdown();
+
+child: // parent -> child messages
+  async Response(nsID requestId, SyncOpResponse aResponse);
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -3,17 +3,24 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.backgroundsync += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
-    'BackgroundSync.cpp'
+    'BackgroundSync.cpp',
+    'BackgroundSyncChild.cpp',
+    'BackgroundSyncParent.cpp'
+]
+
+IPDL_SOURCES += [
+    'BackgroundSyncIPCTypes.ipdlh',
+    'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
     '/dom/workers'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -4,16 +4,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
 #include "ActorsChild.h" // IndexedDB
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
+#include "BackgroundSyncChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PFileSystemRequestChild.h"
@@ -71,16 +72,17 @@ namespace ipc {
 using mozilla::dom::UDPSocketChild;
 using mozilla::net::PUDPSocketChild;
 
 using mozilla::dom::asmjscache::PAsmJSCacheEntryChild;
 using mozilla::dom::cache::PCacheChild;
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::PCacheStreamControlChild;
 using mozilla::dom::PNuwaChild;
+using mozilla::dom::backgroundsync::BackgroundSyncChild;
 
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl::ThreadLocal
 // -----------------------------------------------------------------------------
 
 BackgroundChildImpl::
 ThreadLocal::ThreadLocal()
   : mCurrentFileHandle(nullptr)
@@ -519,16 +521,36 @@ BackgroundChildImpl::DeallocPGamepadTest
 {
 #ifdef MOZ_GAMEPAD
   MOZ_ASSERT(aActor);
   delete static_cast<dom::GamepadTestChannelChild*>(aActor);
 #endif
   return true;
 }
 
+// -----------------------------------------------------------------------------
+// Background Sync API
+// -----------------------------------------------------------------------------
+
+dom::PBackgroundSyncChild*
+BackgroundChildImpl::AllocPBackgroundSyncChild()
+{
+  RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
+  return agent.forget().take();
+}
+
+bool
+BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
+{
+  RefPtr<BackgroundSyncChild> child =
+    dont_AddRef(static_cast<BackgroundSyncChild*>(aActor));
+  MOZ_ASSERT(child);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -179,16 +179,22 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelChild(PGamepadEventChannelChild* aActor) override;
 
   virtual PGamepadTestChannelChild*
   AllocPGamepadTestChannelChild() override;
 
   virtual bool
   DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor) override;
+
+  virtual PBackgroundSyncChild*
+  AllocPBackgroundSyncChild() override;
+
+  virtual bool
+  DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -46,16 +46,17 @@
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsProxyRelease.h"
 #include "mozilla/RefPtr.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 #include "ServiceWorkerManagerParent.h"
+#include "BackgroundSyncParent.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
 #else
 #define ASSERT_UNLESS_FUZZING(...) MOZ_ASSERT(false)
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
@@ -64,16 +65,17 @@ using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::PCacheStorageParent;
 using mozilla::dom::cache::PCacheStreamControlParent;
 using mozilla::dom::FileSystemBase;
 using mozilla::dom::FileSystemRequestParent;
 using mozilla::dom::MessagePortParent;
 using mozilla::dom::NuwaParent;
 using mozilla::dom::PMessagePortParent;
 using mozilla::dom::PNuwaParent;
+using mozilla::dom::backgroundsync::BackgroundSyncParent;
 using mozilla::dom::UDPSocketParent;
 
 namespace {
 
 void
 AssertIsOnMainThread()
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -102,16 +104,17 @@ public:
 } // namespace
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::BroadcastChannelParent;
 using mozilla::dom::ServiceWorkerRegistrationData;
+using mozilla::dom::backgroundsync::BackgroundSyncParent;
 using mozilla::dom::workers::ServiceWorkerManagerParent;
 
 BackgroundParentImpl::BackgroundParentImpl()
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
 
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundParentImpl);
@@ -966,16 +969,36 @@ BackgroundParentImpl::DeallocPGamepadTes
 #ifdef MOZ_GAMEPAD
   MOZ_ASSERT(aActor);
   RefPtr<dom::GamepadTestChannelParent> parent =
     dont_AddRef(static_cast<dom::GamepadTestChannelParent*>(aActor));
 #endif
   return true;
 }
 
+mozilla::dom::PBackgroundSyncParent*
+BackgroundParentImpl::AllocPBackgroundSyncParent()
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+
+  return new BackgroundSyncParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aActor);
+
+  delete static_cast<BackgroundSyncParent*>(aActor);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -210,14 +210,20 @@ protected:
   virtual bool
   DeallocPGamepadEventChannelParent(PGamepadEventChannelParent *aActor) override;
 
   virtual PGamepadTestChannelParent*
   AllocPGamepadTestChannelParent() override;
 
   virtual bool
   DeallocPGamepadTestChannelParent(PGamepadTestChannelParent* aActor) override;
+
+  virtual PBackgroundSyncParent*
+  AllocPBackgroundSyncParent() override;
+
+  virtual bool
+  DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -16,16 +16,17 @@ include protocol PFileSystemRequest;
 include protocol PGamepadEventChannel;
 include protocol PGamepadTestChannel;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PNuwa;
 include protocol PQuota;
 include protocol PSendStream;
 include protocol PServiceWorkerManager;
+include protocol PBackgroundSync;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 include PFileSystemParams;
 include ProtocolTypes;
@@ -44,16 +45,17 @@ using mozilla::dom::asmjscache::WritePar
 namespace mozilla {
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PAsmJSCacheEntry;
   manages PBackgroundIDBFactory;
   manages PBackgroundIndexedDBUtils;
+  manages PBackgroundSync;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
@@ -107,16 +109,18 @@ parent:
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
   async PGamepadEventChannel();
 
   async PGamepadTestChannel();
 
+  async PBackgroundSync();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
   async PFileDescriptorSet(FileDescriptor fd);
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -151,16 +151,17 @@ SOURCES += [
 if CONFIG['_MSC_VER']:
     # This is intended as a temporary hack to support building with VS2015.
     # 'reinterpret_cast': conversion from 'DWORD' to 'HANDLE' of greater size
     SOURCES['BackgroundChildImpl.cpp'].flags += ['-wd4312']
     SOURCES['BackgroundParentImpl.cpp'].flags += ['-wd4312']
 
 LOCAL_INCLUDES += [
     '/caps',
+    '/dom/backgroundsync',
     '/dom/broadcastchannel',
     '/dom/indexedDB',
     '/dom/workers',
     '/media/webrtc/trunk',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
