# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  7b989cc9040b2e104a2e7594c100a42aa664500a

diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
--- a/dom/backgroundsync/StorageContext.cpp
+++ b/dom/backgroundsync/StorageContext.cpp
@@ -28,16 +28,17 @@ class NullAction final : public StorageA
 public:
   NullAction()
   {
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
   {
+    printf_stderr("NullAction::RunOnTarget\n");
     // Resolve success immediately. This Action does no actual work.
     MOZ_ASSERT(aResolver);
     aResolver->Resolve(NS_OK);
   }
 };
 
 } // namespace
 
@@ -114,40 +115,43 @@ public:
     , mData(aData)
     , mTarget(aTarget)
     , mInitAction(aInitAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mResult(NS_OK)
     , mState(STATE_INIT)
     , mCanceled(false)
   {
+    printf_stderr("QuotaInitRunnable\n");
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mData);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mInitiatingThread);
     MOZ_ASSERT(mInitAction);
   }
 
   nsresult Dispatch()
   {
+    printf_stderr("QuotaInitRunnable::Dispatch\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mState == STATE_INIT);
 
     mState = STATE_GET_INFO;
     nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
   void Cancel()
   {
+    printf_stderr("QuotaInitRunnable::Cancel\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(!mCanceled);
     mCanceled = true;
     mInitAction->CancelOnInitiatingThread();
   }
 
   void OpenDirectory();
 
@@ -165,16 +169,17 @@ private:
     SyncResolver()
       : mResolved(false)
       , mResult(NS_OK)
     { }
 
     virtual void
     Resolve(nsresult aRv) override
     {
+      printf_stderr("SyncResolver::Resolve %d\n", aRv);
       MOZ_ASSERT(!mResolved);
       mResolved = true;
       mResult = aRv;
     };
 
     bool Resolved() const { return mResolved; }
     nsresult Result() const { return mResult; }
 
@@ -185,16 +190,17 @@ private:
     nsresult mResult;
 
     NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
                                override)
   };
 
   ~QuotaInitRunnable()
   {
+    printf_stderr("QuotaInitRunnable::~QuotaInitRunnable\n");
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mInitAction);
   }
 
   enum State
   {
     STATE_INIT,
@@ -206,28 +212,30 @@ private:
     STATE_RUN_ON_TARGET,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Complete(nsresult aResult)
   {
+    printf_stderr("QuotaInitRunnable::Complete\n");
     MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
 
     MOZ_ASSERT(NS_SUCCEEDED(mResult));
     mResult = aResult;
 
     mState = STATE_COMPLETING;
     MOZ_ALWAYS_SUCCEEDS(
       mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
   }
 
   void Clear()
   {
+    printf_stderr("QuotaInitRunnable::Clear\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mContext);
     mContext = nullptr;
     mManager = nullptr;
     mInitAction = nullptr;
   }
 
   RefPtr<StorageContext> mContext;
@@ -364,16 +372,17 @@ StorageContext::QuotaInitRunnable::Run()
   // state cases for thread assertions.
 
   RefPtr<SyncResolver> resolver = new SyncResolver();
 
   switch(mState) {
     // -----------------------------------
     case STATE_GET_INFO:
     {
+    printf_stderr("QuotaInitRunnable::Run() GET_INFO \n");
       MOZ_ASSERT(NS_IsMainThread());
 
       if (mCanceled) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
@@ -390,16 +399,17 @@ StorageContext::QuotaInitRunnable::Run()
       mState = STATE_CREATE_QUOTA_MANAGER;
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // ----------------------------------
     case STATE_CREATE_QUOTA_MANAGER:
     {
+      printf_stderr("QuotaInitRunnable::Run() CREATE_QUOTE_MANAGER\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (mCanceled || QuotaManager::IsShuttingDown()) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       if (QuotaManager::Get()) {
@@ -409,73 +419,79 @@ StorageContext::QuotaInitRunnable::Run()
 
       mState = STATE_OPEN_DIRECTORY;
       QuotaManager::GetOrCreate(this);
       break;
     }
     // ----------------------------------
     case STATE_OPEN_DIRECTORY:
     {
+    printf_stderr("QuotaInitRunnable::Run() OPEN_DIRECTORY\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (NS_WARN_IF(!QuotaManager::Get())) {
         resolver->Resolve(NS_ERROR_FAILURE);
         break;
       }
 
       OpenDirectory();
       break;
     }
     // ----------------------------------
     case STATE_ENSURE_ORIGIN_INITIALIZED:
     {
+      printf_stderr("QuotaInitRunnable::Run() ORIGIN_INITIALIZED\n");
       AssertIsOnIOThread();
 
       if (mCanceled) {
+        printf_stderr("mCanceled\n");
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
+        printf_stderr("EnsureOriginInitialized failed %d\n", rv);
         resolver->Resolve(rv);
         break;
       }
 
       mState = STATE_RUN_ON_TARGET;
 
       MOZ_ALWAYS_SUCCEEDS(
         mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("QuotaInitRunnable::Run() RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
 
       mState = STATE_RUNNING;
 
       // Execute the provided initialization StorageAction. The
       // StorageAction must Resolve() before returning.
       mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
       MOZ_ASSERT(resolver->Resolved());
 
       mData = nullptr;
 
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("QuotaInitRunnable::Run() COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
       mInitAction->CompleteOnInitiatingThread(mResult);
       mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
       mState = STATE_COMPLETE;
 
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
@@ -511,16 +527,17 @@ public:
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
     , mExecutingRunOnTarget(false)
   {
+    printf_stderr("ActionRunnable ---- \n");
     MOZ_ASSERT(mContext);
     // mData may be nullptr
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
     MOZ_ASSERT(mInitiatingThread);
   }
 
@@ -542,16 +559,17 @@ public:
   Cancel() override
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) override
   {
+    printf_stderr("ActionRunnable::Resolve\n");
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     MOZ_ASSERT(mState == STATE_RUNNING);
 
     mResult = aRv;
 
     // We ultimately must complete on the initiating thread, but bounce through
     // the current thread again to ensure that we don't destroy objects and
     // state out from under the currently running action's stack.
@@ -653,16 +671,17 @@ NS_IMPL_ISUPPORTS(StorageContext::Action
 // does not see any execution there. Its all handled internal to the StorageAction.
 NS_IMETHODIMP
 StorageContext::ActionRunnable::Run()
 {
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       MOZ_ASSERT(!mExecutingRunOnTarget);
 
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
@@ -680,30 +699,32 @@ StorageContext::ActionRunnable::Run()
         Run();
       }
 
       break;
     }
     // -----------------
     case STATE_RESOLVING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RESOLVING\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       // The call to StorageAction::RunOnTarget() must have returned now if we
       // are running on the target thread again.  We may now proceed
       // with completion.
       mState = STATE_COMPLETING;
       // Shutdown must be delayed until all Contexts are destroyed.  Crash
       // for this invariant violation.
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(ActionRunnable);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
@@ -715,16 +736,17 @@ StorageContext::ActionRunnable::Run()
     }
   }
   return NS_OK;
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToClose()
 {
+  printf_stderr("ThreadSafeHandle::AllowToClose()\n");
   if (mOwningThread == NS_GetCurrentThread()) {
     AllowToCloseOnOwningThread();
     return;
   }
 
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all StorageContexts have been destroyed.
   nsCOMPtr<nsIRunnable> runnable =
@@ -769,16 +791,17 @@ StorageContext::ThreadsafeHandle::~Threa
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all Contexts have been destroyed.
   NS_ProxyRelease(mOwningThread, mStrongRef.forget());
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
 {
+  printf_stderr("ThreadsafeHandle::AllowToCloseOnOwningThread()\n");
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
 
   // A StorageContext "closes" when its ref count drops to zero. Dropping this
   // strong ref is necessary, but not sufficient for the close to occur.
   // Any outstanding IO will continue and keep the StorageContext alive. Once
   // the StorageContext is idle, it will be destroyed.
 
   // First, tell the context to flush any target thread shared data. This
@@ -820,16 +843,17 @@ StorageContext::ThreadsafeHandle::Storag
   mWeakRef = nullptr;
 }
 
 // static
 already_AddRefed<StorageContext>
 StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
                        StorageAction* aInitAction, StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Create\n");
   RefPtr<StorageContext> context =
     new StorageContext(aManager, aTarget, aInitAction);
   context->Init(aOldContext);
   return context.forget();
 }
 
 StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
                                StorageAction* aInitAction)
@@ -916,48 +940,52 @@ StorageContext::AllowToClose()
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   if (mThreadsafeHandle) {
     mThreadsafeHandle->AllowToClose();
   }
 }
 
 StorageContext::~StorageContext()
 {
+  printf_stderr("StorageContext DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mManager);
   MOZ_ASSERT(!mData);
 
   if (mThreadsafeHandle) {
     mThreadsafeHandle->StorageContextDestroyed(this);
   }
 
   // Note, this may set the mOrphanedData flag.
+  printf_stderr("Calling RemoveStorageContext\n");
   mManager->RemoveStorageContext(this);
 
   if (mNextContext) {
     mNextContext->Start();
   }
 }
 
 void
 StorageContext::Init(StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   if (aOldContext) {
     aOldContext->SetNextContext(this);
     return;
   }
 
   Start();
 }
 
 void
 StorageContext::Start()
 {
+  printf_stderr("StorageContext::Start\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   // Previous context closing delayed our start, but then we were canceled.
   // In this case, just do nothing here.
   if (mState == STATE_CONTEXT_CANCELED) {
     MOZ_ASSERT(!mInitRunnable);
     MOZ_ASSERT(!mInitAction);
     return;
@@ -979,16 +1007,17 @@ StorageContext::Start()
     // Crash for this invariant violation.
     MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
   }
 }
 
 void
 StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
 {
+  printf_stderr("StorageContext::DispatchAction\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   RefPtr<ActionRunnable> runnable =
     new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
 
   if (aDoomData) {
     mData = nullptr;
   }
@@ -1001,16 +1030,17 @@ StorageContext::DispatchAction(StorageAc
   }
   AddActivity(runnable);
 }
 
 void
 StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                             already_AddRefed<quota::DirectoryLock> aDirectoryLock)
 {
+  printf_stderr("StorageContext::OnQuotaInit\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   MOZ_ASSERT(mInitRunnable);
   mInitRunnable = nullptr;
 
   mQuotaInfo = aQuotaInfo;
 
   // Always save the directory lock to ensure QuotaManager does not shutdown
@@ -1018,16 +1048,17 @@ StorageContext::OnQuotaInit(nsresult aRv
   MOZ_ASSERT(!mDirectoryLock);
   mDirectoryLock = aDirectoryLock;
 
   // If we opening the context failed, but we were not explicitly canceled,
   // still treat the entire context as canceled.  We don't want to allow
   // new actions to be dispatched.  We also cannot leave the context in
   // the INIT state after failing to open.
   if (NS_FAILED(aRv)) {
+    printf_stderr("QuotaInit failed - STATE_CONTEXT_CANCELED\n");
     mState = STATE_CONTEXT_CANCELED;
   }
 
   if (mState == STATE_CONTEXT_CANCELED) {
     for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
@@ -1089,16 +1120,17 @@ StorageContext::SetNextContext(StorageCo
   MOZ_ASSERT(aNextContext);
   MOZ_ASSERT(!mNextContext);
   mNextContext = aNextContext;
 }
 
 void
 StorageContext::DoomTargetData()
 {
+  printf_stderr("DoomTargetData\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mData);
 
   // We are about to drop our reference to the Data. We need to ensure that
   // the ~StorageContext() destructor does not run until contents of Data have
   // been released on the Target thread.
 
   // Dispatch a no-op StorageAction. This will hold the StorageContext alive
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -28,16 +28,17 @@ public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("SetupAction::RunSyncOnTarget\n");
     // Executes in its own transaction.
     nsresult rv = db::CreateOrMigrateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 };
 
@@ -295,16 +296,17 @@ protected:
   {}
 
   virtual void
   Complete(nsresult aRv) = 0;
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
+    printf_stderr("StorageManager::BaseAction::CompleteOnInitiatingThread\n");
     NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
 
     Complete(aRv);
 
     // Ensure we release the manager on the initiating thread.
     mManager = nullptr;
   }
 
@@ -318,30 +320,34 @@ class StorageManager::RegisterAction fin
 {
 public:
   RegisterAction(const nsID& aRequestId,
                  StorageManager* aManager,
                  const SyncRegisterArgs& aRegisterArgs)
     : BaseAction(aRequestId, aManager)
     , mArgs(aRegisterArgs)
     , mFirstRegistration(true)
-  {}
+  {
+    printf_stderr("RegisterAction::RegisterAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("RegisterAction::RunSyncOnTarget\n");
     nsresult rv = db::Register(aConn, mArgs, mFirstRegistration);
     NS_WARN_IF(NS_FAILED(rv));
     return rv;
   }
 
   virtual void
   Complete(nsresult aRv) override
   {
+    printf_stderr("RegisterAction::Complete\n");
     if (NS_FAILED(aRv)) {
       mManager->OnRequestComplete(mRequestId,
         SyncOpError(static_cast<uint32_t>(aRv)));
     } else {
       mManager->OnRequestComplete(mRequestId,
           SyncRegisterResponse(mArgs.mOrigin(), mFirstRegistration));
     }
   }
@@ -356,30 +362,34 @@ private:
 class StorageManager::GetTagsAction final : public StorageManager::BaseAction
 {
 public:
   GetTagsAction(const nsID& aRequestId,
                 StorageManager* aManager,
                 const SyncGetTagsArgs& aGetTagsArgs)
     : BaseAction(aRequestId, aManager)
     , mArgs(aGetTagsArgs)
-  {}
+  {
+    printf_stderr("GetTagsAction::GetTagsAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("GetTagsAction::RunSyncOnTarget\n");
     nsresult rv = db::GetTags(aConn, mArgs, mTags);
     NS_WARN_IF(NS_FAILED(rv));
     return rv;
   }
 
   virtual void
   Complete(nsresult aRv) override
   {
+    printf_stderr("GetTagsAction::Complete\n");
     if (NS_FAILED(aRv)) {
       mManager->OnRequestComplete(mRequestId,
         SyncOpError(static_cast<uint32_t>(aRv)));
     } else {
       mManager->OnRequestComplete(mRequestId,
         SyncGetTagsResponse(mTags));
     }
   }
@@ -540,16 +550,17 @@ StorageManager::StorageManager(Backgroun
 {
   MOZ_ASSERT(mService);
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
 }
 
 StorageManager::~StorageManager()
 {
+  printf_stderr("StorageManager DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mState == Closing);
   MOZ_ASSERT(!mContext);
 
   mService = nullptr;
 
 /*  nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
@@ -558,16 +569,17 @@ StorageManager::~StorageManager()
   // shutdown. Defer this to the main thread, instead.
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
 }
 
 void
 StorageManager::Init(StorageManager* aOldManager)
 {
+  printf_stderr("StorageManager::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   RefPtr<StorageContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
   // Create the context immediately. Since there can at most be one
@@ -577,32 +589,34 @@ StorageManager::Init(StorageManager* aOl
   RefPtr<StorageContext> ref = StorageContext::Create(this, mIOThread,
                                                       setupAction, oldContext);
   mContext = ref;
 }
 
 void
 StorageManager::Abort()
 {
+  printf_stderr("StorageManager::Abort\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
   // creating a new StorageContext. We must ensure all Contexts and IO
   // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
   RefPtr<StorageContext> context = mContext;
   context->CancelAll();
 }
 
 void
 StorageManager::Shutdown()
 {
+  printf_stderr("StorageManager::Shutdown\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // Ignore duplicate attempts to shutdown. This can occur when we start a
   // browser initiated shutdown and then run ~StorageManager() which also
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
@@ -620,25 +634,28 @@ StorageManager::Shutdown()
     RefPtr<StorageContext> context = mContext;
     context->CancelAll();
   }
 }
 
 void
 StorageManager::NoteClosing()
 {
+  printf_stderr("StorageManager::NoteClosing\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
 void
 StorageManager::RemoveStorageContext(StorageContext* aContext)
 {
+  printf_stderr("StorageManager::RemoveStorageContext\n");
+
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
   // Wether the StorageContext destruction was triggered from the StorageManager
   // going idle or the underlying storage being invalidated, we should know we
   // are closing before the StorageContext is destroyed.
   MOZ_ASSERT(mState == Closing);
@@ -649,16 +666,17 @@ StorageManager::RemoveStorageContext(Sto
   // Factory list. We don't need to block shutdown by stayin in the list
   // any more.
   Factory::Remove(this);
 }
 
 void
 StorageManager::MaybeAllowContextToClose()
 {
+  printf_stderr("StorageManager::MaybeAllowContextToClose\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   // If we have an active context, but we have no more pending requests,
   // then let it shut itself down. We must wait for all possible users
   // of state information to complete before doing this.
   RefPtr<StorageContext> context = mContext;
   if (context && mPendingRequests.IsEmpty()) {
     // Mark the StorageManager as invalid so that it won't get used again.
     NoteClosing();
@@ -666,16 +684,17 @@ StorageManager::MaybeAllowContextToClose
     context->AllowToClose();
   }
 }
 
 // Common to DOM and internal requests.
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, StorageAction* aAction)
 {
+  printf_stderr("StorageManager::ExecuteRequest\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(aAction);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
     OnRequestComplete(aRequestId,
@@ -761,16 +780,17 @@ StorageManager::OnRequestComplete(const 
 
   MaybeAllowContextToClose();
 }
 
 void
 StorageManager::OnRequestComplete(const nsID& aRequestId,
                                   const SyncOpResponse& aResponse)
 {
+  printf_stderr("StorageManager::OnRequestComplete\n");
   switch(aResponse.type()) {
     case SyncOpResponse::TSyncRegisterResponse:
     case SyncOpResponse::TSyncGetTagsResponse:
     case SyncOpResponse::TSyncOpError:
       mService->OnRequestComplete(aRequestId, SyncOpResponse(aResponse));
       break;
     case SyncOpResponse::TSyncGetAllResponse:
       break;
