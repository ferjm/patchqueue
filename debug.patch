# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  ad701028ec68c78f5bc991028501c6c856ea1189

diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
--- a/dom/backgroundsync/StorageContext.cpp
+++ b/dom/backgroundsync/StorageContext.cpp
@@ -28,16 +28,17 @@ class NullAction final : public StorageA
 public:
   NullAction()
   {
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
   {
+    printf_stderr("NullAction::RunOnTarget\n");
     // Resolve success immediately. This Action does no actual work.
     MOZ_ASSERT(aResolver);
     aResolver->Resolve(NS_OK);
   }
 };
 
 } // namespace
 
@@ -112,40 +113,43 @@ public:
     , mData(aData)
     , mTarget(aTarget)
     , mInitAction(aInitAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mResult(NS_OK)
     , mState(STATE_INIT)
     , mCanceled(false)
   {
+    printf_stderr("QuotaInitRunnable\n");
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mData);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mInitiatingThread);
     MOZ_ASSERT(mInitAction);
   }
 
   nsresult Dispatch()
   {
+    printf_stderr("QuotaInitRunnable::Dispatch\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mState == STATE_INIT);
 
     mState = STATE_GET_INFO;
     nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
   void Cancel()
   {
+    printf_stderr("QuotaInitRunnable::Cancel\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(!mCanceled);
     mCanceled = true;
     mInitAction->CancelOnInitiatingThread();
   }
 
   void OpenDirectory();
 
@@ -163,16 +167,17 @@ private:
     SyncResolver()
       : mResolved(false)
       , mResult(NS_OK)
     { }
 
     virtual void
     Resolve(nsresult aRv) override
     {
+      printf_stderr("SyncResolver::Resolve %d\n", aRv);
       MOZ_ASSERT(!mResolved);
       mResolved = true;
       mResult = aRv;
     };
 
     bool Resolved() const { return mResolved; }
     nsresult Result() const { return mResult; }
 
@@ -183,16 +188,17 @@ private:
     nsresult mResult;
 
     NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
                                override)
   };
 
   ~QuotaInitRunnable()
   {
+    printf_stderr("QuotaInitRunnable::~QuotaInitRunnable\n");
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mInitAction);
   }
 
   enum State
   {
     STATE_INIT,
@@ -204,28 +210,30 @@ private:
     STATE_RUN_ON_TARGET,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Complete(nsresult aResult)
   {
+    printf_stderr("QuotaInitRunnable::Complete\n");
     MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
 
     MOZ_ASSERT(NS_SUCCEEDED(mResult));
     mResult = aResult;
 
     mState = STATE_COMPLETING;
     MOZ_ALWAYS_SUCCEEDS(
       mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
   }
 
   void Clear()
   {
+    printf_stderr("QuotaInitRunnable::Clear\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mContext);
     mContext = nullptr;
     mManager = nullptr;
     mInitAction = nullptr;
   }
 
   RefPtr<StorageContext> mContext;
@@ -362,16 +370,17 @@ StorageContext::QuotaInitRunnable::Run()
   // state cases for thread assertions.
 
   RefPtr<SyncResolver> resolver = new SyncResolver();
 
   switch(mState) {
     // -----------------------------------
     case STATE_GET_INFO:
     {
+    printf_stderr("QuotaInitRunnable::Run() GET_INFO \n");
       MOZ_ASSERT(NS_IsMainThread());
 
       if (mCanceled) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
@@ -388,16 +397,17 @@ StorageContext::QuotaInitRunnable::Run()
       mState = STATE_CREATE_QUOTA_MANAGER;
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // ----------------------------------
     case STATE_CREATE_QUOTA_MANAGER:
     {
+      printf_stderr("QuotaInitRunnable::Run() CREATE_QUOTE_MANAGER\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (mCanceled || QuotaManager::IsShuttingDown()) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       if (QuotaManager::Get()) {
@@ -407,73 +417,79 @@ StorageContext::QuotaInitRunnable::Run()
 
       mState = STATE_OPEN_DIRECTORY;
       QuotaManager::GetOrCreate(this);
       break;
     }
     // ----------------------------------
     case STATE_OPEN_DIRECTORY:
     {
+    printf_stderr("QuotaInitRunnable::Run() OPEN_DIRECTORY\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (NS_WARN_IF(!QuotaManager::Get())) {
         resolver->Resolve(NS_ERROR_FAILURE);
         break;
       }
 
       OpenDirectory();
       break;
     }
     // ----------------------------------
     case STATE_ENSURE_ORIGIN_INITIALIZED:
     {
+      printf_stderr("QuotaInitRunnable::Run() ORIGIN_INITIALIZED\n");
       AssertIsOnIOThread();
 
       if (mCanceled) {
+        printf_stderr("mCanceled\n");
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
+        printf_stderr("EnsureOriginInitialized failed %d\n", rv);
         resolver->Resolve(rv);
         break;
       }
 
       mState = STATE_RUN_ON_TARGET;
 
       MOZ_ALWAYS_SUCCEEDS(
         mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("QuotaInitRunnable::Run() RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
 
       mState = STATE_RUNNING;
 
       // Execute the provided initialization StorageAction. The
       // StorageAction must Resolve() before returning.
       mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
       MOZ_ASSERT(resolver->Resolved());
 
       mData = nullptr;
 
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("QuotaInitRunnable::Run() COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
       mInitAction->CompleteOnInitiatingThread(mResult);
       mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
       mState = STATE_COMPLETE;
 
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
@@ -509,16 +525,17 @@ public:
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
     , mExecutingRunOnTarget(false)
   {
+    printf_stderr("ActionRunnable ---- \n");
     MOZ_ASSERT(mContext);
     // mData may be nullptr
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
     MOZ_ASSERT(mInitiatingThread);
   }
 
@@ -540,16 +557,17 @@ public:
   Cancel() override
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) override
   {
+    printf_stderr("ActionRunnable::Resolve\n");
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     MOZ_ASSERT(mState == STATE_RUNNING);
 
     mResult = aRv;
 
     // We ultimately must complete on the initiating thread, but bounce through
     // the current thread again to ensure that we don't destroy objects and
     // state out from under the currently running action's stack.
@@ -651,16 +669,17 @@ NS_IMPL_ISUPPORTS(StorageContext::Action
 // does not see any execution there. Its all handled internal to the StorageAction.
 NS_IMETHODIMP
 StorageContext::ActionRunnable::Run()
 {
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       MOZ_ASSERT(!mExecutingRunOnTarget);
 
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
@@ -678,30 +697,32 @@ StorageContext::ActionRunnable::Run()
         Run();
       }
 
       break;
     }
     // -----------------
     case STATE_RESOLVING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RESOLVING\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       // The call to StorageAction::RunOnTarget() must have returned now if we
       // are running on the target thread again.  We may now proceed
       // with completion.
       mState = STATE_COMPLETING;
       // Shutdown must be delayed until all Contexts are destroyed.  Crash
       // for this invariant violation.
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(ActionRunnable);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
@@ -713,16 +734,17 @@ StorageContext::ActionRunnable::Run()
     }
   }
   return NS_OK;
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToClose()
 {
+  printf_stderr("ThreadSafeHandle::AllowToClose()\n");
   if (mOwningThread == NS_GetCurrentThread()) {
     AllowToCloseOnOwningThread();
     return;
   }
 
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all StorageContexts have been destroyed.
   nsCOMPtr<nsIRunnable> runnable =
@@ -767,16 +789,17 @@ StorageContext::ThreadsafeHandle::~Threa
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all Contexts have been destroyed.
   NS_ProxyRelease(mOwningThread, mStrongRef.forget());
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
 {
+  printf_stderr("ThreadsafeHandle::AllowToCloseOnOwningThread()\n");
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
 
   // A StorageContext "closes" when its ref count drops to zero. Dropping this
   // strong ref is necessary, but not sufficient for the close to occur.
   // Any outstanding IO will continue and keep the StorageContext alive. Once
   // the StorageContext is idle, it will be destroyed.
 
   // First, tell the context to flush any target thread shared data. This
@@ -818,16 +841,17 @@ StorageContext::ThreadsafeHandle::Storag
   mWeakRef = nullptr;
 }
 
 // static
 already_AddRefed<StorageContext>
 StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
                        StorageAction* aInitAction, StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Create\n");
   RefPtr<StorageContext> context =
     new StorageContext(aManager, aTarget, aInitAction);
   context->Init(aOldContext);
   return context.forget();
 }
 
 StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
                                StorageAction* aInitAction)
@@ -914,48 +938,52 @@ StorageContext::AllowToClose()
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   if (mThreadsafeHandle) {
     mThreadsafeHandle->AllowToClose();
   }
 }
 
 StorageContext::~StorageContext()
 {
+  printf_stderr("StorageContext DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mManager);
   MOZ_ASSERT(!mData);
 
   if (mThreadsafeHandle) {
     mThreadsafeHandle->StorageContextDestroyed(this);
   }
 
   // Note, this may set the mOrphanedData flag.
+  printf_stderr("Calling RemoveStorageContext\n");
   mManager->RemoveStorageContext(this);
 
   if (mNextContext) {
     mNextContext->Start();
   }
 }
 
 void
 StorageContext::Init(StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   if (aOldContext) {
     aOldContext->SetNextContext(this);
     return;
   }
 
   Start();
 }
 
 void
 StorageContext::Start()
 {
+  printf_stderr("StorageContext::Start\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   // Previous context closing delayed our start, but then we were canceled.
   // In this case, just do nothing here.
   if (mState == STATE_CONTEXT_CANCELED) {
     MOZ_ASSERT(!mInitRunnable);
     MOZ_ASSERT(!mInitAction);
     return;
@@ -977,16 +1005,17 @@ StorageContext::Start()
     // Crash for this invariant violation.
     MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
   }
 }
 
 void
 StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
 {
+  printf_stderr("StorageContext::DispatchAction\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   RefPtr<ActionRunnable> runnable =
     new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
 
   if (aDoomData) {
     mData = nullptr;
   }
@@ -999,16 +1028,17 @@ StorageContext::DispatchAction(StorageAc
   }
   AddActivity(runnable);
 }
 
 void
 StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                             already_AddRefed<quota::DirectoryLock> aDirectoryLock)
 {
+  printf_stderr("StorageContext::OnQuotaInit\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   MOZ_ASSERT(mInitRunnable);
   mInitRunnable = nullptr;
 
   mQuotaInfo = aQuotaInfo;
 
   // Always save the directory lock to ensure QuotaManager does not shutdown
@@ -1016,16 +1046,17 @@ StorageContext::OnQuotaInit(nsresult aRv
   MOZ_ASSERT(!mDirectoryLock);
   mDirectoryLock = aDirectoryLock;
 
   // If we opening the context failed, but we were not explicitly canceled,
   // still treat the entire context as canceled.  We don't want to allow
   // new actions to be dispatched.  We also cannot leave the context in
   // the INIT state after failing to open.
   if (NS_FAILED(aRv)) {
+    printf_stderr("QuotaInit failed - STATE_CONTEXT_CANCELED\n");
     mState = STATE_CONTEXT_CANCELED;
   }
 
   if (mState == STATE_CONTEXT_CANCELED) {
     for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
@@ -1087,16 +1118,17 @@ StorageContext::SetNextContext(StorageCo
   MOZ_ASSERT(aNextContext);
   MOZ_ASSERT(!mNextContext);
   mNextContext = aNextContext;
 }
 
 void
 StorageContext::DoomTargetData()
 {
+  printf_stderr("DoomTargetData\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mData);
 
   // We are about to drop our reference to the Data. We need to ensure that
   // the ~StorageContext() destructor does not run until contents of Data have
   // been released on the Target thread.
 
   // Dispatch a no-op StorageAction. This will hold the StorageContext alive
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -27,16 +27,17 @@ public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("SetupAction::RunSyncOnTarget\n");
     // Executes in its own transaction.
     nsresult rv = db::CreateOrMigrateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 };
 } // anonymous namespace
@@ -294,16 +295,17 @@ protected:
   {}
 
   virtual void
   Complete(ErrorResult&& aRv) = 0;
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
+    printf_stderr("StorageManager::BaseAction::CompleteOnInitiatingThread\n");
     NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
 
     Complete(ErrorResult(aRv));
 
     // Ensure we release the manager on the initiating thread.
     mManager = nullptr;
   }
 
@@ -313,53 +315,61 @@ protected:
 
 // ---------------------------------------------------------------------------
 
 class StorageManager::RegisterAction final : public StorageManager::BaseAction
 {
 public:
   RegisterAction(const nsID& aRequestId, StorageManager* aManager)
     : BaseAction(aRequestId, aManager)
-  {}
+  {
+    printf_stderr("RegisterAction::RegisterAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("RegisterAction::RunSyncOnTarget\n");
     // XXX
     return NS_OK;
   }
 
   virtual void
   Complete(ErrorResult&& aRv) override
   {
+    printf_stderr("RegisterAction::Complete\n");
     mManager->OnRequestComplete(mRequestId);
   }
 };
 
 // ---------------------------------------------------------------------------
 
 class StorageManager::GetTagsAction final : public StorageManager::BaseAction
 {
 public:
   GetTagsAction(const nsID& aRequestId, StorageManager* aManager)
     : BaseAction(aRequestId, aManager)
-  {}
+  {
+    printf_stderr("GetTagsAction::GetTagsAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("GetTagsAction::RunSyncOnTarget\n");
     // XXX
     return NS_OK;
   }
 
   virtual void
   Complete(ErrorResult&& aRv) override
   {
+    printf_stderr("GetTagsAction::Complete\n");
     mManager->OnRequestComplete(mRequestId);
   }
 };
 
 // ---------------------------------------------------------------------------
 
 // static
 nsresult
@@ -383,16 +393,17 @@ StorageManager::StorageManager(Backgroun
 {
   MOZ_ASSERT(mService);
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
 }
 
 StorageManager::~StorageManager()
 {
+  printf_stderr("StorageManager DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mState == Closing);
   MOZ_ASSERT(!mContext);
 
   mService = nullptr;
 
 /*  nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
@@ -401,16 +412,17 @@ StorageManager::~StorageManager()
   // shutdown. Defer this to the main thread, instead.
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
 }
 
 void
 StorageManager::Init(StorageManager* aOldManager)
 {
+  printf_stderr("StorageManager::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   RefPtr<StorageContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
   // Create the context immediately. Since there can at most be one
@@ -420,32 +432,34 @@ StorageManager::Init(StorageManager* aOl
   RefPtr<StorageContext> ref = StorageContext::Create(this, mIOThread,
                                                       setupAction, oldContext);
   mContext = ref;
 }
 
 void
 StorageManager::Abort()
 {
+  printf_stderr("StorageManager::Abort\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
   // creating a new StorageContext. We must ensure all Contexts and IO
   // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
   RefPtr<StorageContext> context = mContext;
   context->CancelAll();
 }
 
 void
 StorageManager::Shutdown()
 {
+  printf_stderr("StorageManager::Shutdown\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // Ignore duplicate attempts to shutdown. This can occur when we start a
   // browser initiated shutdown and then run ~StorageManager() which also
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
@@ -463,25 +477,28 @@ StorageManager::Shutdown()
     RefPtr<StorageContext> context = mContext;
     context->CancelAll();
   }
 }
 
 void
 StorageManager::NoteClosing()
 {
+  printf_stderr("StorageManager::NoteClosing\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
 void
 StorageManager::RemoveStorageContext(StorageContext* aContext)
 {
+  printf_stderr("StorageManager::RemoveStorageContext\n");
+
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
   // Wether the StorageContext destruction was triggered from the StorageManager
   // going idle or the underlying storage being invalidated, we should know we
   // are closing before the StorageContext is destroyed.
   MOZ_ASSERT(mState == Closing);
@@ -492,32 +509,34 @@ StorageManager::RemoveStorageContext(Sto
   // Factory list. We don't need to block shutdown by stayin in the list
   // any more.
   Factory::Remove(this);
 }
 
 void
 StorageManager::MaybeAllowContextToClose()
 {
+  printf_stderr("StorageManager::MaybeAllowContextToClose\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   // If we have an active context, but we have no more pending requests,
   // then let it shut itself down. We must wait for all possible users
   // of state information to complete before doing this.
   RefPtr<StorageContext> context = mContext;
   if (context && mPendingRequests.IsEmpty()) {
     // Mark the StorageManager as invalid so that it won't get used again.
     NoteClosing();
 
     context->AllowToClose();
   }
 }
 
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
 {
+  printf_stderr("StorageManager::ExecuteRequest\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
     OnRequestComplete(aRequestId);
     return;
@@ -526,16 +545,17 @@ StorageManager::ExecuteRequest(const nsI
   RefPtr<StorageContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StorageAction> action;
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
+      printf_stderr("Is REGISTER Action\n");
       action = new RegisterAction(aRequestId, this);
       break;
     }
     case SyncOpArgs::TSyncGetTagsArgs:
     {
       action = new GetTagsAction(aRequestId, this);
       break;
     }
@@ -546,16 +566,17 @@ StorageManager::ExecuteRequest(const nsI
   }
 
   context->Dispatch(action);
 }
 
 void
 StorageManager::OnRequestComplete(const nsID& aRequestId)
 {
+  printf_stderr("StorageManager::OnRequestComplete\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mPendingRequests.Contains(aRequestId));
 
   mPendingRequests.RemoveElement(aRequestId);
 
   // XXX Notify listener
 
   MaybeAllowContextToClose();
