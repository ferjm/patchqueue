# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  1f9dfab0f578abf2be581531e5c91ca78f3bd692

diff --git a/dom/backgroundsync/BackgroundSyncService.cpp b/dom/backgroundsync/BackgroundSyncService.cpp
--- a/dom/backgroundsync/BackgroundSyncService.cpp
+++ b/dom/backgroundsync/BackgroundSyncService.cpp
@@ -73,16 +73,17 @@ public:
     MOZ_ASSERT(NS_IsMainThread());
 
     nsIScriptSecurityManager *securityManager =
       nsContentUtils::GetSecurityManager();
 
     MOZ_ASSERT(securityManager);
 
     for (uint32_t i = 0; i < mOrigins.Length(); i++) {
+      printf_stderr("ORIGIN %s\n", NS_ConvertUTF16toUTF8(mOrigins[i]).get());
       // To do that, we first need to get the StorageManager responsible for
       // each origin.
       nsCOMPtr<nsIPrincipal> principal;
       securityManager->CreateCodebasePrincipalFromOrigin(
         NS_ConvertUTF16toUTF8(mOrigins[i]), getter_AddRefs(principal));
 
       MOZ_ASSERT(principal);
 
@@ -218,25 +219,27 @@ BackgroundSyncService::ReleaseChromeStor
   mChromeStorageManagers.RemoveAndForget(aRequestId, doomed);
 }
 
 // ----------------------------------------------------------------------------
 
 BackgroundSyncService::BackgroundSyncService()
   : mOnlineState(OnlineStateObserver::UNKNOWN)
 {
+  printf_stderr("BackgroundSyncService CONSTRUCTOR\n");
   AssertIsOnBackgroundThread();
 
   // sInstance is a raw BackgroundSyncService*.
   MOZ_ASSERT(!sInstance);
   sInstance = this;
 }
 
 BackgroundSyncService::~BackgroundSyncService()
 {
+  printf_stderr("BackgroundSyncService DESTRUCTOR\n");
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(sInstance == this);
   MOZ_ASSERT(mBackgroundSyncActors.Count() == 0);
   MOZ_ASSERT(mStorageManagers.Count() == 0);
   MOZ_ASSERT(mChromeStorageManagers.Count() == 0);
 
   mOnlineStateObserver->Shutdown(this);
 
@@ -348,16 +351,17 @@ BackgroundSyncService::Response(const ui
     parent->NotifyResponse(aRequestId, aResponse);
   }
 }
 
 void
 BackgroundSyncService::OnRequestComplete(const nsID& aRequestId,
                                          const SyncOpResponse& aResponse)
 {
+  printf_stderr("OnRequestComplete\n");
   AssertIsOnBackgroundThread();
 
   switch (aResponse.type()) {
     case SyncOpResponse::TSyncRegisterResponse:
       // If this is the first registration for this origin, we need to store
       // it in the 'origins' db before we can progress the response to the
       // DOM side.
       if (aResponse.get_SyncRegisterResponse().mFirstRegistration()) {
@@ -384,70 +388,77 @@ BackgroundSyncService::OnRequestComplete
         }
       }
       break;
     default:
       break;
   }
 
   uint64_t actorId = ReleaseStorageManagerRef(aRequestId);
+  printf_stderr("Releasing StorageManagerRef %llu\n", actorId);
   // If we have an actor ID, this is a DOM request which response needs to be
   // reported back to the content process through the IPC actor.
   if (actorId != 0) {
     return Response(actorId, aRequestId, aResponse);
   }
 
   // Otherwise, this is a response to an internal request that can be handled
   // here.
 
   ReleaseChromeStorageManagerRef(aRequestId);
 
   switch (aResponse.type()) {
     case SyncOpResponse::TSyncGetAllOriginsResponse:
       {
+        printf_stderr("GetAllOriginsResponse\n");
         // If we went offline while getting the origins, we don't care about
         // getting the sync registrations anymore, so we bail out here.
         if (mOnlineState !=  OnlineStateObserver::ONLINE) {
           return;
         }
 
         // If we are still online, we need to get the list of sync registrations
         // per origin.
         nsTArray<nsString> origins(
           aResponse.get_SyncGetAllOriginsResponse().mOrigins());
+        printf_stderr("Origins number %zu\n", origins.Length());
         RefPtr<GetStorageManagerRunnable> runnable =
           new GetStorageManagerRunnable(this, origins,
               SyncInternalOp(SyncGetAllArgs()));
         MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable));
       }
       break;
     case SyncOpResponse::TSyncGetAllResponse:
       {
+        printf_stderr("GetAllResponse\n");
         // If we went offline while getting the sync registrations, it is
         // useless to continue, as no sync event will be triggered for these
         // registrations. So we just bail out here.
         if (mOnlineState !=  OnlineStateObserver::ONLINE) {
           return;
         }
 
         // If we are still online, we try to trigger a sync event per each
         // registration.
         nsTArray<Registration> registrations(
             aResponse.get_SyncGetAllResponse().mRegistrations());
+        printf_stderr("Registrations number %zu\n", registrations.Length());
         for (uint32_t i = 0; i < registrations.Length(); i++) {
           MaybeTriggerSyncEvent(registrations[i]);
         }
       }
       break;
     case SyncOpResponse::TSyncChangeStateResponse:
       {
+        printf_stderr("ChangeStateResponse\n");
         // For now we only care about a change of state to FIRING.
         Registration registration =
           aResponse.get_SyncChangeStateResponse().mRegistration();
         if (registration.mState() != RegistrationState::FIRING) {
+          printf_stderr("Registration not FIRING but %d\n", registration.mState());
           return;
         }
 
         // If we changed the state to FIRING, that means that we are trying to
         // trigger a sync event for a specific registration.
         // In that case, we need to check if we still are online and so we can
         // continue with the process of firing the sync event. Otherwise, we
         // need to get back to the PENDING state and bail out here.
@@ -479,16 +490,17 @@ BackgroundSyncService::MaybeTriggerSyncE
     return;
   }
 
   // First thing we need to do is to change the state of the registration to
   // FIRING.
 
   // We only can do that if the registration is in PENDING state though.
   if (NS_WARN_IF(aRegistration.mState() != RegistrationState::PENDING)) {
+    printf_stderr("Registration should be %d is %d\n", RegistrationState::PENDING, aRegistration.mState());
     return;
   }
 
   // We need to get the appropriate StorageManager for the registration origin,
   // so we need to jump to the main thread for that.
   RefPtr<GetStorageManagerRunnable> runnable =
     new GetStorageManagerRunnable(this, aRegistration.mOrigin(), SyncInternalOp(
       SyncChangeStateArgs(aRegistration.mId(),RegistrationState::FIRING)
@@ -577,16 +589,17 @@ BackgroundSyncService::OnOnlineStateChan
 /**
  * StorageManagerIdFactory::Listener implementation.
  */
 void
 BackgroundSyncService::OnStorageManagerIdCreated(
   StorageManagerId* aManagerId, StorageManagerIdFactory* aFactory,
   const SyncInternalOp& aOp)
 {
+  printf_stderr("BackgroundSyncService::OnStorageManagerIdCreated\n");
   MOZ_ASSERT(mStorageManagerIdFactories.Contains(aFactory));
 
   aFactory->RemoveListener(this);
   mStorageManagerIdFactories.RemoveEntry(aFactory);
 
   RefPtr<StorageManager> manager;
   nsresult rv = StorageManager::GetOrCreate(this,
                                             aManagerId,
@@ -604,16 +617,17 @@ BackgroundSyncService::OnStorageManagerI
   nsID id;
   rv = uuidGenerator->GenerateUUIDInPlace(&id);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
   AddStorageManagerRef(id, 0 /* internal request */, manager);
 
+  printf_stderr("Execute SyncInternalOp()\n");
   manager->ExecuteRequest(id, aOp);
 }
 
 void
 BackgroundSyncService::AddStorageManagerIdFactory(
     StorageManagerIdFactory* aFactory)
 {
   mStorageManagerIdFactories.PutEntry(aFactory);
diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
--- a/dom/backgroundsync/ChromeStorageManager.cpp
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -186,18 +186,20 @@ public:
     MOZ_ASSERT(mInitiatingThread);
     MOZ_ASSERT(aConn);
     MOZ_ASSERT(aAction);
   }
 
   NS_IMETHODIMP
   Run() override
   {
+    printf_stderr("StorageActionRunnable::Run\n");
     nsresult rv = NS_OK;
     if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      printf_stderr("Calling mManager->OnRequestComplete\n");
       mManager->OnRequestComplete(mAction->RequestId(), mResponse);
       return rv;
     }
 
     switch (mAction->Type()) {
       case ChromeStorageAction::Type::Register:
         rv = chromedb::Register(mConn, mAction->Origin());
         if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -253,24 +255,26 @@ private:
 NS_IMPL_ISUPPORTS(StorageActionRunnable, nsICancelableRunnable, nsIRunnable)
 
 //-----------------------------------------------------------------------------
 // PBackground thread
 
 ChromeStorageManager::ChromeStorageManager(BackgroundSyncService* aService)
   : mService(aService)
 {
+  printf_stderr("ChromeStorageManager CONSTRUCTOR\n");
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aService);
 
   Init();
 }
 
 ChromeStorageManager::~ChromeStorageManager()
 {
+  printf_stderr("ChromeStorageManager DESTRUCTOR\n");
   AssertIsOnBackgroundThread();
 
   if (mDBConn) {
     RefPtr<ShutdownRunnable> runnable = new ShutdownRunnable(mDBConn);
     mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
     mDBConn = nullptr;
   }
 
diff --git a/dom/backgroundsync/DBSchema.cpp b/dom/backgroundsync/DBSchema.cpp
--- a/dom/backgroundsync/DBSchema.cpp
+++ b/dom/backgroundsync/DBSchema.cpp
@@ -223,16 +223,17 @@ GetAll(mozIStorageConnection* aConn,
 
     int32_t lastChance;
     rv = state->GetInt32(6, &lastChance);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     Registration registration(id, origin, originSuffix,
       scope, tag, RegistrationState(registrationState),
       bool(lastChance));
+    printf_stderr("Registration found for %s\n", NS_ConvertUTF16toUTF8(origin).get());
     aRegistrations.AppendElement(registration);
   }
 
   return rv;
 }
 
 nsresult
 Remove(mozIStorageConnection* aConn,
diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
--- a/dom/backgroundsync/StorageContext.cpp
+++ b/dom/backgroundsync/StorageContext.cpp
@@ -28,16 +28,17 @@ class NullAction final : public StorageA
 public:
   NullAction()
   {
   }
 
   virtual void
   RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
   {
+    printf_stderr("NullAction::RunOnTarget\n");
     // Resolve success immediately. This Action does no actual work.
     MOZ_ASSERT(aResolver);
     aResolver->Resolve(NS_OK);
   }
 };
 
 } // namespace
 
@@ -114,40 +115,43 @@ public:
     , mData(aData)
     , mTarget(aTarget)
     , mInitAction(aInitAction)
     , mInitiatingThread(NS_GetCurrentThread())
     , mResult(NS_OK)
     , mState(STATE_INIT)
     , mCanceled(false)
   {
+    printf_stderr("QuotaInitRunnable\n");
     MOZ_ASSERT(mContext);
     MOZ_ASSERT(mManager);
     MOZ_ASSERT(mData);
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mInitiatingThread);
     MOZ_ASSERT(mInitAction);
   }
 
   nsresult Dispatch()
   {
+    printf_stderr("QuotaInitRunnable::Dispatch\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mState == STATE_INIT);
 
     mState = STATE_GET_INFO;
     nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) {
       mState = STATE_COMPLETE;
       Clear();
     }
     return rv;
   }
 
   void Cancel()
   {
+    printf_stderr("QuotaInitRunnable::Cancel\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(!mCanceled);
     mCanceled = true;
     mInitAction->CancelOnInitiatingThread();
   }
 
   void OpenDirectory();
 
@@ -165,16 +169,17 @@ private:
     SyncResolver()
       : mResolved(false)
       , mResult(NS_OK)
     { }
 
     virtual void
     Resolve(nsresult aRv) override
     {
+      printf_stderr("SyncResolver::Resolve %d\n", aRv);
       MOZ_ASSERT(!mResolved);
       mResolved = true;
       mResult = aRv;
     };
 
     bool Resolved() const { return mResolved; }
     nsresult Result() const { return mResult; }
 
@@ -185,16 +190,17 @@ private:
     nsresult mResult;
 
     NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
                                override)
   };
 
   ~QuotaInitRunnable()
   {
+    printf_stderr("QuotaInitRunnable::~QuotaInitRunnable\n");
     MOZ_ASSERT(mState == STATE_COMPLETE);
     MOZ_ASSERT(!mContext);
     MOZ_ASSERT(!mInitAction);
   }
 
   enum State
   {
     STATE_INIT,
@@ -206,28 +212,30 @@ private:
     STATE_RUN_ON_TARGET,
     STATE_RUNNING,
     STATE_COMPLETING,
     STATE_COMPLETE
   };
 
   void Complete(nsresult aResult)
   {
+    printf_stderr("QuotaInitRunnable::Complete\n");
     MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
 
     MOZ_ASSERT(NS_SUCCEEDED(mResult));
     mResult = aResult;
 
     mState = STATE_COMPLETING;
     MOZ_ALWAYS_SUCCEEDS(
       mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
   }
 
   void Clear()
   {
+    printf_stderr("QuotaInitRunnable::Clear\n");
     NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
     MOZ_ASSERT(mContext);
     mContext = nullptr;
     mManager = nullptr;
     mInitAction = nullptr;
   }
 
   RefPtr<StorageContext> mContext;
@@ -364,16 +372,17 @@ StorageContext::QuotaInitRunnable::Run()
   // state cases for thread assertions.
 
   RefPtr<SyncResolver> resolver = new SyncResolver();
 
   switch(mState) {
     // -----------------------------------
     case STATE_GET_INFO:
     {
+    printf_stderr("QuotaInitRunnable::Run() GET_INFO \n");
       MOZ_ASSERT(NS_IsMainThread());
 
       if (mCanceled) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
@@ -390,16 +399,17 @@ StorageContext::QuotaInitRunnable::Run()
       mState = STATE_CREATE_QUOTA_MANAGER;
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // ----------------------------------
     case STATE_CREATE_QUOTA_MANAGER:
     {
+      printf_stderr("QuotaInitRunnable::Run() CREATE_QUOTE_MANAGER\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (mCanceled || QuotaManager::IsShuttingDown()) {
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       if (QuotaManager::Get()) {
@@ -409,73 +419,79 @@ StorageContext::QuotaInitRunnable::Run()
 
       mState = STATE_OPEN_DIRECTORY;
       QuotaManager::GetOrCreate(this);
       break;
     }
     // ----------------------------------
     case STATE_OPEN_DIRECTORY:
     {
+    printf_stderr("QuotaInitRunnable::Run() OPEN_DIRECTORY\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
 
       if (NS_WARN_IF(!QuotaManager::Get())) {
         resolver->Resolve(NS_ERROR_FAILURE);
         break;
       }
 
       OpenDirectory();
       break;
     }
     // ----------------------------------
     case STATE_ENSURE_ORIGIN_INITIALIZED:
     {
+      printf_stderr("QuotaInitRunnable::Run() ORIGIN_INITIALIZED\n");
       AssertIsOnIOThread();
 
       if (mCanceled) {
+        printf_stderr("mCanceled\n");
         resolver->Resolve(NS_ERROR_ABORT);
         break;
       }
 
       QuotaManager* qm = QuotaManager::Get();
       MOZ_ASSERT(qm);
       nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
                                                   mQuotaInfo.mGroup,
                                                   mQuotaInfo.mOrigin,
                                                   mQuotaInfo.mIsApp,
                                                   getter_AddRefs(mQuotaInfo.mDir));
       if (NS_FAILED(rv)) {
+        printf_stderr("EnsureOriginInitialized failed %d\n", rv);
         resolver->Resolve(rv);
         break;
       }
 
       mState = STATE_RUN_ON_TARGET;
 
       MOZ_ALWAYS_SUCCEEDS(
         mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("QuotaInitRunnable::Run() RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
 
       mState = STATE_RUNNING;
 
       // Execute the provided initialization StorageAction. The
       // StorageAction must Resolve() before returning.
       mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
       MOZ_ASSERT(resolver->Resolved());
 
       mData = nullptr;
 
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("QuotaInitRunnable::Run() COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
       mInitAction->CompleteOnInitiatingThread(mResult);
       mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
       mState = STATE_COMPLETE;
 
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
@@ -511,16 +527,17 @@ public:
     , mTarget(aTarget)
     , mAction(aAction)
     , mQuotaInfo(aQuotaInfo)
     , mInitiatingThread(NS_GetCurrentThread())
     , mState(STATE_INIT)
     , mResult(NS_OK)
     , mExecutingRunOnTarget(false)
   {
+    printf_stderr("ActionRunnable ---- \n");
     MOZ_ASSERT(mContext);
     // mData may be nullptr
     MOZ_ASSERT(mTarget);
     MOZ_ASSERT(mAction);
     // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
     MOZ_ASSERT(mInitiatingThread);
   }
 
@@ -542,16 +559,17 @@ public:
   Cancel() override
   {
     NS_ASSERT_OWNINGTHREAD(ActionRunnable);
     mAction->CancelOnInitiatingThread();
   }
 
   virtual void Resolve(nsresult aRv) override
   {
+    printf_stderr("ActionRunnable::Resolve\n");
     MOZ_ASSERT(mTarget == NS_GetCurrentThread());
     MOZ_ASSERT(mState == STATE_RUNNING);
 
     mResult = aRv;
 
     // We ultimately must complete on the initiating thread, but bounce through
     // the current thread again to ensure that we don't destroy objects and
     // state out from under the currently running action's stack.
@@ -653,16 +671,17 @@ NS_IMPL_ISUPPORTS(StorageContext::Action
 // does not see any execution there. Its all handled internal to the StorageAction.
 NS_IMETHODIMP
 StorageContext::ActionRunnable::Run()
 {
   switch(mState) {
     // ----------------------
     case STATE_RUN_ON_TARGET:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RUN_ON_TARGET\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       MOZ_ASSERT(!mExecutingRunOnTarget);
 
       // Note that we are calling RunOnTarget().  This lets us detect
       // if Resolve() is called synchronously.
       AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
       mExecutingRunOnTarget = true;
 
@@ -680,30 +699,32 @@ StorageContext::ActionRunnable::Run()
         Run();
       }
 
       break;
     }
     // -----------------
     case STATE_RESOLVING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_RESOLVING\n");
       MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
       // The call to StorageAction::RunOnTarget() must have returned now if we
       // are running on the target thread again.  We may now proceed
       // with completion.
       mState = STATE_COMPLETING;
       // Shutdown must be delayed until all Contexts are destroyed.  Crash
       // for this invariant violation.
       MOZ_ALWAYS_SUCCEEDS(
         mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
       break;
     }
     // -------------------
     case STATE_COMPLETING:
     {
+      printf_stderr("ActionRunnable::Run() STATE_COMPLETING\n");
       NS_ASSERT_OWNINGTHREAD(ActionRunnable);
       mAction->CompleteOnInitiatingThread(mResult);
       mState = STATE_COMPLETE;
       // Explicitly cleanup here as the destructor could fire on any of
       // the threads we have bounced through.
       Clear();
       break;
     }
@@ -715,16 +736,17 @@ StorageContext::ActionRunnable::Run()
     }
   }
   return NS_OK;
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToClose()
 {
+  printf_stderr("ThreadSafeHandle::AllowToClose()\n");
   if (mOwningThread == NS_GetCurrentThread()) {
     AllowToCloseOnOwningThread();
     return;
   }
 
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all StorageContexts have been destroyed.
   nsCOMPtr<nsIRunnable> runnable =
@@ -769,16 +791,17 @@ StorageContext::ThreadsafeHandle::~Threa
   // Dispatch is guaranteed to succeed here because we block shutdown until
   // all Contexts have been destroyed.
   NS_ProxyRelease(mOwningThread, mStrongRef.forget());
 }
 
 void
 StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
 {
+  printf_stderr("ThreadsafeHandle::AllowToCloseOnOwningThread()\n");
   MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
 
   // A StorageContext "closes" when its ref count drops to zero. Dropping this
   // strong ref is necessary, but not sufficient for the close to occur.
   // Any outstanding IO will continue and keep the StorageContext alive. Once
   // the StorageContext is idle, it will be destroyed.
 
   // First, tell the context to flush any target thread shared data. This
@@ -820,16 +843,17 @@ StorageContext::ThreadsafeHandle::Storag
   mWeakRef = nullptr;
 }
 
 // static
 already_AddRefed<StorageContext>
 StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
                        StorageAction* aInitAction, StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Create\n");
   RefPtr<StorageContext> context =
     new StorageContext(aManager, aTarget, aInitAction);
   context->Init(aOldContext);
   return context.forget();
 }
 
 StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
                                StorageAction* aInitAction)
@@ -916,48 +940,52 @@ StorageContext::AllowToClose()
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   if (mThreadsafeHandle) {
     mThreadsafeHandle->AllowToClose();
   }
 }
 
 StorageContext::~StorageContext()
 {
+  printf_stderr("StorageContext DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mManager);
   MOZ_ASSERT(!mData);
 
   if (mThreadsafeHandle) {
     mThreadsafeHandle->StorageContextDestroyed(this);
   }
 
   // Note, this may set the mOrphanedData flag.
+  printf_stderr("Calling RemoveStorageContext\n");
   mManager->RemoveStorageContext(this);
 
   if (mNextContext) {
     mNextContext->Start();
   }
 }
 
 void
 StorageContext::Init(StorageContext* aOldContext)
 {
+  printf_stderr("StorageContext::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   if (aOldContext) {
     aOldContext->SetNextContext(this);
     return;
   }
 
   Start();
 }
 
 void
 StorageContext::Start()
 {
+  printf_stderr("StorageContext::Start\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   // Previous context closing delayed our start, but then we were canceled.
   // In this case, just do nothing here.
   if (mState == STATE_CONTEXT_CANCELED) {
     MOZ_ASSERT(!mInitRunnable);
     MOZ_ASSERT(!mInitAction);
     return;
@@ -979,16 +1007,17 @@ StorageContext::Start()
     // Crash for this invariant violation.
     MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
   }
 }
 
 void
 StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
 {
+  printf_stderr("StorageContext::DispatchAction\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   RefPtr<ActionRunnable> runnable =
     new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
 
   if (aDoomData) {
     mData = nullptr;
   }
@@ -1001,16 +1030,17 @@ StorageContext::DispatchAction(StorageAc
   }
   AddActivity(runnable);
 }
 
 void
 StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
                             already_AddRefed<quota::DirectoryLock> aDirectoryLock)
 {
+  printf_stderr("StorageContext::OnQuotaInit\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
 
   MOZ_ASSERT(mInitRunnable);
   mInitRunnable = nullptr;
 
   mQuotaInfo = aQuotaInfo;
 
   // Always save the directory lock to ensure QuotaManager does not shutdown
@@ -1018,16 +1048,17 @@ StorageContext::OnQuotaInit(nsresult aRv
   MOZ_ASSERT(!mDirectoryLock);
   mDirectoryLock = aDirectoryLock;
 
   // If we opening the context failed, but we were not explicitly canceled,
   // still treat the entire context as canceled.  We don't want to allow
   // new actions to be dispatched.  We also cannot leave the context in
   // the INIT state after failing to open.
   if (NS_FAILED(aRv)) {
+    printf_stderr("QuotaInit failed - STATE_CONTEXT_CANCELED\n");
     mState = STATE_CONTEXT_CANCELED;
   }
 
   if (mState == STATE_CONTEXT_CANCELED) {
     for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
       mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
     }
     mPendingActions.Clear();
@@ -1089,16 +1120,17 @@ StorageContext::SetNextContext(StorageCo
   MOZ_ASSERT(aNextContext);
   MOZ_ASSERT(!mNextContext);
   mNextContext = aNextContext;
 }
 
 void
 StorageContext::DoomTargetData()
 {
+  printf_stderr("DoomTargetData\n");
   NS_ASSERT_OWNINGTHREAD(StorageContext);
   MOZ_ASSERT(mData);
 
   // We are about to drop our reference to the Data. We need to ensure that
   // the ~StorageContext() destructor does not run until contents of Data have
   // been released on the Target thread.
 
   // Dispatch a no-op StorageAction. This will hold the StorageContext alive
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -28,16 +28,17 @@ public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("SetupAction::RunSyncOnTarget\n");
     // Executes in its own transaction.
     nsresult rv = db::CreateOrMigrateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 };
 
@@ -295,16 +296,17 @@ protected:
   {}
 
   virtual void
   Complete(nsresult aRv) = 0;
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
+    printf_stderr("StorageManager::BaseAction::CompleteOnInitiatingThread\n");
     NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
 
     Complete(aRv);
 
     // Ensure we release the manager on the initiating thread.
     mManager = nullptr;
   }
 
@@ -318,30 +320,34 @@ class StorageManager::RegisterAction fin
 {
 public:
   RegisterAction(const nsID& aRequestId,
                  StorageManager* aManager,
                  const SyncRegisterArgs& aRegisterArgs)
     : BaseAction(aRequestId, aManager)
     , mArgs(aRegisterArgs)
     , mFirstRegistration(true)
-  {}
+  {
+    printf_stderr("RegisterAction::RegisterAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("RegisterAction::RunSyncOnTarget\n");
     nsresult rv = db::Register(aConn, mArgs, mFirstRegistration);
     NS_WARN_IF(NS_FAILED(rv));
     return rv;
   }
 
   virtual void
   Complete(nsresult aRv) override
   {
+    printf_stderr("RegisterAction::Complete\n");
     if (NS_FAILED(aRv)) {
       mManager->OnRequestComplete(mRequestId,
         SyncOpError(static_cast<uint32_t>(aRv)));
     } else {
       mManager->OnRequestComplete(mRequestId,
           SyncRegisterResponse(mArgs.mOrigin(), mFirstRegistration));
     }
   }
@@ -356,30 +362,34 @@ private:
 class StorageManager::GetTagsAction final : public StorageManager::BaseAction
 {
 public:
   GetTagsAction(const nsID& aRequestId,
                 StorageManager* aManager,
                 const SyncGetTagsArgs& aGetTagsArgs)
     : BaseAction(aRequestId, aManager)
     , mArgs(aGetTagsArgs)
-  {}
+  {
+    printf_stderr("GetTagsAction::GetTagsAction\n");
+  }
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
+    printf_stderr("GetTagsAction::RunSyncOnTarget\n");
     nsresult rv = db::GetTags(aConn, mArgs, mTags);
     NS_WARN_IF(NS_FAILED(rv));
     return rv;
   }
 
   virtual void
   Complete(nsresult aRv) override
   {
+    printf_stderr("GetTagsAction::Complete\n");
     if (NS_FAILED(aRv)) {
       mManager->OnRequestComplete(mRequestId,
         SyncOpError(static_cast<uint32_t>(aRv)));
     } else {
       mManager->OnRequestComplete(mRequestId,
         SyncGetTagsResponse(mTags));
     }
   }
@@ -542,16 +552,17 @@ StorageManager::StorageManager(Backgroun
 {
   MOZ_ASSERT(mService);
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
 }
 
 StorageManager::~StorageManager()
 {
+  printf_stderr("StorageManager DESTRUCTOR\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mState == Closing);
   MOZ_ASSERT(!mContext);
 
   mService = nullptr;
 
 /*  nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
@@ -560,16 +571,17 @@ StorageManager::~StorageManager()
   // shutdown. Defer this to the main thread, instead.
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
 }
 
 void
 StorageManager::Init(StorageManager* aOldManager)
 {
+  printf_stderr("StorageManager::Init\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   RefPtr<StorageContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
   // Create the context immediately. Since there can at most be one
@@ -579,32 +591,34 @@ StorageManager::Init(StorageManager* aOl
   RefPtr<StorageContext> ref = StorageContext::Create(this, mIOThread,
                                                       setupAction, oldContext);
   mContext = ref;
 }
 
 void
 StorageManager::Abort()
 {
+  printf_stderr("StorageManager::Abort\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
   // creating a new StorageContext. We must ensure all Contexts and IO
   // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
   RefPtr<StorageContext> context = mContext;
   context->CancelAll();
 }
 
 void
 StorageManager::Shutdown()
 {
+  printf_stderr("StorageManager::Shutdown\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // Ignore duplicate attempts to shutdown. This can occur when we start a
   // browser initiated shutdown and then run ~StorageManager() which also
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
@@ -622,25 +636,28 @@ StorageManager::Shutdown()
     RefPtr<StorageContext> context = mContext;
     context->CancelAll();
   }
 }
 
 void
 StorageManager::NoteClosing()
 {
+  printf_stderr("StorageManager::NoteClosing\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
 void
 StorageManager::RemoveStorageContext(StorageContext* aContext)
 {
+  printf_stderr("StorageManager::RemoveStorageContext\n");
+
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
   // Wether the StorageContext destruction was triggered from the StorageManager
   // going idle or the underlying storage being invalidated, we should know we
   // are closing before the StorageContext is destroyed.
   MOZ_ASSERT(mState == Closing);
@@ -651,16 +668,17 @@ StorageManager::RemoveStorageContext(Sto
   // Factory list. We don't need to block shutdown by stayin in the list
   // any more.
   Factory::Remove(this);
 }
 
 void
 StorageManager::MaybeAllowContextToClose()
 {
+  printf_stderr("StorageManager::MaybeAllowContextToClose\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   // If we have an active context, but we have no more pending requests,
   // then let it shut itself down. We must wait for all possible users
   // of state information to complete before doing this.
   RefPtr<StorageContext> context = mContext;
   if (context && mPendingRequests.IsEmpty()) {
     // Mark the StorageManager as invalid so that it won't get used again.
     NoteClosing();
@@ -668,16 +686,17 @@ StorageManager::MaybeAllowContextToClose
     context->AllowToClose();
   }
 }
 
 // Common to DOM and internal requests.
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, StorageAction* aAction)
 {
+  printf_stderr("StorageManager::ExecuteRequest\n");
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(aAction);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
     OnRequestComplete(aRequestId,
@@ -763,15 +782,16 @@ StorageManager::OnRequestComplete(const 
 
   MaybeAllowContextToClose();
 }
 
 void
 StorageManager::OnRequestComplete(const nsID& aRequestId,
                                   const SyncOpResponse& aResponse)
 {
+  printf_stderr("StorageManager::OnRequestComplete\n");
   mService->OnRequestComplete(aRequestId, SyncOpResponse(aResponse));
   OnRequestComplete(aRequestId);
 }
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
