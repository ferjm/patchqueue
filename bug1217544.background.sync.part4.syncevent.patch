# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  97100d73c2704030811d9ee6f4858de2d0d547f5
Bug 1217544 - Implement one-off BackgroundSync API. Part 4: Sync event. r=baku

diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -1264,16 +1264,22 @@ DOMInterfaces = {
 'SVGUnitTypes' : {
     'concrete': False,
 },
 
 'SVGZoomAndPan' : {
     'concrete': False,
 },
 
+'SyncEvent': {
+    'headerFile': 'mozilla/dom/ServiceWorkerEvents.h',
+    'nativeType': 'mozilla::dom::workers::SyncEvent',
+    'workers': True
+},
+
 'Text': {
     # Total hack to allow binding code to realize that nsTextNode can
     # in fact be cast to Text.
     'headerFile': 'nsTextNode.h',
 },
 
 'TextDecoder': {
     'wrapperCache': False
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -72,17 +72,17 @@ interface nsIServiceWorkerRegistrationIn
 [scriptable, uuid(9e523e7c-ad6f-4df0-8077-c74aebbc679d)]
 interface nsIServiceWorkerManagerListener : nsISupports
 {
   void onRegister(in nsIServiceWorkerRegistrationInfo aInfo);
 
   void onUnregister(in nsIServiceWorkerRegistrationInfo aInfo);
 };
 
-[scriptable, builtinclass, uuid(7404c8e8-4d47-4449-8ed1-47d1261d4e33)]
+[scriptable, builtinclass, uuid(0577039d-c34e-4f01-afb4-a423ae650e54)]
 interface nsIServiceWorkerManager : nsISupports
 {
   /**
    * Registers a ServiceWorker with script loaded from `aScriptURI` to act as
    * the ServiceWorker for aScope.  Requires a valid entry settings object on
    * the stack. This means you must call this from content code 'within'
    * a window.
    *
@@ -186,19 +186,24 @@ interface nsIServiceWorkerManager : nsIS
                                   in AString aData,
                                   in AString aBehavior);
   [optional_argc] void sendPushEvent(in ACString aOriginAttributes,
                                      in ACString aScope,
                                      [optional] in uint32_t aDataLength,
                                      [optional, array, size_is(aDataLength)] in uint8_t aDataBytes);
   void sendPushSubscriptionChangeEvent(in ACString aOriginAttributes,
                                        in ACString scope);
-
   void addListener(in nsIServiceWorkerManagerListener aListener);
 
   void removeListener(in nsIServiceWorkerManagerListener aListener);
 
   bool shouldReportToWindow(in mozIDOMWindowProxy aWindow, in ACString aScope);
+
+/*  void sendSyncEvent(in ACString aOriginAttributes,
+                     in ACString scope,
+                     in ACString aTag,
+                     in boolean aLastChance);*/
+  void sendSyncEvent();
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/webidl/SyncEvent.webidl b/dom/webidl/SyncEvent.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/SyncEvent.webidl
@@ -0,0 +1,20 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * https://wicg.github.io/BackgroundSync/spec/
+ */
+
+[Constructor(DOMString type, optional SyncEventInit eventInitDict),
+ Exposed=ServiceWorker]
+interface SyncEvent : ExtendableEvent {
+  readonly attribute DOMString tag;
+  //readonly attribute boolean lastChance;
+};
+
+dictionary SyncEventInit : ExtendableEventInit {
+  required DOMString tag;
+  //boolean lastChance = false;
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -534,16 +534,17 @@ WEBIDL_FILES = [
     'SVGTransformList.webidl',
     'SVGTSpanElement.webidl',
     'SVGUnitTypes.webidl',
     'SVGURIReference.webidl',
     'SVGUseElement.webidl',
     'SVGViewElement.webidl',
     'SVGZoomAndPan.webidl',
     'SVGZoomEvent.webidl',
+    'SyncEvent.webidl',
     'SyncManager.webidl',
     'SystemUpdate.webidl',
     'TCPServerSocket.webidl',
     'TCPServerSocketEvent.webidl',
     'TCPSocket.webidl',
     'TCPSocketErrorEvent.webidl',
     'TCPSocketEvent.webidl',
     'Telephony.webidl',
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -979,17 +979,17 @@ ExtractBytesFromData(const OwningArrayBu
     const ArrayBuffer& buffer = aDataInit.GetAsArrayBuffer();
     return ExtractBytesFromArrayBuffer(buffer, aBytes);
   } else if (aDataInit.IsUSVString()) {
     return ExtractBytesFromUSVString(aDataInit.GetAsUSVString(), aBytes);
   }
   NS_NOTREACHED("Unexpected push message data");
   return NS_ERROR_FAILURE;
 }
-}
+} // namespace
 
 PushMessageData::PushMessageData(nsISupports* aOwner,
                                  const nsTArray<uint8_t>& aBytes)
   : mOwner(aOwner), mBytes(aBytes) {}
 
 PushMessageData::~PushMessageData()
 {
 }
@@ -1110,16 +1110,52 @@ NS_IMPL_RELEASE_INHERITED(PushEvent, Ext
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(PushEvent)
 NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
 
 NS_IMPL_CYCLE_COLLECTION_INHERITED(PushEvent, ExtendableEvent, mData)
 
 #endif /* ! MOZ_SIMPLEPUSH */
 
+// Background Sync
+
+SyncEvent::SyncEvent(EventTarget* aOwner)
+  : ExtendableEvent(aOwner)
+{
+}
+
+already_AddRefed<SyncEvent>
+SyncEvent::Constructor(mozilla::dom::EventTarget* aOwner,
+                       const nsAString& aType,
+                       const SyncEventInit& aOptions,
+                       ErrorResult& aRv)
+{
+  RefPtr<SyncEvent> e = new SyncEvent(aOwner);
+  bool trusted = e->Init(aOwner);
+  e->InitEvent(aType, aOptions.mBubbles, aOptions.mCancelable);
+  e->SetTrusted(trusted);
+  e->mTag = aOptions.mTag;
+/*  if (aOptions.mLastEventId.WasPassed()) {
+    e->mLastChance = aOptions.mLastEventId.Value();
+  }*/
+  return e.forget();
+}
+
+NS_IMPL_ADDREF_INHERITED(SyncEvent, ExtendableEvent)
+NS_IMPL_RELEASE_INHERITED(SyncEvent, ExtendableEvent)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(SyncEvent)
+NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(SyncEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(SyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(SyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
 ExtendableMessageEvent::ExtendableMessageEvent(EventTarget* aOwner)
   : ExtendableEvent(aOwner)
   , mData(JS::UndefinedValue())
 {
   mozilla::HoldJSObjects(this);
 }
 
 ExtendableMessageEvent::~ExtendableMessageEvent()
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -16,16 +16,18 @@
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
 #ifndef MOZ_SIMPLEPUSH
 #include "mozilla/dom/PushEventBinding.h"
 #include "mozilla/dom/PushMessageDataBinding.h"
 #include "mozilla/dom/File.h"
 #endif
 
+#include "mozilla/dom/SyncEventBinding.h"
+
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
 class Blob;
@@ -317,11 +319,62 @@ public:
 
   void SetPorts(MessagePortList* aPorts);
 
   void SetSource(ServiceWorkerClient* aClient);
 
   void SetSource(ServiceWorker* aServiceWorker);
 };
 
+class SyncEvent final : public ExtendableEvent
+{
+  nsString mTag;
+  //bool mLastChance;
+
+protected:
+  explicit SyncEvent(mozilla::dom::EventTarget* aOwner);
+  ~SyncEvent() {}
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(SyncEvent, ExtendableEvent)
+  NS_FORWARD_TO_EVENT
+
+  virtual JSObject* WrapObjectInternal(JSContext* aCx,
+                                       JS::Handle<JSObject*> aGivenProto) override
+  {
+    return mozilla::dom::SyncEventBinding_workers::Wrap(aCx, this, aGivenProto);
+  }
+
+  static already_AddRefed<SyncEvent>
+  Constructor(mozilla::dom::EventTarget* aOwner,
+              const nsAString& aType,
+              const SyncEventInit& aOptions,
+              ErrorResult& aRv);
+
+  static already_AddRefed<SyncEvent>
+  Constructor(const GlobalObject& aGlobal,
+              const nsAString& aType,
+              const SyncEventInit& aOptions,
+              ErrorResult& aRv)
+  {
+    nsCOMPtr<EventTarget> owner = do_QueryInterface(aGlobal.GetAsSupports());
+    return Constructor(owner, aType, aOptions, aRv);
+  }
+
+  NS_IMETHOD
+  GetTag(nsAString& aTag)
+  {
+    aTag = mTag;
+    return NS_OK;
+  }
+
+  /*NS_IMETHOD
+  GetLastChance(bool& aLastChance)
+  {
+    aLastChance = mLastChance;
+    return NS_OK;
+  }*/
+};
+
 END_WORKERS_NAMESPACE
 
 #endif /* mozilla_dom_workers_serviceworkerevents_h__ */
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -5200,9 +5200,36 @@ ServiceWorkerInfo::~ServiceWorkerInfo()
 static uint64_t gServiceWorkerInfoCurrentID = 0;
 
 uint64_t
 ServiceWorkerInfo::GetNextID() const
 {
   return ++gServiceWorkerInfoCurrentID;
 }
 
+// Background Sync
+
+/*NS_IMETHODIMP
+ServiceWorkerManager::SendSyncEvent(const nsACString& aOriginAttributes,
+                                    const nsACString& aScope,
+                                    const nsACString& aTag,
+                                    const bool aLastChance)*/
+NS_IMETHODIMP
+ServiceWorkerManager::SendSyncEvent()
+{
+/*  PrincipalOriginAttributes attrs;
+  if (!attrs.PopulateFromSuffix(aOriginAttributes)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  ServiceWorkerInfo* serviceWorker = GetActiveWorkerInfoForScope(attrs, aScope);
+  if (NS_WARN_IF(!serviceWorker)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(serviceWorker->GetPrincipal(), aScope);
+*/
+  return NS_OK;
+  //return serviceWorker->WorkerPrivate()->SendSyncEvent(aData, registration);
+}
+
 END_WORKERS_NAMESPACE
