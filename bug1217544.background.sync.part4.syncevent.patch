# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  8c71ea9d40a9e0fb603a4e8b0b043dc7f0b96501
Bug 1217544 - Implement one-off BackgroundSync API. Part 4: Sync event. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -145,29 +145,32 @@ private:
 };
 
 // BackgroundSync
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnMainThread(nsIGlobalObject* aGlobal,
                                    nsIPrincipal* aPrincipal,
+                                   const nsAString& aScope,
                                    ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
+  MOZ_ASSERT(!aScope.IsEmpty());
   MOZ_ASSERT(NS_IsMainThread());
 
   PrincipalInfo principalInfo;
   aRv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
+  RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo,
+                                                  aScope);
 
   // Register as observer for inner-window-destroyed.
   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
   if (obs) {
     aRv = obs->AddObserver(ref, "inner-window-destroyed",
                            false /* ownsWeak */);
     if (NS_WARN_IF(aRv.Failed())) {
       return nullptr;
@@ -189,41 +192,46 @@ BackgroundSync::CreateOnMainThread(nsIGl
   ref->mInnerID = window->WindowID();
 
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
-                               WorkerPrivate* aWorkerPrivate)
+                               WorkerPrivate* aWorkerPrivate,
+                               const nsAString& aScope)
 {
   MOZ_ASSERT(aWorkerPrivate);
+  MOZ_ASSERT(!aScope.IsEmpty());
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal,
-                                                  principalInfo);
+                                                  principalInfo,
+                                                  aScope);
 
   ref->mWorkerHolder = new BackgroundSyncHolder(ref);
   if (NS_WARN_IF(!ref->mWorkerHolder->HoldWorker(aWorkerPrivate, Terminating))) {
     ref->mWorkerHolder = nullptr;
     return nullptr;
   }
 
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
-                               const PrincipalInfo& aPrincipalInfo)
+                               const PrincipalInfo& aPrincipalInfo,
+                               const nsAString& aScope)
   : mInnerID(0)
   , mGlobal(aGlobal)
   , mShuttingDown(false)
   , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
+  , mScope(aScope)
 {
 #ifdef DEBUG
   mThread = do_GetCurrentThread();
 #endif
 
   MOZ_ASSERT(aGlobal);
 
   // Register this component to PBackground.
@@ -413,17 +421,17 @@ BackgroundSync::ExecuteOp(const SyncOpAr
 
 // WebIDL interface methods.
 
 already_AddRefed<Promise>
 BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
-  const SyncRegisterArgs args((nsString(aTag)));
+  const SyncRegisterArgs args(mScope, (nsString(aTag)));
   return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -50,21 +50,23 @@ class BackgroundSync final : public nsII
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
       BackgroundSync, nsIIPCBackgroundChildCreateCallback)
 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
+                     const nsAString& aScope,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
   CreateOnWorker(nsIGlobalObject* aGlobal,
-                 workers::WorkerPrivate* aWorkerPrivate);
+                 workers::WorkerPrivate* aWorkerPrivate,
+                 const nsAString& aScope);
 
   // Binding methods.
 
   nsIGlobalObject*
   GetParentObject() const
   {
     return mGlobal;
   }
@@ -80,17 +82,18 @@ public:
   Register(const nsAString& aTag, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetTags(ErrorResult& aRv);
 
   void Shutdown();
 private:
   BackgroundSync(nsIGlobalObject* aGlobal,
-                 const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
+                 const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
+                 const nsAString& aScope);
 
   ~BackgroundSync();
 
   already_AddRefed<Promise>
   ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
 
   uint64_t mInnerID;
 
@@ -103,16 +106,18 @@ private:
   bool mShuttingDown;
 
   UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
 
   nsCOMPtr<nsIThread> mThread;
 
   nsTArray<RefPtr<SyncOpRunnable>> mPendingOperations;
 
+  nsString mScope;
+
 #ifdef DEBUG
   bool IsBackgroundSyncThread();
 #endif
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
--- a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -4,16 +4,17 @@
 
 include PBackgroundSharedTypes;
 
 namespace mozilla {
 namespace dom {
 
 struct SyncRegisterArgs
 {
+  nsString mScope;
   nsString mTag;
 };
 
 struct SyncGetTagsArgs
 {
 };
 
 union SyncOpArgs
diff --git a/dom/bindings/Bindings.conf b/dom/bindings/Bindings.conf
--- a/dom/bindings/Bindings.conf
+++ b/dom/bindings/Bindings.conf
@@ -103,16 +103,22 @@ DOMInterfaces = {
     'headerFile': 'mozilla/dom/BarProps.h',
 },
 
 'BackgroundSync': {
     'nativeType': 'mozilla::dom::backgroundsync::BackgroundSync',
     'headerFile': 'mozilla/dom/backgroundsync/BackgroundSync.h',
 },
 
+'BackgroundSyncEvent': {
+    'headerFile': 'mozilla/dom/ServiceWorkerEvents.h',
+    'nativeType': 'mozilla::dom::workers::BackgroundSyncEvent',
+    'workers': True
+},
+
 'BaseAudioContext': {
     'nativeType': 'mozilla::dom::AudioContext',
 },
 
 'Blob': {
     'headerFile': 'mozilla/dom/File.h',
 },
 
diff --git a/dom/interfaces/base/nsIServiceWorkerManager.idl b/dom/interfaces/base/nsIServiceWorkerManager.idl
--- a/dom/interfaces/base/nsIServiceWorkerManager.idl
+++ b/dom/interfaces/base/nsIServiceWorkerManager.idl
@@ -213,19 +213,23 @@ interface nsIServiceWorkerManager : nsIS
                                   in AString aBehavior);
 
   [optional_argc] void sendPushEvent(in ACString aOriginAttributes,
                                      in ACString aScope,
                                      [optional] in uint32_t aDataLength,
                                      [optional, array, size_is(aDataLength)] in uint8_t aDataBytes);
   void sendPushSubscriptionChangeEvent(in ACString aOriginAttributes,
                                        in ACString scope);
-
   void addListener(in nsIServiceWorkerManagerListener aListener);
 
   void removeListener(in nsIServiceWorkerManagerListener aListener);
 
   bool shouldReportToWindow(in mozIDOMWindowProxy aWindow, in ACString aScope);
+
+  void sendBackgroundSyncEvent(in ACString aOriginAttributes,
+                               in ACString scope,
+                               in AString aTag,
+                               in boolean aLastChance);
 };
 
 %{ C++
 #define SERVICEWORKERMANAGER_CONTRACTID "@mozilla.org/serviceworkers/manager;1"
 %}
diff --git a/dom/webidl/BackgroundSyncEvent.webidl b/dom/webidl/BackgroundSyncEvent.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/BackgroundSyncEvent.webidl
@@ -0,0 +1,21 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * https://wicg.github.io/BackgroundSync/spec/
+ */
+
+[Constructor(DOMString type, optional BackgroundSyncEventInit eventInitDict),
+ Exposed=ServiceWorker,
+ Func="mozilla::dom::backgroundsync::BackgroundSync::PrefEnabled"]
+interface BackgroundSyncEvent : ExtendableEvent {
+  readonly attribute DOMString tag;
+  readonly attribute boolean lastChance;
+};
+
+dictionary BackgroundSyncEventInit : ExtendableEventInit {
+  required DOMString tag;
+  boolean lastChance = false;
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -43,16 +43,17 @@ WEBIDL_FILES = [
     'AudioProcessingEvent.webidl',
     'AudioScheduledSourceNode.webidl',
     'AudioStreamTrack.webidl',
     'AudioTrack.webidl',
     'AudioTrackList.webidl',
     'AudioWorkletGlobalScope.webidl',
     'AutocompleteInfo.webidl',
     'BackgroundSync.webidl',
+    'BackgroundSyncEvent.webidl',
     'BarProp.webidl',
     'BaseAudioContext.webidl',
     'BaseKeyframeTypes.webidl',
     'BatteryManager.webidl',
     'BeforeUnloadEvent.webidl',
     'BiquadFilterNode.webidl',
     'Blob.webidl',
     'BoxObject.webidl',
diff --git a/dom/workers/PServiceWorkerManager.ipdl b/dom/workers/PServiceWorkerManager.ipdl
--- a/dom/workers/PServiceWorkerManager.ipdl
+++ b/dom/workers/PServiceWorkerManager.ipdl
@@ -28,18 +28,22 @@ parent:
   async PropagateRemove(nsCString host);
 
   async PropagateRemoveAll();
 
   async Shutdown();
 
 child:
   async NotifyRegister(ServiceWorkerRegistrationData data);
-  async NotifySoftUpdate(PrincipalOriginAttributes originAttributes, nsString scope);
+  async NotifySoftUpdate(PrincipalOriginAttributes originAttributes,
+                         nsString scope);
   async NotifyUnregister(PrincipalInfo principalInfo, nsString scope);
   async NotifyRemove(nsCString host);
   async NotifyRemoveAll();
-
+  async NotifyBackgroundSyncEvent(PrincipalInfo principalInfo,
+                                  nsString scope,
+                                  nsString tag,
+                                  bool lastChance);
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerEvents.cpp b/dom/workers/ServiceWorkerEvents.cpp
--- a/dom/workers/ServiceWorkerEvents.cpp
+++ b/dom/workers/ServiceWorkerEvents.cpp
@@ -1006,17 +1006,17 @@ ExtractBytesFromData(const OwningArrayBu
     return NS_OK;
   }
   if (aDataInit.IsUSVString()) {
     return ExtractBytesFromUSVString(aDataInit.GetAsUSVString(), aBytes);
   }
   NS_NOTREACHED("Unexpected push message data");
   return NS_ERROR_FAILURE;
 }
-}
+} // anonymous namespace
 
 PushMessageData::PushMessageData(nsISupports* aOwner,
                                  nsTArray<uint8_t>&& aBytes)
   : mOwner(aOwner), mBytes(Move(aBytes)) {}
 
 PushMessageData::~PushMessageData()
 {
 }
@@ -1148,16 +1148,50 @@ NS_INTERFACE_MAP_END_INHERITING(Extendab
 NS_IMPL_CYCLE_COLLECTION_INHERITED(PushEvent, ExtendableEvent, mData)
 
 JSObject*
 PushEvent::WrapObjectInternal(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
   return mozilla::dom::PushEventBinding::Wrap(aCx, this, aGivenProto);
 }
 
+// Background Sync
+
+BackgroundSyncEvent::BackgroundSyncEvent(EventTarget* aOwner)
+  : ExtendableEvent(aOwner)
+{
+}
+
+already_AddRefed<BackgroundSyncEvent>
+BackgroundSyncEvent::Constructor(mozilla::dom::EventTarget* aOwner,
+                       const nsAString& aType,
+                       const BackgroundSyncEventInit& aOptions,
+                       ErrorResult& aRv)
+{
+  RefPtr<BackgroundSyncEvent> e = new BackgroundSyncEvent(aOwner);
+  bool trusted = e->Init(aOwner);
+  e->InitEvent(aType, aOptions.mBubbles, aOptions.mCancelable);
+  e->SetTrusted(trusted);
+  e->mTag = aOptions.mTag;
+  e->mLastChance = aOptions.mLastChance;
+  return e.forget();
+}
+
+NS_IMPL_ADDREF_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_RELEASE_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(BackgroundSyncEvent)
+NS_INTERFACE_MAP_END_INHERITING(ExtendableEvent)
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(BackgroundSyncEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
 ExtendableMessageEvent::ExtendableMessageEvent(EventTarget* aOwner)
   : ExtendableEvent(aOwner)
   , mData(JS::UndefinedValue())
 {
   mozilla::HoldJSObjects(this);
 }
 
 ExtendableMessageEvent::~ExtendableMessageEvent()
diff --git a/dom/workers/ServiceWorkerEvents.h b/dom/workers/ServiceWorkerEvents.h
--- a/dom/workers/ServiceWorkerEvents.h
+++ b/dom/workers/ServiceWorkerEvents.h
@@ -11,16 +11,18 @@
 #include "mozilla/dom/ExtendableEventBinding.h"
 #include "mozilla/dom/ExtendableMessageEventBinding.h"
 #include "mozilla/dom/FetchEventBinding.h"
 #include "mozilla/dom/File.h"
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/Response.h"
 #include "mozilla/dom/workers/bindings/ServiceWorker.h"
 
+#include "mozilla/dom/BackgroundSyncEventBinding.h"
+
 #include "nsProxyRelease.h"
 #include "nsContentUtils.h"
 
 class nsIInterceptedChannel;
 
 namespace mozilla {
 namespace dom {
 class Blob;
@@ -321,11 +323,61 @@ public:
   {
     aLastEventId = mLastEventId;
     return NS_OK;
   }
 
   void GetPorts(nsTArray<RefPtr<MessagePort>>& aPorts);
 };
 
+class BackgroundSyncEvent final : public ExtendableEvent
+{
+  nsString mTag;
+  bool mLastChance;
+
+protected:
+  explicit BackgroundSyncEvent(mozilla::dom::EventTarget* aOwner);
+  ~BackgroundSyncEvent() {}
+
+public:
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(BackgroundSyncEvent, ExtendableEvent)
+  NS_FORWARD_TO_EVENT
+
+  virtual JSObject* WrapObjectInternal(JSContext* aCx,
+                                       JS::Handle<JSObject*> aGivenProto) override
+  {
+    return mozilla::dom::BackgroundSyncEventBinding::Wrap(aCx, this,
+                                                          aGivenProto);
+  }
+
+  static already_AddRefed<BackgroundSyncEvent>
+  Constructor(mozilla::dom::EventTarget* aOwner,
+              const nsAString& aType,
+              const BackgroundSyncEventInit& aOptions,
+              ErrorResult& aRv);
+
+  static already_AddRefed<BackgroundSyncEvent>
+  Constructor(const GlobalObject& aGlobal,
+              const nsAString& aType,
+              const BackgroundSyncEventInit& aOptions,
+              ErrorResult& aRv)
+  {
+    nsCOMPtr<EventTarget> owner = do_QueryInterface(aGlobal.GetAsSupports());
+    return Constructor(owner, aType, aOptions, aRv);
+  }
+
+  void
+  GetTag(nsAString& aTag)
+  {
+    aTag = mTag;
+  }
+
+  bool
+  LastChance()
+  {
+    return mLastChance;
+  }
+};
+
 END_WORKERS_NAMESPACE
 
 #endif /* mozilla_dom_workers_serviceworkerevents_h__ */
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1025,16 +1025,42 @@ ServiceWorkerManager::SendNotificationCl
                                                  const nsAString& aBehavior)
 {
   return SendNotificationEvent(NS_LITERAL_STRING(NOTIFICATION_CLOSE_EVENT_NAME),
                                aOriginSuffix, aScope, aID, aTitle, aDir, aLang,
                                aBody, aTag, aIcon, aData, aBehavior);
 }
 
 NS_IMETHODIMP
+ServiceWorkerManager::SendBackgroundSyncEvent(const nsACString& aOrigin,
+                                              const nsACString& aScope,
+                                              const nsAString& aTag,
+                                              const bool aLastChance)
+{
+  nsAutoCString originNoSuffix;
+  PrincipalOriginAttributes attrs;
+  if (!attrs.PopulateFromOrigin(aOrigin, originNoSuffix)) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  ServiceWorkerInfo* serviceWorker =
+    GetActiveWorkerInfoForScope(attrs, aScope);
+  if (NS_WARN_IF(!serviceWorker)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  RefPtr<ServiceWorkerRegistrationInfo> registration =
+    GetRegistration(serviceWorker->GetPrincipal(), aScope);
+
+  return serviceWorker->WorkerPrivate()->SendBackgroundSyncEvent(aTag,
+                                                                 aLastChance,
+                                                                 registration);
+}
+
+NS_IMETHODIMP
 ServiceWorkerManager::GetReadyPromise(mozIDOMWindow* aWindow,
                                       nsISupports** aPromise)
 {
   AssertIsOnMainThread();
 
   if (NS_WARN_IF(!aWindow)) {
     return NS_ERROR_DOM_INVALID_STATE_ERR;
   }
diff --git a/dom/workers/ServiceWorkerManagerChild.cpp b/dom/workers/ServiceWorkerManagerChild.cpp
--- a/dom/workers/ServiceWorkerManagerChild.cpp
+++ b/dom/workers/ServiceWorkerManagerChild.cpp
@@ -90,11 +90,40 @@ ServiceWorkerManagerChild::RecvNotifyRem
 
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
   swm->RemoveAll();
   return IPC_OK();
 }
 
+mozilla::ipc::IPCResult
+ServiceWorkerManagerChild::RecvNotifyBackgroundSyncEvent(
+    const PrincipalInfo& aPrincipalInfo, const nsString& aScope,
+    const nsString& aTag, const bool& aLastChance)
+{
+  if (mShuttingDown) {
+    return IPC_OK();
+  }
+
+  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo);
+  if (NS_WARN_IF(!principal)) {
+    return IPC_OK();
+  }
+
+  nsAutoCString originSuffix;
+  nsresult rv = principal->GetOriginSuffix(originSuffix);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return IPC_OK();
+  }
+
+  RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
+  MOZ_ASSERT(swm);
+
+  swm->SendBackgroundSyncEvent(originSuffix,
+                               NS_ConvertUTF16toUTF8(aScope),
+                               aTag, aLastChance);
+  return IPC_OK();
+}
+
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManagerChild.h b/dom/workers/ServiceWorkerManagerChild.h
--- a/dom/workers/ServiceWorkerManagerChild.h
+++ b/dom/workers/ServiceWorkerManagerChild.h
@@ -41,16 +41,21 @@ public:
 
   virtual mozilla::ipc::IPCResult RecvNotifyUnregister(const PrincipalInfo& aPrincipalInfo,
                                                        const nsString& aScope) override;
 
   virtual mozilla::ipc::IPCResult RecvNotifyRemove(const nsCString& aHost) override;
 
   virtual mozilla::ipc::IPCResult RecvNotifyRemoveAll() override;
 
+  virtual mozilla::ipc::IPCResult RecvNotifyBackgroundSyncEvent(const PrincipalInfo& aPrincipalInfo,
+                                                                const nsString& aScope,
+                                                                const nsString& aTag,
+                                                                const bool& aLastChance) override;
+
 private:
   ServiceWorkerManagerChild()
     : mShuttingDown(false)
   {}
 
   ~ServiceWorkerManagerChild() {}
 
   bool mShuttingDown;
diff --git a/dom/workers/ServiceWorkerPrivate.cpp b/dom/workers/ServiceWorkerPrivate.cpp
--- a/dom/workers/ServiceWorkerPrivate.cpp
+++ b/dom/workers/ServiceWorkerPrivate.cpp
@@ -1768,16 +1768,102 @@ ServiceWorkerPrivate::SendFetchEvent(nsI
 
   if (NS_WARN_IF(!r->Dispatch())) {
     return NS_ERROR_FAILURE;
   }
 
   return NS_OK;
 }
 
+namespace {
+class SendSyncEventRunnable final : public ExtendableFunctionalEventWorkerRunnable
+{
+  nsString mTag;
+  bool mLastChance;
+
+public:
+  SendSyncEventRunnable(WorkerPrivate* aWorkerPrivate,
+                        KeepAliveToken* aKeepAliveToken,
+                        const nsAString& aTag,
+                        const bool aLastChance,
+                        nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> aRegistration)
+    : ExtendableFunctionalEventWorkerRunnable(
+        aWorkerPrivate, aKeepAliveToken, aRegistration)
+    , mTag(aTag)
+    , mLastChance(aLastChance)
+  {
+    AssertIsOnMainThread();
+    MOZ_ASSERT(aWorkerPrivate);
+    MOZ_ASSERT(aWorkerPrivate->IsServiceWorker());
+  }
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    MOZ_ASSERT(aWorkerPrivate);
+    GlobalObject globalObj(aCx, aWorkerPrivate->GlobalScope()->GetWrapper());
+
+    BackgroundSyncEventInit sei;
+    sei.mTag = mTag;
+    sei.mLastChance = mLastChance;
+    sei.mBubbles = false;
+    sei.mCancelable = false;
+
+    ErrorResult result;
+    RefPtr<BackgroundSyncEvent> event =
+      BackgroundSyncEvent::Constructor(globalObj, NS_LITERAL_STRING("sync"),
+                                       sei, result);
+    if (NS_WARN_IF(result.Failed())) {
+      result.SuppressException();
+      return false;
+    }
+    event->SetTrusted(true);
+
+    DispatchExtendableEventOnWorkerScope(aCx, aWorkerPrivate->GlobalScope(),
+                                         event, nullptr);
+
+    return true;
+  }
+};
+} // anonymous namespace
+
+nsresult
+ServiceWorkerPrivate::SendBackgroundSyncEvent(const nsAString& aTag,
+                                              const bool aLastChance,
+                                              ServiceWorkerRegistrationInfo* aRegistration)
+{
+  nsresult rv = SpawnWorkerIfNeeded(BackgroundSyncEvent, nullptr);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  RefPtr<KeepAliveToken> token = CreateEventKeepAliveToken();
+
+  nsMainThreadPtrHandle<ServiceWorkerRegistrationInfo> regInfo(
+      new nsMainThreadPtrHolder<ServiceWorkerRegistrationInfo>(aRegistration, false));
+
+
+  RefPtr<WorkerRunnable> runnable = new SendSyncEventRunnable(mWorkerPrivate,
+                                                              token,
+                                                              aTag,
+                                                              aLastChance,
+                                                              regInfo);
+
+  if (mInfo->State() == ServiceWorkerState::Activating) {
+    mPendingFunctionalEvents.AppendElement(runnable.forget());
+    return NS_OK;
+  }
+
+  MOZ_ASSERT(mInfo->State() == ServiceWorkerState::Activated);
+
+  if (NS_WARN_IF(!runnable->Dispatch())) {
+    return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
 nsresult
 ServiceWorkerPrivate::SpawnWorkerIfNeeded(WakeUpReason aWhy,
                                           nsIRunnable* aLoadFailedRunnable,
                                           nsILoadGroup* aLoadGroup)
 {
   AssertIsOnMainThread();
 
   // XXXcatalinb: We need to have a separate load group that's linked to
diff --git a/dom/workers/ServiceWorkerPrivate.h b/dom/workers/ServiceWorkerPrivate.h
--- a/dom/workers/ServiceWorkerPrivate.h
+++ b/dom/workers/ServiceWorkerPrivate.h
@@ -110,16 +110,21 @@ public:
                         const nsAString& aScope);
 
   nsresult
   SendFetchEvent(nsIInterceptedChannel* aChannel,
                  nsILoadGroup* aLoadGroup,
                  const nsAString& aDocumentId,
                  bool aIsReload);
 
+  nsresult
+  SendBackgroundSyncEvent(const nsAString& aTag,
+                          const bool aLastChance,
+                          ServiceWorkerRegistrationInfo* aRegistration);
+
   void
   StoreISupports(nsISupports* aSupports);
 
   void
   RemoveISupports(nsISupports* aSupports);
 
   // This will terminate the current running worker thread and drop the
   // workerPrivate reference.
@@ -160,17 +165,18 @@ private:
   enum WakeUpReason {
     FetchEvent = 0,
     PushEvent,
     PushSubscriptionChangeEvent,
     MessageEvent,
     NotificationClickEvent,
     NotificationCloseEvent,
     LifeCycleEvent,
-    AttachEvent
+    AttachEvent,
+    BackgroundSyncEvent
   };
 
   // Timer callbacks
   static void
   NoteIdleWorkerCallback(nsITimer* aTimer, void* aPrivate);
 
   static void
   TerminateWorkerCallback(nsITimer* aTimer, void *aPrivate);
diff --git a/dom/workers/ServiceWorkerRegistration.cpp b/dom/workers/ServiceWorkerRegistration.cpp
--- a/dom/workers/ServiceWorkerRegistration.cpp
+++ b/dom/workers/ServiceWorkerRegistration.cpp
@@ -897,17 +897,17 @@ ServiceWorkerRegistrationMainThread::Get
 
     nsCOMPtr<nsIPrincipal> principal = document->NodePrincipal();
     if (!principal) {
       aRv.Throw(NS_ERROR_FAILURE);
       return nullptr;
     }
 
     mBackgroundSync = BackgroundSync::CreateOnMainThread(globalObject, principal,
-                                                         aRv);
+                                                         mScope, aRv);
   }
 
   return mBackgroundSync;
 }
 
 ////////////////////////////////////////////////////
 // Worker Thread implementation
 
@@ -1417,17 +1417,17 @@ ServiceWorkerRegistrationWorkerThread::G
   return ret.forget();
 }
 
 BackgroundSync*
 ServiceWorkerRegistrationWorkerThread::GetSync(ErrorResult& aRv)
 {
   if (!mBackgroundSync) {
     mBackgroundSync = BackgroundSync::CreateOnWorker(
-        mWorkerPrivate->GlobalScope(), mWorkerPrivate);
+        mWorkerPrivate->GlobalScope(), mWorkerPrivate, mScope);
   }
 
   return mBackgroundSync;
 }
 
 ////////////////////////////////////////////////////
 // Base class implementation
 
diff --git a/dom/workers/test/serviceworkers/test_serviceworker_interfaces.js b/dom/workers/test/serviceworkers/test_serviceworker_interfaces.js
--- a/dom/workers/test/serviceworkers/test_serviceworker_interfaces.js
+++ b/dom/workers/test/serviceworkers/test_serviceworker_interfaces.js
@@ -72,17 +72,19 @@ var ecmaGlobals =
   ];
 // IMPORTANT: Do not change the list above without review from
 //            a JavaScript Engine peer!
 
 // IMPORTANT: Do not change the list below without review from a DOM peer!
 var interfaceNamesInGlobalScope =
   [
 // IMPORTANT: Do not change this list without review from a DOM peer!
-    {name: "BackgroundSync", disabled: true},
+    { name: "BackgroundSync", disabled: true },
+// IMPORTANT: Do not change this list without review from a DOM peer!
+    { name: "BackgroundSyncEvent", disabled: true },
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "Blob",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "BroadcastChannel",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "Cache",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "CacheStorage",
