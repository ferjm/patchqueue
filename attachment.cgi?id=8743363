# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  ce90b71eb26e1cddfdc5f3bfe352dc90066fad21
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: Sync DB. r=baku

diff --git a/dom/sync/SyncRegistration.cpp b/dom/sync/SyncRegistration.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncRegistration.cpp
@@ -0,0 +1,147 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/ModuleUtils.h"
+#include "SyncRegistration.h"
+
+#define NS_SYNCREGISTRATION_CID \
+  { 0x566a1540, 0x45d8, 0x4828, {0xbf, 0x8a, 0xf9, 0x6e, 0x58, 0x5d, 0x94, 0xe8} }
+
+namespace mozilla {
+namespace dom {
+
+NS_IMPL_ISUPPORTS(nsSyncRegistration, nsISyncRegistration)
+
+NS_IMETHODIMP
+nsSyncRegistration::Init(const nsAString& aId,
+                         const nsAString& aOriginSuffix,
+                         const nsAString& aScope,
+                         const nsAString& aTag,
+                         uint16_t aState,
+                         bool aLastChance)
+{
+  mId = aId;
+  mOriginSuffix = aOriginSuffix;
+  mScope = aScope;
+  mTag = aTag;
+  mState = aState;
+  mLastChance = aLastChance;
+  return NS_OK;
+}
+
+/* attribute DOMString originSuffix; */
+NS_IMETHODIMP
+nsSyncRegistration::GetOriginSuffix(nsAString & aOriginSuffix)
+{
+  aOriginSuffix = mOriginSuffix;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetOriginSuffix(const nsAString & aOriginSuffix)
+{
+  mOriginSuffix = aOriginSuffix;
+  return NS_OK;
+}
+
+/* attribute DOMString id; */
+NS_IMETHODIMP
+nsSyncRegistration::GetId(nsAString & aId)
+{
+  aId = mId;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetId(const nsAString & aId)
+{
+  mId = aId;
+  return NS_OK;
+}
+
+/* attribute DOMString scope; */
+NS_IMETHODIMP
+nsSyncRegistration::GetScope(nsAString & aScope)
+{
+  aScope = mScope;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetScope(const nsAString & aScope)
+{
+  mScope = aScope;
+  return NS_OK;
+}
+
+/* attribute DOMString tag; */
+NS_IMETHODIMP
+nsSyncRegistration::GetTag(nsAString & aTag)
+{
+  aTag = mTag;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetTag(const nsAString & aTag)
+{
+  mTag = aTag;
+  return NS_OK;
+}
+
+/* attribute unsigned short state; */
+NS_IMETHODIMP
+nsSyncRegistration::GetState(uint16_t *aState)
+{
+  *aState = mState;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetState(uint16_t aState)
+{
+  mState = aState;
+  return NS_OK;
+}
+
+/* attribute boolean lastChance; */
+NS_IMETHODIMP
+nsSyncRegistration::GetLastChance(bool *aLastChance)
+{
+  *aLastChance = mLastChance;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsSyncRegistration::SetLastChance(bool aLastChance)
+{
+  mLastChance = aLastChance;
+  return NS_OK;
+}
+
+NS_GENERIC_FACTORY_CONSTRUCTOR(nsSyncRegistration);
+
+NS_DEFINE_NAMED_CID(NS_SYNCREGISTRATION_CID);
+
+static const mozilla::Module::CIDEntry kSyncRegistrationCIDs[] = {
+  { &kNS_SYNCREGISTRATION_CID, false, nullptr, nsSyncRegistrationConstructor },
+  { nullptr }
+};
+
+static const mozilla::Module::ContractIDEntry kSyncRegistrationContracts[] = {
+  { "@mozilla.org/dom/sync/registration;1", &kNS_SYNCREGISTRATION_CID },
+  { nullptr }
+};
+
+static const mozilla::Module kSyncRegistrationModule = {
+  mozilla::Module::kVersion,
+  kSyncRegistrationCIDs,
+  kSyncRegistrationContracts,
+  nullptr
+};
+
+} // namespace dom
+} // namespace mozilla
+
+NSMODULE_DEFN(SyncRegistrationModule) = &mozilla::dom::kSyncRegistrationModule;
diff --git a/dom/sync/SyncRegistration.h b/dom/sync/SyncRegistration.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncRegistration.h
@@ -0,0 +1,35 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_SyncRegistration_h
+#define mozilla_dom_SyncRegistration_h
+
+#include "nsISyncRegistry.h"
+
+namespace mozilla {
+namespace dom {
+
+class nsSyncRegistration : public nsISyncRegistration
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSISYNCREGISTRATION
+
+  nsSyncRegistration() {}
+
+private:
+  virtual ~nsSyncRegistration() {}
+
+  nsString mOriginSuffix;
+  nsString mId;
+  nsString mScope;
+  nsString mTag;
+  uint16_t mState;
+  bool mLastChance;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncRegistration_h
diff --git a/dom/sync/SyncRegistry.js b/dom/sync/SyncRegistry.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncRegistry.js
@@ -0,0 +1,169 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict"
+
+function debug(s) {
+  dump("DEBUG SyncRegistry: " + s + "\n");
+}
+
+function error(s) {
+  dump("ERROR SyncRegistry: " + s + "\n");
+}
+
+const { classes: Cc, interfaces: Ci, results: Cr, utils: Cu } = Components;
+
+Cu.import("resource://gre/modules/IndexedDBHelper.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+const RW = "readwrite";
+const RO = "readonly";
+
+const SYNC_REGISTRY_DB_NAME    = "background-sync-registry";
+const SYNC_REGISTRY_DB_VERSION = 1;
+const SYNC_REGISTRY_STORE_NAME = "registry";
+
+let gInstance = null;
+function SyncRegistry() {
+  if (gInstance) {
+    return gInstance;
+  }
+  gInstance = this;
+  gInstance.init();
+  debug("SyncRegistry created");
+}
+
+SyncRegistry.prototype = {
+  __proto__: IndexedDBHelper.prototype,
+
+  init: function() {
+    debug("init");
+    this.initDBHelper(SYNC_REGISTRY_DB_NAME,
+                      SYNC_REGISTRY_DB_VERSION,
+                      [SYNC_REGISTRY_STORE_NAME]);
+  },
+
+  upgradeSchema: function(aTransaction, aDb, aOldVersion, aNewVersion) {
+    debug("upgradeSchema");
+    /**
+     * We will be storing objects like:
+     * {
+     *   id: <string> (key), // concatenation of scope + tag,
+     *   originSuffix: <string>,
+     *   scope: <string> (index),
+     *   tag: <string>,
+     *   state: <number>,
+     *   lastChance: <boolean>
+     * }
+     */
+    let objectStore = aDb.createObjectStore(SYNC_REGISTRY_STORE_NAME, {
+      keyPath: "id"
+    });
+    objectStore.createIndex("scope", "scope", { unique: false });
+  },
+
+  getId(aRegistration) {
+    return aRegistration.tag + '@' + aRegistration.scope;
+  },
+
+  add(aRegistration, aListener) {
+    debug("add " + JSON.stringify(aRegistration));
+    if (!aRegistration ||
+        !aRegistration.tag || !aRegistration.scope ||
+        !aRegistration.tag.length || !aRegistration.scope.length) {
+      error("Missing registration info");
+      aListener.notifyError(Cr.NS_ERROR_ILLEGAL_VALUE);
+      return;
+    }
+
+    this.newTxn(RW, SYNC_REGISTRY_STORE_NAME, (aTxn, aStore) => {
+      aStore.add({
+        id: this.getId(aRegistration),
+        originSuffix: aRegistration.originSuffix,
+        scope: aRegistration.scope,
+        tag: aRegistration.tag,
+        state: Ci.nsISyncRegistry.STATE_PENDING,
+        lastChance: true // XXX Bug 1260138
+      });
+    }, () => {
+      aListener.notifyAddSuccess();
+    }, error => {
+      error = isNaN(error) ? Cr.NS_ERROR_FAILURE : error;
+      aListener.notifyError(error);
+    });
+  },
+
+  remove(aId, aListener) {
+    debug("remove " + aId);
+    this.newTxn(RW, SYNC_REGISTRY_STORE_NAME, (aTxn, aStore) => {
+      aStore.delete(aId);
+    }, () => {
+      debug("registration removed " + aId);
+    }, error => {
+      error = isNaN(error) ? Cr.NS_ERROR_FAILURE : error;
+      aListener.notifyError(error);
+    });
+  },
+
+  getAll(aListener) {
+    debug("getAll");
+    this.newTxn(RO, SYNC_REGISTRY_STORE_NAME, (aTxn, aStore) => {
+      aStore.getAll().onsuccess = event => {
+        let results = event.target.result;
+        let registrations = Cc["@mozilla.org/array;1"]
+                              .createInstance(Ci.nsIMutableArray);;
+        for (let i = 0; i < results.length; i++) {
+          let registration = Cc["@mozilla.org/dom/sync/registration;1"]
+                               .createInstance(Ci.nsISyncRegistration);
+          let result = results[i];
+          registration.init(result.id,
+                            result.originSuffix,
+                            result.scope,
+                            result.tag,
+                            result.state,
+                            result.lastChance);
+          debug("registration " + JSON.stringify(registration));
+          try {
+            registrations.appendElement(registration, false /* weak */);
+          } catch(e) {
+            return aListener.notifyError(Cr.NS_ERROR_OUT_OF_MEMORY);
+          }
+        }
+        aListener.notifyGetAllSuccess(registrations);
+      };
+    }, null, error => {
+      error = isNaN(error) ? Cr.NS_ERROR_FAILURE : error;
+      aListener.notifyError(error);
+    });
+  },
+
+  changeState(aId, aState, aListener) {
+    debug("changeState " + aId + " " + aState);
+    this.newTxn(RW, SYNC_REGISTRY_STORE_NAME, (aTxn, aStore) => {
+      aStore.get(aId).onsuccess = event => {
+        let registration = event.target.result;
+        debug("registration " + JSON.stringify(registration));
+        registration.state = aState;
+        aStore.put(registration).onsuccess = event => {
+          let result = Cc["@mozilla.org/dom/sync/registration;1"]
+                         .createInstance(Ci.nsISyncRegistration);
+          ["id", "scope", "tag", "state", "lastChance"].forEach(property => {
+            result[property] = registration[property];
+          });
+          aListener.notifyChangeStateSuccess(result);
+        };
+      };
+    }, null, error => {
+      error = isNaN(error) ? Cr.NS_ERROR_FAILURE : error;
+      aListener.notifyError(error);
+    });
+  },
+
+  classID: Components.ID("{c1200834-3ebb-45e2-81cf-986edeb107f6}"),
+  contractID: "@mozilla.org/dom/sync/registry;1",
+  QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistry,
+                                         Ci.nsISupports])
+};
+
+this.NSGetFactory = XPCOMUtils.generateNSGetFactory([SyncRegistry]);
diff --git a/dom/sync/SyncRegistry.manifest b/dom/sync/SyncRegistry.manifest
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncRegistry.manifest
@@ -0,0 +1,2 @@
+component {c1200834-3ebb-45e2-81cf-986edeb107f6} SyncRegistry.js
+contract @mozilla.org/dom/sync/registry;1 {c1200834-3ebb-45e2-81cf-986edeb107f6}
diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -5,23 +5,35 @@
 
 EXPORTS.mozilla.dom += [
     'SyncManager.h'
 ]
 
 UNIFIED_SOURCES += [
     'SyncManager.cpp',
     'SyncManagerChild.cpp',
-    'SyncManagerParent.cpp'
+    'SyncManagerParent.cpp',
+    'SyncRegistration.cpp'
 ]
 
 IPDL_SOURCES += [
     'PSyncManager.ipdl',
     'SyncIPCTypes.ipdlh'
 ]
 
 LOCAL_INCLUDES += [
     '/dom/workers'
 ]
 
+XPIDL_SOURCES += [
+    'nsISyncRegistry.idl'
+]
+
+XPIDL_MODULE = 'dom_sync'
+
+EXTRA_COMPONENTS += [
+    'SyncRegistry.js',
+    'SyncRegistry.manifest'
+]
+
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
diff --git a/dom/sync/nsISyncRegistry.idl b/dom/sync/nsISyncRegistry.idl
new file mode 100644
--- /dev/null
+++ b/dom/sync/nsISyncRegistry.idl
@@ -0,0 +1,57 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsIArray.idl"
+#include "nsISupports.idl"
+
+[scriptable, uuid(671ea934-232d-47c6-87ba-b72715088914)]
+interface nsISyncRegistration : nsISupports
+{
+  attribute DOMString id;
+  attribute DOMString originSuffix;
+  attribute DOMString scope;
+  attribute DOMString tag;
+  attribute unsigned short state; // "pending" by default
+  attribute boolean lastChance;
+
+  void init(in DOMString id,
+            in DOMString originSuffix,
+            in DOMString scope,
+            in DOMString tag,
+            in unsigned short state,
+            in boolean lastChance);
+};
+
+[scriptable, uuid(3084a211-3ef4-4fa3-8a20-dab42f062571)]
+interface nsISyncRegistryListener : nsISupports
+{
+  attribute nsID requestId;
+  attribute unsigned long long actorId;
+
+  void notifyAddSuccess();
+  void notifyGetAllSuccess(in nsIArray registrations);
+  void notifyChangeStateSuccess(in nsISyncRegistration registration);
+  void notifyError(in uint32_t error);
+};
+
+[scriptable, uuid(dfcc3fb2-f40d-44f9-85ea-1127be79fbe9)]
+interface nsISyncRegistry : nsISupports
+{
+  const unsigned short STATE_PENDING                    = 1;
+  const unsigned short STATE_WAITING                    = 2;
+  const unsigned short STATE_FIRING                     = 3;
+  const unsigned short STATE_REREGISTERING_WHILE_FIRING = 4;
+
+  void add(in nsISyncRegistration registration,
+           in nsISyncRegistryListener listener);
+
+  void remove(in DOMString id,
+              in nsISyncRegistryListener listener);
+
+  void getAll(in nsISyncRegistryListener listener);
+
+  void changeState(in DOMString id,
+                   in unsigned short state,
+                   in nsISyncRegistryListener listener);
+};
