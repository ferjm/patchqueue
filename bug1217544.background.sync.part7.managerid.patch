# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  e25919eb2e0af494fe0c86e6e15d2b0e81a3ba0e
Bug 1217544 - Implement one-off BackgroundSync API. Part 7: Storage. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSync.h"
 #include "BackgroundSyncChild.h"
 
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BackgroundSyncBinding.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/Unused.h"
 #include "mozilla/Preferences.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIGlobalObject.h"
@@ -48,44 +47,241 @@ public:
 
   void SetActor(BackgroundSyncChild* aActor)
   {
     MOZ_ASSERT(!mActor);
     MOZ_ASSERT(aActor);
     mActor = aActor;
   }
 
-  NS_IMETHOD Run() override
+  NS_IMETHOD
+  Run() override
   {
     MOZ_ASSERT(mActor);
     if (mActor->IsActorDestroyed()) {
       return NS_OK;
     }
 
     return mActor->ExecuteOp(mPromise, mOp);
   }
 
-  NS_IMETHOD Cancel() override
+  NS_IMETHOD
+  Cancel() override
   {
     mActor = nullptr;
     mPromise = nullptr;
     mOp = nullptr;
     return NS_OK;
   }
 
+  void
+  MaybeReject(nsresult aRv)
+  {
+    MOZ_ASSERT(mPromise);
+
+    mPromise->MaybeReject(aRv);
+  }
+
 private:
   ~SyncOpRunnable() {}
 
   RefPtr<Promise> mPromise;
   nsAutoPtr<SyncOp> mOp;
   RefPtr<BackgroundSyncChild> mActor;
 };
 
 NS_IMPL_ISUPPORTS(SyncOpRunnable, nsICancelableRunnable, nsIRunnable)
 
+class RegisterResultRunnable final : public WorkerRunnable
+{
+public:
+  RegisterResultRunnable(WorkerPrivate* aWorkerPrivate,
+                         PromiseWorkerProxy* aProxy,
+                         nsresult aStatus,
+                         ErrorResult& aRv)
+    : WorkerRunnable(aWorkerPrivate, WorkerThreadUnchangedBusyCount)
+    , mProxy(aProxy)
+    , mStatus(aStatus)
+    , mRv(aRv)
+  {}
+
+  bool
+  WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate) override
+  {
+    RefPtr<Promise> promise = mProxy->WorkerPromise();
+    if (NS_SUCCEEDED(mStatus)) {
+      promise->MaybeResolve(JS::NullHandleValue);
+    } else {
+      mRv.Throw(mStatus);
+      promise->MaybeReject(mStatus);
+    }
+    return true;
+  }
+
+private:
+  ~RegisterResultRunnable() {}
+
+  RefPtr<PromiseWorkerProxy> mProxy;
+  nsresult mStatus;
+  ErrorResult& mRv;
+};
+
+class RegisterHelper final : public nsIRunnable,
+                             public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  // Worker thread constructor.
+  RegisterHelper(BackgroundSync* aTarget,
+                 PromiseWorkerProxy* aPromiseProxy,
+                 const PrincipalInfo& aPrincipalInfo,
+                 const nsAString& aScope,
+                 const nsAString& aTag,
+                 ErrorResult& aRv)
+    : mTarget(aTarget)
+    , mPromiseProxy(aPromiseProxy)
+    , mPromise(nullptr)
+    , mPrincipalInfo(aPrincipalInfo)
+    , mScope(aScope)
+    , mTag(aTag)
+    , mRv(aRv)
+  {
+    MOZ_ASSERT(!NS_IsMainThread());
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mPromiseProxy);
+  }
+
+  // Main thread constructor.
+  RegisterHelper(BackgroundSync* aTarget,
+                 Promise* aPromise,
+                 const PrincipalInfo& aPrincipalInfo,
+                 const nsAString& aScope,
+                 const nsAString& aTag,
+                 ErrorResult& aRv)
+    : mTarget(aTarget)
+    , mPromiseProxy(nullptr)
+    , mPromise(aPromise)
+    , mPrincipalInfo(aPrincipalInfo)
+    , mScope(aScope)
+    , mTag(aTag)
+    , mRv(aRv)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mPromise);
+  }
+
+  void
+  Execute()
+  {
+    if (NS_IsMainThread()) {
+      nsresult rv;
+      nsCOMPtr<nsIPrincipal> principal =
+        PrincipalInfoToPrincipal(mPrincipalInfo, &rv);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        MaybeReject(rv);
+        return;
+      }
+
+      rv = principal->GetOrigin(mOrigin);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        MaybeReject(rv);
+        return;
+      }
+
+      if (mPromise) {
+        const SyncRegisterArgs args(NS_ConvertUTF8toUTF16(mOrigin),
+                                    mScope, (nsString(mTag)));
+        mTarget->ExecuteOp(SyncOpArgs(args), mPromise, mRv);
+      } else {
+        MOZ_ASSERT(mPromiseProxy);
+        MOZ_ASSERT(mWorkerThread);
+        mWorkerThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      }
+    } else {
+      MOZ_ASSERT(mPromiseProxy);
+
+      mWorkerThread = do_GetCurrentThread();
+
+      nsresult rv = NS_DispatchToMainThread(this);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        MaybeReject(rv);
+      }
+    }
+  }
+
+  /**
+   * This method is called only when the RegisterHelper is created on a worker
+   * thread. And in that case it is called twice. The first time in the main
+   * thread, to get the origin value from the principal info and the second time
+   * back on the worker thread to continue with the execution of the sync
+   * operation.
+   */
+  NS_IMETHOD
+  Run() override
+  {
+    if (NS_IsMainThread()) {
+      Execute();
+    } else {
+      RefPtr<Promise> promise = mPromiseProxy->WorkerPromise();
+      MOZ_ASSERT(promise);
+      const SyncRegisterArgs args(NS_ConvertUTF8toUTF16(mOrigin),
+                                  mScope, (nsString(mTag)));
+      mTarget->ExecuteOp(SyncOpArgs(args), promise, mRv);
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~RegisterHelper() {}
+
+  void
+  MaybeReject(nsresult aRv)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+
+    if (mPromise) {
+      mRv.Throw(aRv);
+      return mPromise->MaybeReject(aRv);
+    }
+
+    MOZ_ASSERT(mPromiseProxy);
+
+    MutexAutoLock lock(mPromiseProxy->Lock());
+    if (mPromiseProxy->CleanedUp()) {
+      // Worker has already shut down, can't access worker private;
+      return;
+    }
+    RefPtr<RegisterResultRunnable> runnable =
+      new RegisterResultRunnable(mPromiseProxy->GetWorkerPrivate(),
+                                 mPromiseProxy, aRv, mRv);
+    MOZ_ALWAYS_TRUE(runnable->Dispatch());
+  }
+
+  RefPtr<BackgroundSync> mTarget;
+  RefPtr<PromiseWorkerProxy> mPromiseProxy;
+  RefPtr<Promise> mPromise;
+  PrincipalInfo mPrincipalInfo;
+  nsString mScope;
+  nsString mTag;
+  nsAutoCString mOrigin;
+  ErrorResult& mRv;
+  nsCOMPtr<nsIThread> mWorkerThread;
+};
+
+NS_IMPL_ISUPPORTS(RegisterHelper, nsICancelableRunnable, nsIRunnable)
+
 class TeardownRunnable final : public nsIRunnable,
                                public nsICancelableRunnable
 {
 public:
   NS_DECL_ISUPPORTS
 
   explicit TeardownRunnable(BackgroundSyncChild* aActor)
     : mActor(aActor)
@@ -335,17 +531,18 @@ BackgroundSync::ActorCreated(PBackground
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
   if (mShuttingDown) {
     return;
   }
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
@@ -383,65 +580,112 @@ BackgroundSync::Observe(nsISupports* aSu
     }
   }
 
   Shutdown();
 
   return NS_OK;
 }
 
+void
+BackgroundSync::ExecuteOp(SyncOpRunnable* aRunnable,
+                          ErrorResult& aRv)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  if (mShuttingDown) {
+    aRunnable->MaybeReject(NS_ERROR_NOT_AVAILABLE);
+    aRv.Throw(NS_ERROR_NOT_AVAILABLE);
+  }
+
+  if (!mActor) {
+    mPendingOperations.AppendElement(aRunnable);
+    return;
+  }
+
+  MOZ_ASSERT(mPendingOperations.IsEmpty());
+
+  aRunnable->SetActor(mActor);
+  nsresult rv = NS_DispatchToCurrentThread(aRunnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aRunnable->MaybeReject(rv);
+  }
+}
+
+void
+BackgroundSync::ExecuteOp(const SyncOpArgs& aArgs,
+                          Promise* aPromise,
+                          ErrorResult& aRv)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  nsAutoPtr<SyncOp> op(new SyncOp(*mPrincipalInfo, aArgs));
+  RefPtr<SyncOpRunnable> runnable = new SyncOpRunnable(aPromise, op);
+
+  ExecuteOp(runnable, aRv);
+}
+
+// WebIDL interface methods.
+
 already_AddRefed<Promise>
-BackgroundSync::ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv)
+BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
   if (mShuttingDown) {
     return nullptr;
   }
 
   RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
-  nsAutoPtr<SyncOp> op(new SyncOp(*mPrincipalInfo, aArgs));
-  RefPtr<SyncOpRunnable> runnable = new SyncOpRunnable(p, op);
+  RefPtr<RegisterHelper> helper;
 
-  if (!mActor) {
-    mPendingOperations.AppendElement(runnable);
-    return p.forget();
+  if (NS_IsMainThread()) {
+    helper = new RegisterHelper(this, p, *mPrincipalInfo, mScope, aTag, aRv);
+  } else {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+    workerPrivate->AssertIsOnWorkerThread();
+
+    RefPtr<PromiseWorkerProxy> promiseProxy =
+      PromiseWorkerProxy::Create(workerPrivate, p);
+    if (!promiseProxy) {
+      p->MaybeReject(NS_ERROR_DOM_ABORT_ERR);
+      return p.forget();
+    }
+
+    helper = new RegisterHelper(this, promiseProxy, *mPrincipalInfo, mScope,
+                                aTag, aRv);
   }
 
-  runnable->SetActor(mActor);
-  nsresult rv = NS_DispatchToCurrentThread(runnable);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    p->MaybeReject(rv);
-  }
-
+  helper->Execute();
   return p.forget();
 }
 
-// WebIDL interface methods.
-
-already_AddRefed<Promise>
-BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
-{
-  MOZ_ASSERT(IsBackgroundSyncThread());
-
-  const SyncRegisterArgs args(mScope, (nsString(aTag)));
-  return ExecuteOp(SyncOpArgs(args), aRv);
-}
-
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
+  if (mShuttingDown) {
+    return nullptr;
+  }
+
+  RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
+  if (NS_WARN_IF(aRv.Failed())) {
+    return nullptr;
+  }
+
   const SyncGetTagsArgs args;
-  return ExecuteOp(SyncOpArgs(args), aRv);
+  ExecuteOp(SyncOpArgs(args), p, aRv);
+
+  return p.forget();
 }
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(BackgroundSync, mGlobal)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(BackgroundSync)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(BackgroundSync)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(BackgroundSync)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
   NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -5,17 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSync_h
 #define mozilla_dom_BackgroundSync_h
 
 #include "jsapi.h"
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/ErrorResult.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "nsCOMPtr.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 #include "nsIObserver.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 class nsIPrincipal;
@@ -39,16 +39,18 @@ namespace backgroundsync {
 
 class BackgroundSyncChild;
 class SyncOpRunnable;
 
 class BackgroundSync final : public nsIIPCBackgroundChildCreateCallback
                            , public nsIObserver
                            , public nsWrapperCache
 {
+  friend class RegisterHelper;
+
   NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
   NS_DECL_NSIOBSERVER
 
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
       BackgroundSync, nsIIPCBackgroundChildCreateCallback)
 
@@ -87,18 +89,21 @@ public:
   void Shutdown();
 private:
   BackgroundSync(nsIGlobalObject* aGlobal,
                  const mozilla::ipc::PrincipalInfo& aPrincipalInfo,
                  const nsAString& aScope);
 
   ~BackgroundSync();
 
-  already_AddRefed<Promise>
-  ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
+  void
+  ExecuteOp(SyncOpRunnable* aRunnable,ErrorResult& aRv);
+  void
+  ExecuteOp(const SyncOpArgs& aArgs, Promise* aPromise,
+            ErrorResult& aRv);
 
   uint64_t mInnerID;
 
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
   nsAutoPtr<workers::WorkerHolder> mWorkerHolder;
 
   RefPtr<BackgroundSyncChild> mActor;
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -4,25 +4,25 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncChild_h
 #define mozilla_dom_BackgroundSyncChild_h
 
 #include "BackgroundSync.h"
 
-#include "mozilla/dom/PBackgroundSyncChild.h"
+#include "mozilla/dom/backgroundsync/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
--- a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -1,55 +1,136 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PBackgroundSharedTypes;
 
+using RegistrationState from "mozilla/dom/backgroundsync/BackgroundSyncTypes.h";
+using mozilla::void_t from "ipc/IPCMessageUtils.h";
+
 namespace mozilla {
 namespace dom {
+namespace backgroundsync {
 
 struct SyncRegisterArgs
 {
+  nsString mOrigin;
   nsString mScope;
   nsString mTag;
 };
 
 struct SyncGetTagsArgs
 {
+  nsString mScope;
 };
 
 union SyncOpArgs
 {
   SyncRegisterArgs;
   SyncGetTagsArgs;
 };
 
 struct SyncOp
 {
   PrincipalInfo mPrincipal;
   SyncOpArgs mArgs;
 };
 
+struct Registration
+{
+  nsString mId;
+  nsString mOrigin;
+  nsString mScope;
+  nsString mTag;
+  RegistrationState mState;
+  bool mLastChance;
+};
+
 struct SyncRegisterResponse
 {
-  bool mSuccess;
+  Registration mRegistration;
+  bool mFirstRegistration;
 };
 
 struct SyncGetTagsResponse
 {
   nsString[] mTags;
 };
 
+struct SyncGetAllResponse
+{
+  Registration[] mRegistrations;
+};
+
+struct SyncRemoveResponse
+{
+  nsString mOrigin;
+};
+
+struct SyncChangeStateResponse
+{
+  Registration mRegistration;
+};
+
+struct SyncRegisterOriginResponse
+{
+  Registration mRegistration;
+};
+
+struct SyncUnregisterOriginResponse
+{
+};
+
+struct SyncGetAllOriginsResponse
+{
+  nsString[] mOrigins;
+};
+
 struct SyncOpError
 {
   uint32_t mCode;
 };
 
 union SyncOpResponse
 {
+  void_t;
   SyncRegisterResponse;
   SyncGetTagsResponse;
+  SyncGetAllResponse;
+  SyncRemoveResponse;
+  SyncChangeStateResponse;
+  SyncRegisterOriginResponse;
+  SyncUnregisterOriginResponse;
+  SyncGetAllOriginsResponse;
   SyncOpError;
 };
 
+struct SyncGetAllArgs
+{};
+
+struct SyncChangeStateArgs
+{
+  nsString mId;
+  uint16_t mState;
+};
+
+struct SyncRemoveArgs
+{
+  nsString mId;
+};
+
+union SyncInternalOpArgs
+{
+  void_t;
+  SyncGetAllArgs;
+  SyncChangeStateArgs;
+  SyncRemoveArgs;
+};
+
+struct SyncInternalOp
+{
+  SyncInternalOpArgs mArgs;
+};
+
+} // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -11,71 +11,120 @@
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 namespace backgroundsync {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class BackgroundSyncParent::PendingRequest final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(PendingRequest)
+
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID RequestId() const
+  {
+    return mRequestId;
+  }
+
+  SyncOp Op() const
+  {
+    return mOp;
+  }
+private:
+  ~PendingRequest() {}
+
+  const nsID mRequestId;
+  const SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  mStorageManagerIdFactory =
+    StorageManagerIdFactory::Create(this, aPrincipalInfo);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
-  switch(aOp.mArgs().type()) {
-    case SyncOpArgs::TSyncRegisterArgs:
-    {
-      // XXX Do registration.
-      const SyncRegisterResponse response(true);
-      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    case SyncOpArgs::TSyncGetTagsArgs:
-    {
-      //XXX Do GetTags.
-      nsTArray<nsString> tags;
-      const SyncGetTagsResponse response(tags);
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    default:
-    {
-      MOZ_CRASH("Unknown BackgroundSync request");
-    }
+  // XXX Progress request to BackgroundSyncService.
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a StorageManagerId for this parent yet, we
+  // queue the request.
+  if (!mStorageManagerId) {
+    RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
+    mPendingRequests.AppendElement(pendingRequest);
+    return true;
   }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
 void
+BackgroundSyncParent::OnStorageManagerIdCreated(
+    StorageManagerId* aManagerId)
+{
+  MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(!mStorageManagerId);
+
+  mStorageManagerId = aManagerId;
+  mStorageManagerIdFactory->RemoveListener(this);
+  mStorageManagerIdFactory = nullptr;
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+    MOZ_ASSERT(mPendingRequests[i]);
+    ExecuteRequest(mPendingRequests[i]->RequestId(),
+                   mPendingRequests[i]->Op());
+  }
+  mPendingRequests.Clear();
+}
+
+void
 BackgroundSyncParent::NotifyResponse(const nsID& aRequestId,
                                      const SyncOpResponse& aResponse)
 {
   AssertIsOnBackgroundThread();
 
   Unused << SendResponse(aRequestId, aResponse);
 }
 
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,47 +2,68 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
-#include "mozilla/dom/PBackgroundSyncParent.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+#include "mozilla/dom/backgroundsync/PBackgroundSyncParent.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
+
+#include "StorageManagerId.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
   class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
+                                 , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 
   void NotifyResponse(const nsID& aRequestId,
                       const SyncOpResponse& aResponse);
 
 private:
-  BackgroundSyncParent();
+  explicit BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // StorageManagerId method
+  virtual void
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+
+  RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
+  // We use this Id to ensure that we have a single StorageManager
+  // per principal.
+  RefPtr<StorageManagerId> mStorageManagerId;
+
+  class PendingRequest;
+  nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
diff --git a/dom/backgroundsync/BackgroundSyncTypes.h b/dom/backgroundsync/BackgroundSyncTypes.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncTypes.h
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncTypes_h
+#define mozilla_dom_BackgroundSyncTypes_h
+
+#include <stdint.h>
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+enum RegistrationState
+{
+  ePending = 1,
+  eWaiting,
+  eFiring,
+  eReregisteringWhileFiring,
+  eNumberOfRegistrationStates
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+namespace IPC {
+
+using mozilla::dom::backgroundsync::RegistrationState;
+
+template <>
+struct ParamTraits<RegistrationState>
+  : public ContiguousEnumSerializer<RegistrationState,
+                                    RegistrationState::ePending,
+                                    RegistrationState::eNumberOfRegistrationStates>
+{ };
+
+} // namespace IPC
+#endif // mozilla_dom_BackgroundSyncTypes_h
diff --git a/dom/backgroundsync/ChromeDBSchema.cpp b/dom/backgroundsync/ChromeDBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeDBSchema.cpp
@@ -0,0 +1,154 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ChromeDBSchema.h"
+#include "DBCommon.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozilla/storage.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace chromedb {
+
+using namespace mozilla::dom::backgroundsync::dbcommon;
+
+using storage::utils::Expect;
+using storage::utils::Migration;
+
+namespace {
+
+// Update this whenever the DB schema is changed.
+const int32_t kLatestSchemaVersion = 1;
+
+// We will wipe out databases with schema versions less than this. Newer
+// versions will be migrated on open to the latest schema version.
+const int32_t kFirstShippedSchemaVersion = 1;
+
+// ---------
+const char* const kTableOrigins =
+  "CREATE TABLE origins ("
+    "origin TEXT NOT NULL PRIMARY KEY"
+  ")";
+// ---------
+// End schema definition
+// ---------
+
+} // namespace
+
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn)
+{
+  nsTArray<nsCString> tablesSql;
+  tablesSql.AppendElement(nsCString(kTableOrigins));
+
+  nsTArray<Expect> expect;
+  expect.AppendElement(Expect("origins", "table", kTableOrigins));
+  expect.AppendElement(Expect("sqlite_autoindex_origins_1", "index"));
+
+  return storage::utils::CreateOrMigrateSchema(aConn,
+                                               kFirstShippedSchemaVersion,
+                                               kLatestSchemaVersion, tablesSql,
+                                               expect, nsTArray<Migration>());
+}
+
+nsresult
+InitializeConnection(mozIStorageConnection* aConn)
+{
+  return storage::utils::InitializeConnection(aConn, kPageSize, kGrowthSize,
+                                              kWalAutoCheckpointPages,
+                                              kWalAutoCheckpointSize);
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return storage::utils::IncrementalVacuum(aConn, kMaxFreePages);
+}
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const nsAString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO origins ("
+      "origin "
+    ") VALUES ("
+      ":origin "
+    ");"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsString origin;
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"), aOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+Unregister(mozIStorageConnection* aConn,
+           const nsAString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM origins WHERE origin=:origin;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsString origin;
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"), aOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<nsString>& aOrigins)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT * FROM origins;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString origin;
+    rv = state->GetString(0, origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    aOrigins.AppendElement(origin);
+  }
+
+  return rv;
+}
+
+} // namespace chromedb
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/ChromeDBSchema.h b/dom/backgroundsync/ChromeDBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeDBSchema.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ChromeDBSchema_h
+#define mozilla_dom_ChromeDBSchema_h
+
+class mozIStorageConnection;
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace chromedb {
+
+// Note, this cannot be executed within a transaction.
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn);
+
+// Note, this cannot be executed within a transaction.
+nsresult
+InitializeConnection(mozIStorageConnection* aConn);
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const nsAString& aOrigin);
+
+nsresult
+Unregister(mozIStorageConnection* aConn,
+           const nsAString& aOrigin);
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<nsString>& aOrigins);
+
+// Note, this works best when its NOT executed within a transaction.
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn);
+
+} // namespace chromedb
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ChromeDBSchema_h
diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -0,0 +1,403 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ChromeDBSchema.h"
+#include "ChromeStorageManager.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
+
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+namespace {
+  ChromeStorageManager* csmInstance = nullptr;
+} // namespace
+
+//-----------------------------------------------------------------------------
+
+class ChromeStorageAction
+{
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageAction)
+
+  enum Type {
+    Register = 0,
+    Unregister,
+    GetAll
+  };
+
+  ChromeStorageAction(Type aType,
+                      const nsID& aRequestId)
+    : mType(aType)
+    , mRequestId(aRequestId)
+  {}
+
+  ChromeStorageAction(Type aType,
+                      const nsID& aRequestId,
+                      const nsAString& aOrigin)
+    : mType(aType)
+    , mRequestId(aRequestId)
+    , mOrigin(aOrigin)
+  {}
+
+  ChromeStorageAction(Type aType,
+                      const nsID& aRequestId,
+                      const Registration& aRegistration)
+    : mType(aType)
+    , mRequestId(aRequestId)
+    , mRegistration(aRegistration)
+  {}
+
+  Type Type()
+  {
+    return mType;
+  }
+
+  nsString& Origin()
+  {
+    return mOrigin;
+  }
+
+  nsID& RequestId()
+  {
+    return mRequestId;
+  }
+
+  Registration& GetRegistration()
+  {
+    return mRegistration;
+  }
+
+private:
+  ~ChromeStorageAction() {}
+
+  enum Type mType;
+  nsID mRequestId;
+  nsString mOrigin;
+  Registration mRegistration;
+};
+
+//-----------------------------------------------------------------------------
+// IO thread
+
+class InitRunnable final : public nsIRunnable,
+                           public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  InitRunnable(ChromeStorageManager* aManager)
+    : mManager(aManager)
+    , mInitiatingThread(do_GetCurrentThread())
+  {
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      MOZ_ASSERT(mDBConn);
+      mManager->OnInitialized(mDBConn);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIFile> dbFile;
+    nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
+                                         getter_AddRefs(dbFile));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dbFile->AppendNative(NS_LITERAL_CSTRING("backgroundsync.sqlite"));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<mozIStorageService> storage =
+      do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+    if (NS_WARN_IF(!storage)) { return rv; }
+
+    rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    MOZ_ASSERT(mDBConn);
+
+    chromedb::CreateOrMigrateSchema(mDBConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+
+    return rv;
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~InitRunnable() {};
+
+  nsCOMPtr<mozIStorageConnection> mDBConn;
+  RefPtr<ChromeStorageManager> mManager;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+};
+
+NS_IMPL_ISUPPORTS(InitRunnable, nsICancelableRunnable, nsIRunnable)
+
+class ShutdownRunnable : public nsIRunnable,
+                         public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  ShutdownRunnable(mozIStorageConnection* aConn)
+    : mDBConn(aConn)
+  {}
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    MOZ_ASSERT(mDBConn);
+
+    return mDBConn->Close();
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~ShutdownRunnable() {};
+
+  nsCOMPtr<mozIStorageConnection> mDBConn;
+};
+
+NS_IMPL_ISUPPORTS(ShutdownRunnable, nsICancelableRunnable, nsIRunnable)
+
+class StorageActionRunnable : public nsIRunnable,
+                              public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  StorageActionRunnable(ChromeStorageManager* aManager,
+                        mozIStorageConnection* aConn,
+                        ChromeStorageAction* aAction)
+    : mManager(aManager)
+    , mInitiatingThread(do_GetCurrentThread())
+    , mConn(aConn)
+    , mAction(aAction)
+  {
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(mInitiatingThread);
+    MOZ_ASSERT(aConn);
+    MOZ_ASSERT(aAction);
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    nsresult rv = NS_OK;
+    if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      mManager->OnRequestComplete(mAction->RequestId(), mResponse);
+      return rv;
+    }
+
+    switch (mAction->Type()) {
+      case ChromeStorageAction::Type::Register:
+        {
+          Registration registration = mAction->GetRegistration();
+          rv = chromedb::Register(mConn, registration.mOrigin());
+          if (NS_WARN_IF(NS_FAILED(rv))) {
+            mResponse = SyncOpError(static_cast<uint32_t>(rv));
+          } else {
+            mResponse = SyncRegisterOriginResponse(registration);
+          }
+        }
+        break;
+      case ChromeStorageAction::Type::Unregister:
+        rv = chromedb::Unregister(mConn, mAction->Origin());
+        if (NS_WARN_IF(NS_FAILED(rv))) {
+          mResponse = SyncOpError(static_cast<uint32_t>(rv));
+        } else {
+          mResponse = SyncUnregisterOriginResponse();
+        }
+        break;
+      case ChromeStorageAction::Type::GetAll:
+        {
+          nsTArray<nsString> origins;
+          rv = chromedb::GetAll(mConn, origins);
+          if (NS_WARN_IF(NS_FAILED(rv))) {
+            mResponse = SyncOpError(static_cast<uint32_t>(rv));
+          } else {
+            mResponse = SyncGetAllOriginsResponse(origins);
+          }
+          break;
+        }
+      default:
+        MOZ_CRASH("BackgroundSync: Unexpected ChromeStorageAction");
+    }
+
+    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+
+    return rv;
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~StorageActionRunnable() {}
+
+  RefPtr<ChromeStorageManager> mManager;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsCOMPtr<mozIStorageConnection> mConn;
+  RefPtr<ChromeStorageAction> mAction;
+  SyncOpResponse mResponse;
+};
+
+NS_IMPL_ISUPPORTS(StorageActionRunnable, nsICancelableRunnable, nsIRunnable)
+
+//-----------------------------------------------------------------------------
+// PBackground thread
+
+ChromeStorageManager::ChromeStorageManager()
+{
+  AssertIsOnBackgroundThread();
+
+  Init();
+}
+
+ChromeStorageManager::~ChromeStorageManager()
+{
+  AssertIsOnBackgroundThread();
+
+  if (mDBConn) {
+    RefPtr<ShutdownRunnable> runnable = new ShutdownRunnable(mDBConn);
+    mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+    mDBConn = nullptr;
+  }
+
+  mPendingActions.Clear();
+
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
+
+  csmInstance = nullptr;
+}
+
+// static
+already_AddRefed<ChromeStorageManager>
+ChromeStorageManager::GetOrCreate()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ChromeStorageManager> instance = csmInstance;
+  if (!instance) {
+    instance = new ChromeStorageManager();
+  }
+  return instance.forget();
+}
+
+void
+ChromeStorageManager::Init()
+{
+  AssertIsOnBackgroundThread();
+
+  nsresult rv = NS_NewNamedThread("BSyncChIOThread", getter_AddRefs(mIOThread));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  RefPtr<InitRunnable> runnable = new InitRunnable(this);
+  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+}
+
+void
+ChromeStorageManager::OnInitialized(mozIStorageConnection* aConn)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aConn);
+
+  mDBConn = aConn;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    ExecuteStorageAction(mPendingActions[i]);
+  }
+  mPendingActions.Clear();
+}
+
+void
+ChromeStorageManager::ExecuteStorageAction(ChromeStorageAction* aAction)
+{
+  AssertIsOnBackgroundThread();
+
+  if (!mDBConn) {
+    mPendingActions.AppendElement(aAction);
+    return;
+  }
+
+  RefPtr<StorageActionRunnable> runnable = new StorageActionRunnable(this,
+                                                                     mDBConn,
+                                                                     aAction);
+  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+}
+
+void
+ChromeStorageManager::Register(const nsID& aRequestId,
+                               const Registration& aRegistration)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ChromeStorageAction> action =
+    new ChromeStorageAction(ChromeStorageAction::Type::Register, aRequestId,
+                            aRegistration);
+  ExecuteStorageAction(action);
+}
+
+void
+ChromeStorageManager::Unregister(const nsID& aRequestId,
+                                 const nsAString& aOrigin)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ChromeStorageAction> action =
+    new ChromeStorageAction(ChromeStorageAction::Type::Unregister, aRequestId,
+                            aOrigin);
+  ExecuteStorageAction(action);
+}
+
+void
+ChromeStorageManager::GetAll(const nsID& aRequestId)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ChromeStorageAction> action =
+    new ChromeStorageAction(ChromeStorageAction::Type::GetAll, aRequestId);
+  ExecuteStorageAction(action);
+}
+
+void
+ChromeStorageManager::OnRequestComplete(const nsID& aRequestId,
+                                        const SyncOpResponse& aResponse)
+{
+  AssertIsOnBackgroundThread();
+
+  // XXX Notify listener.
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/ChromeStorageManager.h b/dom/backgroundsync/ChromeStorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeStorageManager.h
@@ -0,0 +1,68 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ChromeStorageManager_h
+#define mozilla_dom_ChromeStorageManager_h
+
+/**
+ * This singleton object is kept alive by the BackgroundSyncService. While a
+ * content related storage request is on going, this object should be kept
+ * alive. If no pending storage requests are in place, this object can be
+ * released.
+ **
+ * It manages the chrome database that stores the origins that have pending
+ * sync registrations.
+ */
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/storage.h"
+#include "nsISupportsImpl.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class ChromeStorageAction;
+class Registration;
+
+class ChromeStorageManager final
+{
+  friend class InitRunnable;
+  friend class StorageActionRunnable;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageManager)
+
+  static already_AddRefed<ChromeStorageManager>
+  GetOrCreate();
+
+  void Register(const nsID& aRequestId, const Registration& aRegistration);
+  void Unregister(const nsID& aRequestId, const nsAString& aOrigin);
+  void GetAll(const nsID& aRequestId);
+
+private:
+  ChromeStorageManager();
+  ~ChromeStorageManager();
+
+  void Init();
+  void OnInitialized(mozIStorageConnection* aConn);
+
+  void ExecuteStorageAction(ChromeStorageAction* aAction);
+
+  void OnRequestComplete(const nsID& aRequestId,
+                         const SyncOpResponse& aResponse);
+
+  nsCOMPtr<nsIThread> mIOThread;
+  nsCOMPtr<mozIStorageConnection> mDBConn;
+
+  nsTArray<RefPtr<ChromeStorageAction>> mPendingActions;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ChromeStorageManager_h
diff --git a/dom/backgroundsync/DBAction.cpp b/dom/backgroundsync/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBAction.cpp
@@ -0,0 +1,228 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBAction.h"
+#include "DBSchema.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozilla/net/nsFileProtocolHandler.h"
+#include "mozilla/storage.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsIFileURL.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode)
+  : mMode(aMode)
+{
+}
+
+DBAction::~DBAction()
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                      Data* aOptionalData)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaInfo.mDir);
+
+  if (IsCanceled()) {
+    aResolver->Resolve(NS_ERROR_ABORT);
+    return;
+  }
+
+  nsCOMPtr<nsIFile> dbDir;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  rv = dbDir->Append(NS_LITERAL_STRING("backgroundsync"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+
+  // Attempt to reuse the connection opened by a previous Action.
+  if (aOptionalData) {
+    conn = aOptionalData->GetConnection();
+  }
+
+  // If there is no previous ClientAction, then we must open one.
+  if (!conn) {
+    rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+    MOZ_ASSERT(conn);
+
+    // Save this connection in the shared Data object so later ClientActions
+    // can use it.  This avoids opening a new connection for every
+    // ClientAction.
+    if (aOptionalData) {
+      // Since we know this connection will be around for as long as the
+      // storage is open, use our special wrapped connection class.  This
+      // will let us perform certain operations once the storage origin
+      // is closed.
+      nsCOMPtr<mozIStorageConnection> wrapped =
+        new storage::IncrementalVacuumConnection(conn, db::kMaxFreePages);
+      aOptionalData->SetConnection(wrapped);
+    }
+  }
+
+  RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
+}
+
+nsresult
+DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                         mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  nsCOMPtr<mozIStorageConnection> conn;
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("backgroundsync.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Use our default file:// protocol handler directly to construct the database
+  // URL. This avoids any problems if a plugin registers a custom file://
+  // handler. If such a custom handler used javascript, then we would have a
+  // bad time running off the main thread here.
+  RefPtr<nsFileProtocolHandler> handler = new nsFileProtocolHandler();
+  rv = handler->Init();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIURI> uri;
+  rv = handler->NewFileURI(dbFile, getter_AddRefs(uri));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
+
+  rv = dbFileUrl->SetQuery(
+    NS_LITERAL_CSTRING("persistenceType=") + type +
+    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
+    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin +
+    NS_LITERAL_CSTRING("&cache=private"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    NS_WARNING("BackgroundSync database corrupted. Recreating empty database.");
+
+    conn = nullptr;
+
+    // There is nothing else we can do to recover.  Also, this data can
+    // be deleted by QuotaManager at any time anyways.
+    rv = WipeDatabase(dbFile, aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Check the schema to make sure it is not too old.
+  int32_t schemaVersion = 0;
+  rv = conn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (schemaVersion > 0 && schemaVersion < db::kFirstShippedSchemaVersion) {
+    conn = nullptr;
+    rv = WipeDatabase(dbFile, aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = db::InitializeConnection(conn);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  conn.forget(aConnOut);
+
+  return rv;
+}
+
+nsresult
+DBAction::WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir)
+{
+  nsresult rv = aDBFile->Remove(false);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Note, the -wal journal file will be automatically deleted by sqlite when
+  // the new database is created.  No need to explicitly delete it here.
+
+  return rv;
+}
+
+SyncDBAction::SyncDBAction(Mode aMode)
+  : DBAction(aMode)
+{
+}
+
+SyncDBAction::~SyncDBAction()
+{
+}
+
+void
+SyncDBAction::RunWithDBOnTarget(Resolver* aResolver,
+                                const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                                mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = RunSyncOnTarget(aQuotaInfo, aConn);
+  aResolver->Resolve(rv);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBAction.h b/dom/backgroundsync/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBAction.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DBAction_h
+#define mozilla_dom_DBAction_h
+
+#include "mozilla/dom/quota/ClientAction.h"
+#include "mozilla/dom/quota/QuotaInfo.h"
+#include "mozilla/RefPtr.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using quota::ClientAction;
+using quota::QuotaInfo;
+
+class DBAction : public ClientAction
+{
+protected:
+  // The mode specifies whether the database should already exist or if its
+  // ok to create a new database.
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  explicit DBAction(Mode aMode);
+
+  // ClientAction objects are deleted through their base pointer
+  virtual ~DBAction();
+
+  // Just as the resolver must be ref'd until resolve, you may also
+  // ref the DB connection. The connection can only be referenced from the
+  // target thread and must be released upon resolve.
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) = 0;
+
+private:
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+              Data* aOptionalData) override;
+
+  nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
+                          mozIStorageConnection** aConnOut);
+
+  nsresult WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir);
+
+  const Mode mMode;
+};
+
+class SyncDBAction : public DBAction
+{
+protected:
+  explicit SyncDBAction(Mode aMode);
+
+  // Action objects are deleted through their base pointer
+  virtual ~SyncDBAction();
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) = 0;
+
+private:
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) override;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DBAction_h
diff --git a/dom/backgroundsync/DBSchema.cpp b/dom/backgroundsync/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchema.cpp
@@ -0,0 +1,404 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBSchema.h"
+#include "DBCommon.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+#include "nsICryptoHash.h"
+#include "nsNetCID.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace db {
+
+using namespace mozilla::dom::backgroundsync::dbcommon;
+
+using mozilla::dom::backgroundsync::Registration;
+using storage::utils::Migration;
+
+const int32_t kFirstShippedSchemaVersion = 1;
+
+namespace {
+
+// Update this whenever the DB schema is changed.
+const int32_t kLatestSchemaVersion = 1;
+
+// ---------
+// We want to use the concatenation of scope and tag as the primary key, but
+// since scope is a URL, it can be quite long and so quite expensive to index,
+// so we create a hash of this concatenation taking the first 8 bytes of its
+// SHA1.
+//
+// tag allows NULL below since that is how "" is represented in a
+// BLOB column. We use BLOB to avoid encoding issues with storing
+// DOMStrings.
+const char* const kTableRegistrations =
+  "CREATE TABLE registrations ("
+    "id TEXT NOT NULL PRIMARY KEY, "
+    "origin TEXT NOT NULL, "
+    "scope TEXT NOT NULL, "
+    "tag BLOB NULL, "
+    "state INTEGER NOT NULL, "
+    "lastChance INTEGER NOT NULL"
+  ")";
+// ---------
+// End schema definition
+// ---------
+
+} // namespace
+
+
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn)
+{
+  nsTArray<nsCString> tablesSql;
+  tablesSql.AppendElement(nsCString(kTableRegistrations));
+
+  nsTArray<Expect> expect;
+  expect.AppendElement(Expect("registrations", "table", kTableRegistrations));
+  expect.AppendElement(Expect("sqlite_autoindex_registrations_1", "index"));
+
+  return storage::utils::CreateOrMigrateSchema(aConn,
+                                               kFirstShippedSchemaVersion,
+                                               kLatestSchemaVersion, tablesSql,
+                                               expect, nsTArray<Migration>());
+}
+
+nsresult
+InitializeConnection(mozIStorageConnection* aConn)
+{
+  return storage::utils::InitializeConnection(aConn, kPageSize, kGrowthSize,
+                                              kWalAutoCheckpointPages,
+                                              kWalAutoCheckpointSize);
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return storage::utils::IncrementalVacuum(aConn, kMaxFreePages);
+}
+
+nsresult
+GetId(const nsAString& aScope, const nsAString& aTag, nsAString& aId)
+{
+  nsresult rv;
+
+  nsCOMPtr<nsICryptoHash> crypto =
+    do_CreateInstance(NS_CRYPTO_HASH_CONTRACTID, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = crypto->Init(nsICryptoHash::SHA1);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsAString concat(aScope + NS_LITERAL_STRING("@") + aTag);
+  rv = crypto->Update(reinterpret_cast<const uint8_t*>(concat.BeginReading()),
+                      concat.Length());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsAutoCString fullHash;
+  rv = crypto->Finish(true /* based64 result */, fullHash);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  aId = NS_ConvertUTF8toUTF16(Substring(fullHash, 0, 8));
+  return rv;
+}
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aArgs,
+         bool& firstRegistrationForOrigin,
+         Registration& aRegistration)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = NS_OK;
+
+  {
+    nsCOMPtr<mozIStorageStatement> state;
+    rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+      "INSERT INTO registrations ("
+        "id, "
+        "origin, "
+        "scope, "
+        "tag, "
+        "state, "
+        "lastChance "
+      ") VALUES ("
+        ":id, "
+        ":origin, "
+        ":scope, "
+        ":tag, "
+        ":state, "
+        ":lastChance "
+      ");"
+    ), getter_AddRefs(state));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString id;
+    GetId(aArgs.mScope(), aArgs.mTag(), id);
+
+    Registration registration(id, aArgs.mOrigin(),
+                              aArgs.mScope(),
+                              aArgs.mTag(),
+                              RegistrationState::ePending,
+                              false);
+    aRegistration = registration;
+
+    rv = state->BindStringByName(NS_LITERAL_CSTRING("id"),
+                                 registration.mId());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"),
+                                 registration.mOrigin());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindStringByName(NS_LITERAL_CSTRING("scope"),
+                                 registration.mScope());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindUTF8StringAsBlobByName(NS_LITERAL_CSTRING("tag"),
+                                           NS_ConvertUTF16toUTF8(registration.mTag()));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindInt32ByName(NS_LITERAL_CSTRING("state"),
+                                RegistrationState::ePending);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // By default new registrations are not flagged as last chance.
+    rv = state->BindInt32ByName(NS_LITERAL_CSTRING("lastChance"), 0);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->Execute();
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  // After inserting the new registration we check if this is the first
+  // registration for this origin. In that case, we need to register the
+  // origin in the 'origins' DB.
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT COUNT(*) FROM (SELECT id FROM registrations WHERE origin=:origin);"
+  ), getter_AddRefs(state));
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"), aArgs.mOrigin());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  NS_SUCCEEDED(state->ExecuteStep(&hasMoreData));
+
+  int32_t count;
+  rv = state->GetInt32(0, &count);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  firstRegistrationForOrigin = (count == 1);
+
+  return rv;
+}
+
+nsresult
+GetTags(mozIStorageConnection* aConn,
+        const SyncGetTagsArgs& aArgs,
+        nsTArray<nsString>& aTags)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT tag FROM registrations;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsAutoCString tag;
+    rv = state->GetBlobAsUTF8String(0, tag);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    aTags.AppendElement(NS_ConvertUTF8toUTF16(tag));
+  }
+
+  return rv;
+}
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<Registration>& aRegistrations)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT "
+    "id, "
+    "origin, "
+    "scope, "
+    "tag, "
+    "state, "
+    "lastChance FROM registrations;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString id;
+    rv = state->GetString(0, id);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString origin;
+    rv = state->GetString(1, origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString scope;
+    rv = state->GetString(2, scope);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsAutoCString tag;
+    rv = state->GetBlobAsUTF8String(3, tag);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t registrationState;
+    rv = state->GetInt32(4, &registrationState);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t lastChance;
+    rv = state->GetInt32(5, &lastChance);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    Registration registration(id, origin, scope, NS_ConvertUTF8toUTF16(tag),
+      RegistrationState(registrationState), bool(lastChance));
+    aRegistrations.AppendElement(registration);
+  }
+
+  return rv;
+}
+
+nsresult
+Remove(mozIStorageConnection* aConn,
+       const SyncRemoveArgs& aArgs,
+       nsString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  // Get the origin value before removing the entry from the 'registrations'
+  // DB so we can remove the entry from the 'origins' DB in case that there are
+  // no more sync registrations for that origin.
+  nsCOMPtr<mozIStorageStatement> getOriginState;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT origin FROM registrations WHERE id=:id;"
+  ), getter_AddRefs(getOriginState));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = getOriginState->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t count = 0;
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(getOriginState->ExecuteStep(&hasMoreData))
+         && hasMoreData) {
+    // We only set the origin on the first registration.
+    if (count == 0) {
+      rv = getOriginState->GetString(0, aOrigin);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    } else if (!aOrigin.IsEmpty() && hasMoreData){
+      aOrigin = EmptyString();
+    }
+    hasMoreData = false;
+    count++;
+  }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM registrations WHERE id=:id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+ChangeState(mozIStorageConnection* aConn,
+            const SyncChangeStateArgs& aArgs,
+            Registration& aRegistrationOut)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "UPDATE registrations SET state=:regstate WHERE id=:id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("regstate"),
+                              static_cast<int32_t>(aArgs.mState()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  {
+    // Get the origin value after changing its state.
+    nsCOMPtr<mozIStorageStatement> state;
+    nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+      "SELECT * FROM registrations WHERE id=:id;"
+    ), getter_AddRefs(state));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool ignored = false;
+    rv = state->ExecuteStep(&ignored);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetString(0, aRegistrationOut.mId());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetString(1, aRegistrationOut.mOrigin());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetString(2, aRegistrationOut.mScope());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = state->GetString(3, aRegistrationOut.mTag());
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t registrationState;
+    rv = state->GetInt32(4, &registrationState);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    aRegistrationOut.mState() =
+      RegistrationState(registrationState);
+
+    int32_t lastChance;
+    rv = state->GetInt32(5, &lastChance);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    aRegistrationOut.mLastChance() = bool(lastChance);
+  }
+
+  return rv;
+}
+
+} // namespace db
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBSchema.h b/dom/backgroundsync/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchema.h
@@ -0,0 +1,83 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DBSchema_h
+#define mozilla_dom_DBSchema_h
+
+class mozIStorageConnection;
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class Registration;
+
+namespace db {
+
+using storage::utils::Expect;
+
+// Note, this cannot be executed within a transaction.
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn,
+                      int32_t aLatestSchemaVersion,
+                      const nsDependentCString aSql,
+                      Expect aExpect);
+
+// Note, this cannot be executed within a transaction.
+nsresult
+InitializeConnection(mozIStorageConnection* aConn);
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aArgs,
+         bool& firstRegistrationForOrigin,
+         Registration& aRegistration);
+
+nsresult
+GetTags(mozIStorageConnection* aConn,
+        const SyncGetTagsArgs& aArgs,
+        nsTArray<nsString>& aTags);
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<Registration>& aRegistrations);
+
+nsresult
+Remove(mozIStorageConnection* aConn,
+       const SyncRemoveArgs& aArgs,
+       nsString& aOrigin);
+
+nsresult
+ChangeState(mozIStorageConnection* aConn,
+            const SyncChangeStateArgs& aArgs,
+            Registration& aRegistration);
+
+// Note, this works best when its NOT executed within a transaction.
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn);
+
+// We will wipe out databases with schema versions less than this. Newer
+// versions will be migrated on open to the latest schema version.
+extern const int32_t kFirstShippedSchemaVersion;
+
+const uint32_t kPageSize = 4 * 1024;
+
+// Grow the database in chunks to reduce fragmentation
+const uint32_t kGrowthSize = 32 * 1024;
+const uint32_t kGrowthPages = kGrowthSize / kPageSize;
+static_assert(kGrowthSize % kPageSize == 0,
+              "Growth size must be multiple of page size");
+
+// Only release free pages when we have more than this limit
+extern const int32_t kMaxFreePages = kGrowthPages;
+
+} // namespace db
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DBSchema_h
diff --git a/dom/backgroundsync/PBackgroundSync.ipdl b/dom/backgroundsync/PBackgroundSync.ipdl
--- a/dom/backgroundsync/PBackgroundSync.ipdl
+++ b/dom/backgroundsync/PBackgroundSync.ipdl
@@ -5,24 +5,26 @@
 include protocol PBackground;
 
 include BackgroundSyncIPCTypes;
 
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
+namespace backgroundsync {
 
 protocol PBackgroundSync
 {
   manager PBackground;
 
 parent: // child -> parent messages
   async Request(nsID aRequestId, SyncOp aOp);
   async Shutdown();
 
 child: // parent -> child messages
   async Response(nsID requestId, SyncOpResponse aResponse);
   async __delete__();
 };
 
+} // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/QuotaClient.cpp b/dom/backgroundsync/QuotaClient.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/QuotaClient.cpp
@@ -0,0 +1,185 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "QuotaClient.h"
+#include "StorageManager.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/dom/quota/UsageInfo.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsIFile.h"
+#include "nsISimpleEnumerator.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::DebugOnly;
+using mozilla::dom::ContentParentId;
+using mozilla::dom::backgroundsync::StorageManager;
+using mozilla::dom::quota::Client;
+using mozilla::dom::quota::PersistenceType;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::UsageInfo;
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+class BackgroundSyncQuotaClient final : public Client
+{
+public:
+  virtual Type
+  GetType() override
+  {
+    return BACKGROUNDSYNC;
+  }
+
+  virtual nsresult
+  InitOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
+             const nsACString& aOrigin, UsageInfo* aUsageInfo) override
+  {
+    // The QuotaManager passes a nullptr UsageInfo if there is no quota being
+    // enforced against the origin.
+    if (!aUsageInfo) {
+      return NS_OK;
+    }
+
+    return GetUsageForOrigin(aPersistenceType, aGroup, aOrigin, aUsageInfo);
+  }
+
+  virtual nsresult
+  GetUsageForOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
+                    const nsACString& aOrigin, UsageInfo* aUsageInfo) override
+  {
+    MOZ_ASSERT(aUsageInfo);
+
+    QuotaManager* qm = QuotaManager::Get();
+    MOZ_ASSERT(qm);
+
+    nsCOMPtr<nsIFile> dir;
+    nsresult rv = qm->GetDirectoryForOrigin(aPersistenceType, aOrigin,
+                                            getter_AddRefs(dir));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dir->Append(NS_LITERAL_STRING(BACKGROUNDSYNC_DIRECTORY_NAME));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsISimpleEnumerator> entries;
+    rv = dir->GetDirectoryEntries(getter_AddRefs(entries));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool hasMore;
+    while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+           !aUsageInfo->Canceled()) {
+      nsCOMPtr<nsISupports> entry;
+      rv = entries->GetNext(getter_AddRefs(entry));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+
+      nsAutoString leafName;
+      rv = file->GetLeafName(leafName);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      bool isDir;
+      rv = file->IsDirectory(&isDir);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      if (isDir) {
+        NS_WARNING("Unknown BackgroundSync directory found!");
+        continue;
+      }
+
+      // Ignore transient sqlite files and marker files
+      if (leafName.EqualsLiteral("backgroundsync.sqlite-journal") ||
+          leafName.EqualsLiteral("backgroundsync.sqlite-shm") ||
+          leafName.Find(NS_LITERAL_CSTRING("backgroundsync.sqlite-mj"), false, 0, 0) == 0 ||
+          leafName.EqualsLiteral("context_open.marker")) {
+        continue;
+      }
+
+      if (leafName.EqualsLiteral("backgroundsync.sqlite") ||
+          leafName.EqualsLiteral("backgroundsync.sqlite-wal")) {
+        int64_t fileSize;
+        rv = file->GetFileSize(&fileSize);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+        MOZ_ASSERT(fileSize >= 0);
+
+        aUsageInfo->AppendToDatabaseUsage(fileSize);
+        continue;
+      }
+
+      NS_WARNING("Unknown BackgroundSync file found!");
+    }
+
+    return NS_OK;
+  }
+
+  virtual void
+  OnOriginClearCompleted(PersistenceType aPersistenceType,
+                         const nsACString& aOrigin) override
+  { }
+
+  virtual void
+  ReleaseIOThreadObjects() override
+  {
+    // Nothing to do here as the ClientContext handles cleaning everything up
+    // automatically.
+  }
+
+  virtual void
+  AbortOperations(const nsACString& aOrigin) override
+  {
+    AssertIsOnBackgroundThread();
+
+    StorageManager::Abort(aOrigin);
+  }
+
+  virtual void
+  AbortOperationsForProcess(ContentParentId aContentParentId) override
+  { }
+
+  virtual void
+  StartIdleMaintenance() override
+  { }
+
+  virtual void
+  StopIdleMaintenance() override
+  { }
+
+  virtual void
+  ShutdownWorkThreads() override
+  {
+    AssertIsOnBackgroundThread();
+
+    // spins the event loop and synchronously shuts down all StorageManagers.
+    StorageManager::ShutdownAll();
+  }
+
+private:
+  ~BackgroundSyncQuotaClient()
+  {
+    AssertIsOnBackgroundThread();
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncQuotaClient, override)
+};
+
+} // namespace
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+already_AddRefed<mozilla::dom::quota::Client> CreateQuotaClient()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<BackgroundSyncQuotaClient> ref = new BackgroundSyncQuotaClient();
+  return ref.forget();
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/QuotaClient.h b/dom/backgroundsync/QuotaClient.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/QuotaClient.h
@@ -0,0 +1,24 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_backgroundsync_QuotaClient_h
+#define mozilla_dom_backgroundsync_QuotaClient_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/quota/Client.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+already_AddRefed<mozilla::dom::quota::Client>
+CreateQuotaClient();
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_backgroundsync_QuotaClient_h
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -0,0 +1,780 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBAction.h"
+#include "StorageManager.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/StaticMutex.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+namespace {
+
+// ClientActions that are executed when a ClientContext is first created.
+// It ensures that the database is setup properly.
+// This lets other actions not worry about these details.
+class SetupAction final : public SyncDBAction
+{
+public:
+  SetupAction()
+    : SyncDBAction(DBAction::Create)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    // Executes in its own transaction.
+    nsresult rv = db::CreateOrMigrateSchema(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+};
+
+} // anonymous namespace
+
+// ---------------------------------------------------------------------------
+
+// Singleton class to track StorageManager instances and ensure there is only
+// one for each unique StorageManagerId.
+class StorageManager::Factory
+{
+public:
+  friend class StaticAutoPtr<StorageManager::Factory>;
+
+  static nsresult
+  GetOrCreate(StorageManagerId* aManagerId,
+              StorageManager** aManagerOut)
+  {
+    AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance. This forces the Get() call
+    // below to use the same factory.
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    RefPtr<StorageManager> ref = Get(aManagerId);
+    if (!ref) {
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("BSyncIOThread", getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      ref = new StorageManager(aManagerId, ioThread);
+
+      // There may be an old manager for this origin in the process of
+      // cleaning up.  We need to tell the new manager about this so
+      // that it won't actually start until the old manager is done.
+      RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
+      ref->Init(oldManager);
+
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<StorageManager>
+  Get(StorageManagerId* aManagerId, State aState = Open)
+  {
+    AssertIsOnBackgroundThread();
+
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    // Iterate in reverse to find the most recent, matching Manager. This
+    // is important when looking for a Closing Manager.  If a new Manager
+    // chains to an old Manager we want it to be the most recent one.
+    ManagerList::BackwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      RefPtr<StorageManager> manager = iter.GetNext();
+      if (aState == manager->GetState() && *manager->mManagerId == *aManagerId) {
+        return manager.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void
+  Remove(StorageManager* aManager)
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(sFactory);
+
+    MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
+
+    // Clean up the factory singleton if there are no more managers.
+    MaybeDestroyInstance();
+  }
+
+  static void
+  Abort(const nsACString& aOrigin)
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        if (aOrigin.IsVoid() ||
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
+          manager->Abort();
+        }
+      }
+    }
+  }
+
+  static void
+  ShutdownAll()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      // Note that we are synchronously calling shutdown code here. If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
+    }
+
+    MaybeDestroyInstance();
+  }
+
+  static bool
+  IsShutdownAllComplete()
+  {
+    AssertIsOnBackgroundThread();
+    return !sFactory;
+  }
+
+private:
+  Factory()
+    : mInSyncShutdown(false)
+  {
+    MOZ_COUNT_CTOR(StorageManager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(StorageManager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
+  }
+
+  static nsresult
+  MaybeCreateInstance()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // Be clear about what we are locking. sFactory is bg thread only, so
+      // we don't need to lock it here. Just protect sFactoryShutdown and
+      // sBackgroundThread.
+      {
+        StaticMutexAutoLock lock(sMutex);
+
+        if (sFactoryShutdown) {
+          return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+        }
+      }
+
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread. Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+
+    return NS_OK;
+  }
+
+  static void
+  MaybeDestroyInstance()
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(sFactory);
+
+    // If the factory is still in use then we cannot delete yet. This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down. We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
+    sFactory = nullptr;
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove(). PBackground thread only.
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Protects following static attribute.
+  static StaticMutex sMutex;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sMutex to access.
+  static bool sFactoryShutdown;
+
+  // Weak references as we don't want to keep StorageManager objects alive
+  // forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
+  typedef nsTObserverArray<StorageManager*> ManagerList;
+  ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
+};
+
+// static
+StaticAutoPtr<StorageManager::Factory> StorageManager::Factory::sFactory;
+
+// static
+StaticMutex StorageManager::Factory::sMutex;
+
+// static
+bool StorageManager::Factory::sFactoryShutdown = false;
+
+// ---------------------------------------------------------------------------
+
+// Abstract class to help implement the varios ClientActions.
+class StorageManager::BaseAction : public SyncDBAction
+{
+protected:
+  BaseAction(const nsID& aRequestId, StorageManager* aManager)
+    : SyncDBAction(DBAction::Existing)
+    , mRequestId(aRequestId)
+    , mManager(aManager)
+  {}
+
+  virtual void
+  Complete(nsresult aRv) = 0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) override
+  {
+    NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
+
+    Complete(aRv);
+
+    // Ensure we release the manager on the initiating thread.
+    mManager = nullptr;
+  }
+
+  const nsID mRequestId;
+  RefPtr<StorageManager> mManager;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::RegisterAction final : public StorageManager::BaseAction
+{
+public:
+  RegisterAction(const nsID& aRequestId,
+                 StorageManager* aManager,
+                 const SyncRegisterArgs& aRegisterArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aRegisterArgs)
+    , mFirstRegistration(true)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::Register(aConn, mArgs, mFirstRegistration,
+                               mRegistration);
+    NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "db::Register failed");
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete(mRequestId,
+        SyncOpError(static_cast<uint32_t>(aRv)));
+    } else {
+      mManager->OnRequestComplete(mRequestId,
+          SyncRegisterResponse(mRegistration, mFirstRegistration));
+    }
+  }
+
+private:
+  SyncRegisterArgs mArgs;
+  bool mFirstRegistration;
+  Registration mRegistration;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::GetTagsAction final : public StorageManager::BaseAction
+{
+public:
+  GetTagsAction(const nsID& aRequestId,
+                StorageManager* aManager,
+                const SyncGetTagsArgs& aGetTagsArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aGetTagsArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::GetTags(aConn, mArgs, mTags);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete(mRequestId,
+        SyncOpError(static_cast<uint32_t>(aRv)));
+    } else {
+      mManager->OnRequestComplete(mRequestId,
+        SyncGetTagsResponse(mTags));
+    }
+  }
+
+private:
+  SyncGetTagsArgs mArgs;
+  nsTArray<nsString> mTags;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::GetAllAction final : public StorageManager::BaseAction
+{
+public:
+  GetAllAction(const nsID& aRequestId,
+               StorageManager* aManager)
+    : BaseAction(aRequestId, aManager)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::GetAll(aConn, mRegistrations);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete(mRequestId,
+      SyncGetAllResponse(mRegistrations));
+  }
+
+private:
+  nsTArray<Registration> mRegistrations;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::RemoveAction final : public StorageManager::BaseAction
+{
+public:
+  RemoveAction(const nsID& aRequestId,
+               StorageManager* aManager,
+               const SyncRemoveArgs& aRemoveArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aRemoveArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::Remove(aConn, mArgs, mOrigin);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete(mRequestId,
+      SyncRemoveResponse(mOrigin));
+  }
+
+private:
+  SyncRemoveArgs mArgs;
+  nsString mOrigin;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::ChangeStateAction final : public StorageManager::BaseAction
+{
+public:
+  ChangeStateAction(const nsID& aRequestId,
+                   StorageManager* aManager,
+                   const SyncChangeStateArgs& aChangeStateArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aChangeStateArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::ChangeState(aConn, mArgs, mRegistration);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete(mRequestId,
+      SyncChangeStateResponse(mRegistration));
+  }
+
+private:
+  SyncChangeStateArgs mArgs;
+  Registration mRegistration;
+};
+
+// ---------------------------------------------------------------------------
+
+// static
+nsresult
+StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+                            StorageManager** aManagerOut)
+{
+  AssertIsOnBackgroundThread();
+  return Factory::GetOrCreate(aManagerId, aManagerOut);
+}
+
+// static
+void
+StorageManager::ShutdownAll()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  Factory::ShutdownAll();
+  while (!Factory::IsShutdownAllComplete()) {
+    if (!NS_ProcessNextEvent()) {
+      NS_WARNING("Something bad happened!");
+      break;
+    }
+  }
+}
+
+// static
+void
+StorageManager::Abort(const nsACString& aOrigin)
+{
+ mozilla::ipc::AssertIsOnBackgroundThread();
+
+ Factory::Abort(aOrigin);
+}
+
+StorageManager::StorageManager(StorageManagerId* aManagerId,
+                               nsIThread* aIOThread)
+  : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
+  , mContext(nullptr)
+  , mShuttingDown(false)
+  , mState(Open)
+{
+  MOZ_ASSERT(mManagerId);
+  MOZ_ASSERT(mIOThread);
+}
+
+StorageManager::~StorageManager()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mState == Closing);
+  MOZ_ASSERT(!mContext);
+
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
+}
+
+void
+StorageManager::Init(StorageManager* aOldManager)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  RefPtr<ClientContext> oldContext;
+  if (aOldManager) {
+    oldContext = aOldManager->mContext;
+  }
+
+  // Create the context immediately. Since there can at most be one
+  // ClientContext per StorageManager, this lets us cleanly call
+  // Factory::Remove() once the ClientContext goes away.
+  RefPtr<ClientAction> setupAction = new SetupAction();
+  RefPtr<ClientContext> ref =
+    ClientContext::Create(this, quota::Client::BACKGROUNDSYNC,
+                          NS_LITERAL_STRING("backgroundsync"),
+                          mIOThread, setupAction, oldContext);
+  mContext = ref;
+}
+
+void
+StorageManager::Abort()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+
+  // Note that we are closing to prevent any new requests from coming in and
+  // creating a new ClientContext. We must ensure all Contexts and IO
+  // operations are complete before shutdown proceeds.
+  NoteClosing();
+
+  // Cancel and only note that we are done after the context is cleaned up.
+  RefPtr<ClientContext> context = mContext;
+  context->CancelAll();
+}
+
+void
+StorageManager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  // Ignore duplicate attempts to shutdown. This can occur when we start a
+  // browser initiated shutdown and then run ~StorageManager() which also
+  // calls Shutdown().
+  if (mShuttingDown) {
+    return;
+  }
+
+  mShuttingDown = true;
+
+  // Note that we are closing to prevent any new requests from coming in and
+  // creating a new ClientContext. We must ensure all Contexts and IO
+  // operations are complete before shutdown proceeds.
+  NoteClosing();
+
+  // If there is a context, then cancel and only note that we are done after
+  // its cleaned up.
+  if (mContext) {
+    RefPtr<ClientContext> context = mContext;
+    context->CancelAll();
+  }
+}
+
+void
+StorageManager::NoteClosing()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  // This can be called more than once legitimately through different paths.
+  mState = Closing;
+}
+
+void
+StorageManager::RemoveClientContext(ClientContext* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+
+  // Wether the ClientContext destruction was triggered from the StorageManager
+  // going idle or the underlying storage being invalidated, we should know we
+  // are closing before the ClientContext is destroyed.
+  MOZ_ASSERT(mState == Closing);
+
+  mContext = nullptr;
+
+  // Once the context is gone, we can immediately remove ourself from the
+  // Factory list. We don't need to block shutdown by stayin in the list
+  // any more.
+  Factory::Remove(this);
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManager::GetPrincipal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIPrincipal> ref = mManagerId->Principal();
+  return ref.forget();
+}
+
+void
+StorageManager::MaybeAllowContextToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  // If we have an active context, but we have no more pending requests,
+  // then let it shut itself down. We must wait for all possible users
+  // of state information to complete before doing this.
+  RefPtr<ClientContext> context = mContext;
+  if (context && mPendingRequests.IsEmpty()) {
+    // Mark the StorageManager as invalid so that it won't get used again.
+    NoteClosing();
+
+    context->AllowToClose();
+  }
+}
+
+// Common to DOM and internal requests.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, ClientAction* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(aAction);
+
+  mPendingRequests.AppendElement(aRequestId);
+
+  if (NS_WARN_IF(mState == Closing)) {
+    OnRequestComplete(aRequestId,
+                      SyncOpError(static_cast<uint32_t>(NS_ERROR_ABORT)));
+    return;
+  }
+
+  RefPtr<ClientContext> context = mContext;
+  MOZ_ASSERT(!context->IsCanceled());
+
+  context->Dispatch(aAction);
+}
+
+// DOM request.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
+{
+  RefPtr<ClientAction> action;
+
+  switch(aOp.mArgs().type()) {
+    case SyncOpArgs::TSyncRegisterArgs:
+    {
+      action = new RegisterAction(aRequestId, this,
+                                  aOp.mArgs().get_SyncRegisterArgs());
+      break;
+    }
+    case SyncOpArgs::TSyncGetTagsArgs:
+    {
+      action = new GetTagsAction(aRequestId, this,
+                                 aOp.mArgs().get_SyncGetTagsArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync request");
+    }
+  }
+
+  ExecuteRequest(aRequestId, action);
+}
+
+// Internal request.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp)
+{
+  RefPtr<ClientAction> action;
+
+  switch(aOp.mArgs().type()) {
+    case SyncInternalOpArgs::TSyncGetAllArgs:
+    {
+      action = new GetAllAction(aRequestId, this);
+      break;
+    }
+    case SyncInternalOpArgs::TSyncChangeStateArgs:
+    {
+      action = new ChangeStateAction(aRequestId, this,
+                                     aOp.mArgs().get_SyncChangeStateArgs());
+      break;
+    }
+    case SyncInternalOpArgs::TSyncRemoveArgs:
+    {
+      action = new RemoveAction(aRequestId, this,
+                                aOp.mArgs().get_SyncRemoveArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync internal request");
+    }
+  }
+
+  ExecuteRequest(aRequestId, action);
+}
+
+// Common to DOM and internal responses.
+void
+StorageManager::OnRequestComplete(const nsID& aRequestId)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mPendingRequests.Contains(aRequestId));
+
+  mPendingRequests.RemoveElement(aRequestId);
+
+  MaybeAllowContextToClose();
+}
+
+template<typename T>
+void
+StorageManager::OnRequestComplete(const nsID& aRequestId, const T& aResponse)
+{
+  // XXX Notify listener
+
+  OnRequestComplete(aRequestId);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.h
@@ -0,0 +1,116 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManager_h
+#define mozilla_dom_StorageManager_h
+
+#include "mozilla/dom/quota/ClientContext.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using quota::ClientContext;
+
+/**
+ * The StorageManager class is responsible for managing the storage of sync
+ * requests. The DOM objects and IPC actors are basically just plumbing to
+ * get the request to the right StorageManager object running in the parent
+ * process.
+ *
+ * There should be exactly one StorageManager object for each origin or app
+ * using the BackgroundSync API. This uniqueness is defined by the
+ * StorageManagerId equality operator. The uniqueness is enforced by the
+ * Manager GetOrCreate() factory method.
+ *
+ * The StorageManager instances are kept alive by the BackgroundSyncService,
+ * which keeps a reference to the StorageManager dealing with a storage request
+ * until that request is completed or the actor requesting it is destroyed.
+ */
+
+class StorageManager final : public quota::ClientContext::Listener
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageManager, override)
+
+  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+                              StorageManager** aManagerOut);
+
+  enum State
+  {
+    Open,
+    Closing
+  };
+
+  State GetState() const
+  {
+    return mState;
+  }
+
+  already_AddRefed<StorageManagerId> GetManagerId() const
+  {
+    RefPtr<StorageManagerId> ref = mManagerId;
+    return ref.forget();
+  }
+
+  // Synchronously shutdown.  This spins the event loop.
+  static void ShutdownAll();
+
+  // Cancel actions for given origin or all actions if passed string is null.
+  static void Abort(const nsACString& aOrigin);
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // quota::ClientContext::Listener
+  virtual void NoteClosing() override;
+  virtual void RemoveClientContext(ClientContext* aContext) override;
+  virtual already_AddRefed<nsIPrincipal> GetPrincipal() const override;
+
+private:
+  class BaseAction;
+  class ChangeStateAction;
+  class Factory;
+  class GetAllAction;
+  class GetTagsAction;
+  class RegisterAction;
+  class RemoveAction;
+
+  StorageManager(StorageManagerId* aManagerId,
+                 nsIThread* aIOThread);
+  ~StorageManager();
+
+  void Init(StorageManager* aOldManager);
+  void Abort();
+  void Shutdown();
+
+  void MaybeAllowContextToClose();
+
+  void OnRequestComplete(const nsID& aRequestId);
+  template<typename T>
+  void OnRequestComplete(const nsID& aRequestId, const T& aResponse);
+
+  void ExecuteRequest(const nsID& aRequestId, ClientAction* aAction);
+  void ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp);
+
+  RefPtr<StorageManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+
+  // Weak reference cleared by RemoveClientContext() in ClientContext
+  // destructor.
+  ClientContext* MOZ_NON_OWNING_REF mContext;
+
+  bool mShuttingDown;
+  State mState;
+
+  // Keep a list of the request IDs coming from BackgroundSyncService.
+  nsTArray<nsID> mPendingRequests;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManager_h
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -0,0 +1,167 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManagerId.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+/**
+ * StorageManagerIdFactory
+ */
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManagerIdFactory> factory =
+    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewRunnableMethod(factory,
+                                              &StorageManagerIdFactory::Run)));
+
+  return factory.forget();
+}
+
+StorageManagerIdFactory::StorageManagerIdFactory(
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+  : mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(aListener);
+
+  mListenerList.AppendElement(aListener);
+}
+
+StorageManagerIdFactory::~StorageManagerIdFactory()
+{
+  // Since this is a Runnable that executes on multiple threads, its a race
+  // to see which thread de-refs us last. Therefore we cannot guarantee which
+  // thread we destruct on.
+
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+void
+StorageManagerIdFactory::Run()
+{
+  // Execute twice. First on the main thread and then back on the originating
+  // thread.
+
+  if (mManagerId) {
+    AssertIsOnBackgroundThread();
+
+    ListenerList::ForwardIterator iter(mListenerList);
+    while (iter.HasMore()) {
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+    }
+
+    // The listener must clear its reference in
+    // OnStorageManagerIdCreated().
+    MOZ_ASSERT(mListenerList.IsEmpty());
+
+    return;
+  }
+
+  AssertIsOnMainThread();
+
+  nsresult rv;
+  RefPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(mPrincipalInfo, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  rv = StorageManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(
+        NewRunnableMethod(this, &StorageManagerIdFactory::Run),
+        NS_DISPATCH_NORMAL));
+}
+
+void
+StorageManagerIdFactory::RemoveListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+
+  MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
+}
+
+/**
+ * StorageManagerId
+ */
+
+// static
+nsresult
+StorageManagerId::Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   // suffix
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<StorageManagerId> ref =
+    new StorageManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+StorageManagerId::StorageManagerId(nsIPrincipal* aPrincipal,
+                                   const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+StorageManagerId::~StorageManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -0,0 +1,95 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManagerId_h
+#define mozilla_dom_StorageManagerId_h
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::ipc::PrincipalInfo;
+
+class StorageManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const StorageManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  StorageManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~StorageManagerId();
+
+  StorageManagerId(const StorageManagerId&) = delete;
+  StorageManagerId& operator=(const StorageManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerId)
+};
+
+class StorageManagerIdFactory
+{
+public:
+  // An interface to be implemented by code wishing to use the
+  // StorageManagerIdFactory.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the StorageManagerIdFactory to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+  };
+
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
+
+  // The Listener must call RemoveListener() when
+  // OnStorageManagerIdCreated is called or when
+  // the Listener is destroyed.
+  void RemoveListener(Listener* aListener);
+
+  void Run();
+
+private:
+  StorageManagerIdFactory(Listener* aListener,
+                          const PrincipalInfo& aPrincipalInfo);
+  virtual ~StorageManagerIdFactory();
+
+  // Weak reference cleared by RemoveListener().
+  typedef nsTObserverArray<Listener*> ListenerList;
+  ListenerList mListenerList;
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<StorageManagerId> mManagerId;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerIdFactory)
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManagerId_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -1,21 +1,30 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.backgroundsync += [
-    'BackgroundSync.h'
+    'BackgroundSync.h',
+    'BackgroundSyncTypes.h',
+    'QuotaClient.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
-    'BackgroundSyncParent.cpp'
+    'BackgroundSyncParent.cpp',
+    'ChromeDBSchema.cpp',
+    'ChromeStorageManager.cpp',
+    'DBAction.cpp',
+    'DBSchema.cpp',
+    'QuotaClient.cpp',
+    'StorageManager.cpp',
+    'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/dom/quota/ActorsParent.cpp b/dom/quota/ActorsParent.cpp
--- a/dom/quota/ActorsParent.cpp
+++ b/dom/quota/ActorsParent.cpp
@@ -25,16 +25,17 @@
 
 #include <algorithm>
 #include "GeckoProfiler.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/dom/PContent.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
+#include "mozilla/dom/backgroundsync/QuotaClient.h"
 #include "mozilla/dom/cache/QuotaClient.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/quota/PQuotaParent.h"
 #include "mozilla/dom/quota/PQuotaRequestParent.h"
 #include "mozilla/dom/quota/PQuotaUsageRequestParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/IntegerRange.h"
@@ -3142,25 +3143,27 @@ QuotaManager::Init(const nsAString& aBas
   // Make a timer here to avoid potential failures later. We don't actually
   // initialize the timer until shutdown.
   mShutdownTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
   if (NS_WARN_IF(!mShutdownTimer)) {
     return NS_ERROR_FAILURE;
   }
 
   static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::DOMCACHE == 2 &&
-                Client::TYPE_MAX == 3, "Fix the registration!");
+                Client::BACKGROUNDSYNC == 3 && Client::TYPE_MAX == 4,
+                "Fix the registration!");
 
   MOZ_ASSERT(mClients.Capacity() == Client::TYPE_MAX,
              "Should be using an auto array with correct capacity!");
 
   // Register clients.
   mClients.AppendElement(indexedDB::CreateQuotaClient());
   mClients.AppendElement(asmjscache::CreateClient());
   mClients.AppendElement(cache::CreateQuotaClient());
+  mClients.AppendElement(backgroundsync::CreateQuotaClient());
 
   return NS_OK;
 }
 
 void
 QuotaManager::Shutdown()
 {
   AssertIsOnOwningThread();
diff --git a/dom/quota/Client.h b/dom/quota/Client.h
--- a/dom/quota/Client.h
+++ b/dom/quota/Client.h
@@ -13,16 +13,17 @@
 
 #include "PersistenceType.h"
 
 class nsIRunnable;
 
 #define IDB_DIRECTORY_NAME "idb"
 #define ASMJSCACHE_DIRECTORY_NAME "asmjs"
 #define DOMCACHE_DIRECTORY_NAME "cache"
+#define BACKGROUNDSYNC_DIRECTORY_NAME "backgroundsync"
 
 BEGIN_QUOTA_NAMESPACE
 
 class QuotaManager;
 class UsageInfo;
 
 // An abstract interface for quota manager clients.
 // Each storage API must provide an implementation of this interface in order
@@ -37,16 +38,17 @@ public:
   Release() = 0;
 
   enum Type {
     IDB = 0,
     //LS,
     //APPCACHE,
     ASMJS,
     DOMCACHE,
+    BACKGROUNDSYNC,
     TYPE_MAX
   };
 
   virtual Type
   GetType() = 0;
 
   static nsresult
   TypeToText(Type aType, nsAString& aText)
@@ -59,16 +61,20 @@ public:
       case ASMJS:
         aText.AssignLiteral(ASMJSCACHE_DIRECTORY_NAME);
         break;
 
       case DOMCACHE:
         aText.AssignLiteral(DOMCACHE_DIRECTORY_NAME);
         break;
 
+      case BACKGROUNDSYNC:
+        aText.AssignLiteral(BACKGROUNDSYNC_DIRECTORY_NAME);
+        break;
+
       case TYPE_MAX:
       default:
         NS_NOTREACHED("Bad id value!");
         return NS_ERROR_UNEXPECTED;
     }
 
     return NS_OK;
   }
@@ -80,16 +86,19 @@ public:
       aType = IDB;
     }
     else if (aText.EqualsLiteral(ASMJSCACHE_DIRECTORY_NAME)) {
       aType = ASMJS;
     }
     else if (aText.EqualsLiteral(DOMCACHE_DIRECTORY_NAME)) {
       aType = DOMCACHE;
     }
+    else if (aText.EqualsLiteral(BACKGROUNDSYNC_DIRECTORY_NAME)) {
+      aType = BACKGROUNDSYNC;
+    }
     else {
       return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
   }
 
   // Methods which are called on the IO thred.
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -508,18 +508,18 @@ BackgroundChildImpl::DeallocPGamepadTest
 #endif
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
-dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+dom::backgroundsync::PBackgroundSyncChild*
+BackgroundChildImpl::AllocPBackgroundSyncChild(const PrincipalInfo&)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -175,17 +175,17 @@ protected:
 
   virtual PGamepadTestChannelChild*
   AllocPGamepadTestChannelChild() override;
 
   virtual bool
   DeallocPGamepadTestChannelChild(PGamepadTestChannelChild* aActor) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -946,33 +946,39 @@ BackgroundParentImpl::DeallocPGamepadTes
 #ifdef MOZ_GAMEPAD
   MOZ_ASSERT(aActor);
   RefPtr<dom::GamepadTestChannelParent> parent =
     dont_AddRef(static_cast<dom::GamepadTestChannelParent*>(aActor));
 #endif
   return true;
 }
 
-mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+mozilla::dom::backgroundsync::PBackgroundSyncParent*
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  RefPtr<BackgroundSyncParent> agent =
+    new BackgroundSyncParent(aPrincipalInfo);
+  return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundSyncParent*>(aActor);
+  RefPtr<BackgroundSyncParent> parent =
+    dont_AddRef(static_cast<BackgroundSyncParent*>(aActor));
+  MOZ_ASSERT(parent);
+
   return true;
 }
 
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -203,17 +203,17 @@ protected:
 
   virtual PGamepadTestChannelParent*
   AllocPGamepadTestChannelParent() override;
 
   virtual bool
   DeallocPGamepadTestChannelParent(PGamepadTestChannelParent* aActor) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -105,17 +105,17 @@ parent:
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
   async PGamepadEventChannel();
 
   async PGamepadTestChannel();
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
