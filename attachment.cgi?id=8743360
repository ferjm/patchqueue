# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  dec8e9207c9a61f9d74660fa6e9d1d1235789495
Bug 1217544 - Implement one-off BackgroundSync API. Part 3: IPC. r=baku

diff --git a/dom/sync/BackgroundSync.cpp b/dom/sync/BackgroundSync.cpp
--- a/dom/sync/BackgroundSync.cpp
+++ b/dom/sync/BackgroundSync.cpp
@@ -1,85 +1,286 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSync.h"
+#include "BackgroundSyncChild.h"
 
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BackgroundSyncBinding.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
+#include "mozilla/unused.h"
 #include "mozilla/Preferences.h"
+#include "nsISupportsPrimitives.h"
 #include "nsIGlobalObject.h"
 #include "WorkerPrivate.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
 using namespace workers;
 
+// Helpers
+
+class SyncOpRunnable final : public nsIRunnable,
+                             public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  SyncOpRunnable(Promise* aPromise, nsAutoPtr<SyncOp>& aOp)
+    : mPromise(aPromise)
+    , mOp(aOp)
+  {
+    MOZ_ASSERT(mPromise);
+    MOZ_ASSERT(mOp);
+  }
+
+  void SetActor(BackgroundSyncChild* aActor)
+  {
+    MOZ_ASSERT(!mActor);
+    MOZ_ASSERT(aActor);
+    mActor = aActor;
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (mActor->IsActorDestroyed()) {
+      return NS_OK;
+    }
+
+    return mActor->ExecuteOp(mPromise, mOp);
+  }
+
+  NS_IMETHODIMP Cancel() override
+  {
+    mActor = nullptr;
+    mPromise = nullptr;
+    mOp = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~SyncOpRunnable() {}
+
+  RefPtr<Promise> mPromise;
+  nsAutoPtr<SyncOp> mOp;
+  RefPtr<BackgroundSyncChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(SyncOpRunnable, nsICancelableRunnable, nsIRunnable)
+
+class TeardownRunnable final : public nsIRunnable,
+                               public nsICancelableRunnable
+{
+public:
+  NS_DECL_ISUPPORTS
+
+  explicit TeardownRunnable(BackgroundSyncChild* aActor)
+    : mActor(aActor)
+  {
+    MOZ_ASSERT(mActor);
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    MOZ_ASSERT(mActor);
+    if (!mActor->IsActorDestroyed()) {
+      mActor->SendShutdown();
+    }
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP Cancel() override
+  {
+    mActor = nullptr;
+    return NS_OK;
+  }
+
+private:
+  ~TeardownRunnable() {};
+
+  RefPtr<BackgroundSyncChild> mActor;
+};
+
+NS_IMPL_ISUPPORTS(TeardownRunnable, nsICancelableRunnable, nsIRunnable)
+
+class BackgroundSyncFeature final : public workers::WorkerFeature
+{
+  // The manager keeps alive this feature.
+  BackgroundSync* MOZ_NON_OWNING_REF mManager;
+
+public:
+  explicit BackgroundSyncFeature(BackgroundSync* aManager)
+    : mManager(aManager)
+  {
+    MOZ_ASSERT(aManager);
+    MOZ_COUNT_CTOR(BackgroundSyncFeature);
+  }
+
+  virtual bool Notify(workers::Status aStatus) override
+  {
+    if (aStatus >= Closing) {
+      mManager->Shutdown();
+    }
+    return true;
+  }
+
+private:
+  ~BackgroundSyncFeature()
+  {
+    MOZ_COUNT_CTOR(BackgroundSyncFeature);
+  }
+};
+
+
 // BackgroundSync
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnMainThread(nsIGlobalObject* aGlobal,
-                                nsIPrincipal* aPrincipal,
-                                ErrorResult& aRv)
+                                   nsIPrincipal* aPrincipal,
+                                   ErrorResult& aRv)
 {
   MOZ_ASSERT(aGlobal);
   MOZ_ASSERT(aPrincipal);
   MOZ_ASSERT(NS_IsMainThread());
 
   PrincipalInfo principalInfo;
-  nsresult rv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    aRv.Throw(rv);
+  aRv = PrincipalToPrincipalInfo(aPrincipal, &principalInfo);
+  if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
+
+  // Register as observer for inner-window-destroyed.
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    aRv = obs->AddObserver(ref, "inner-window-destroyed",
+                           false /* ownsWeak */);
+    if (NS_WARN_IF(aRv.Failed())) {
+      return nullptr;
+    }
+  } else {
+    aRv.Throw(NS_ERROR_UNEXPECTED);
+    return nullptr;
+  }
+
+  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(aGlobal);
+  MOZ_ASSERT(window);
+  MOZ_ASSERT(window->IsInnerWindow());
+  ref->mInnerID = window->WindowID();
+
   return ref.forget();
 }
 
 // static
 already_AddRefed<BackgroundSync>
 BackgroundSync::CreateOnWorker(nsIGlobalObject* aGlobal,
                                WorkerPrivate* aWorkerPrivate)
 {
   MOZ_ASSERT(aWorkerPrivate);
   aWorkerPrivate->AssertIsOnWorkerThread();
 
   const PrincipalInfo& principalInfo = aWorkerPrivate->GetPrincipalInfo();
 
   RefPtr<BackgroundSync> ref = new BackgroundSync(aGlobal, principalInfo);
+
+  ref->mWorkerFeature = new BackgroundSyncFeature(ref);
+  if (NS_WARN_IF(!aWorkerPrivate->AddFeature(ref->mWorkerFeature))) {
+    ref->mWorkerFeature = nullptr;
+    return nullptr;
+  }
+
   return ref.forget();
 }
 
 BackgroundSync::BackgroundSync(nsIGlobalObject* aGlobal,
-                         const PrincipalInfo& aPrincipalInfo)
-  : mGlobal(aGlobal)
-  , mPrincipalInfo(new PrincipalInfo(aPrincipalInfo))
-{}
+                               const PrincipalInfo& aPrincipalInfo)
+  : mInnerID(0)
+  , mGlobal(aGlobal)
+  , mShuttingDown(false)
+  , mPrincipalInfo(MakeUnique<PrincipalInfo>(aPrincipalInfo))
+{
+#ifdef DEBUG
+  mThread = do_GetCurrentThread();
+#endif
+
+  MOZ_ASSERT(aGlobal);
+
+  // Register this component to PBackground.
+  PBackgroundChild* actor = BackgroundChild::GetForCurrentThread();
+  if (actor) {
+    ActorCreated(actor);
+  } else {
+    MOZ_ALWAYS_TRUE(BackgroundChild::GetOrCreateForCurrentThread(this));
+  }
+}
 
 BackgroundSync::~BackgroundSync()
-{}
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+  Shutdown();
+  MOZ_ASSERT(!mWorkerFeature);
+  MOZ_ASSERT(!mActor);
+}
 
+bool
+BackgroundSync::IsBackgroundSyncThread() {
+  return mThread == nsCOMPtr<nsIThread>(do_GetCurrentThread());
+};
+
+void
+BackgroundSync::Shutdown()
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  mShuttingDown = true;
+
+  nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+  if (obs) {
+    obs->RemoveObserver(this, "inner-window-destroyed");
+  }
+
+  if (mWorkerFeature) {
+    WorkerPrivate* workerPrivate = GetCurrentThreadWorkerPrivate();
+    MOZ_ASSERT(workerPrivate);
+    workerPrivate->AssertIsOnWorkerThread();
+    workerPrivate->RemoveFeature(mWorkerFeature);
+    mWorkerFeature = nullptr;
+  }
+
+  if (mActor) {
+    RefPtr<TeardownRunnable> runnable = new TeardownRunnable(mActor);
+    Unused << NS_WARN_IF(NS_FAILED(NS_DispatchToCurrentThread(runnable)));
+    mActor = nullptr;
+  }
+
+  mPendingOperations.Clear();
+}
+ 
 // Bindings methods.
 
 JSObject*
 BackgroundSync::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
 {
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
   return BackgroundSyncBinding::Wrap(aCx, this, aGivenProto);
 }
 
 // static
 bool
 BackgroundSync::PrefEnabled(JSContext* aCx, JSObject* aObj)
 {
   using mozilla::dom::workers::WorkerPrivate;
@@ -96,42 +297,126 @@ BackgroundSync::PrefEnabled(JSContext* a
   WorkerPrivate* workerPrivate = GetWorkerPrivateFromContext(aCx);
   if (!workerPrivate) {
     return false;
   }
 
   return workerPrivate->BackgroundSyncEnabled();
 }
 
-// WebIDL interace methods.
+// nsIIPCBackgroundChildCreateCallback methods.
+
+void
+BackgroundSync::ActorFailed()
+{
+  MOZ_CRASH("Failed to create a PBackgroundChild actor!");
+}
+
+void
+BackgroundSync::ActorCreated(PBackgroundChild* aActor)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+  MOZ_ASSERT(aActor);
+  MOZ_ASSERT(!mActor);
+
+  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  mActor = static_cast<BackgroundSyncChild*>(actor);
+  MOZ_ASSERT(mActor);
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
+    RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
+    MOZ_ASSERT(runnable);
+    runnable->SetActor(mActor);
+    if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
+      NS_WARNING("Failed to dispatch to the current thread");
+      mPendingOperations.Clear();
+      return;
+    }
+  }
+  mPendingOperations.Clear();
+}
+
+// nsIObserver
+
+NS_IMETHODIMP
+BackgroundSync::Observe(nsISupports* aSubject,
+                        const char* aTopic,
+                        const char16_t* aData)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!strcmp(aTopic, "inner-window-destroyed"));
+
+  nsCOMPtr<nsISupportsPRUint64> wrapper = do_QueryInterface(aSubject);
+  NS_ENSURE_TRUE(wrapper, NS_ERROR_FAILURE);
+
+  uint64_t innerID;
+  nsresult rv = wrapper->GetData(&innerID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (innerID != mInnerID) {
+    return NS_OK;
+  }
+
+  Shutdown();
+
+  return NS_OK;
+}
 
 already_AddRefed<Promise>
-BackgroundSync::Register(const nsAString& aName, ErrorResult& aRv)
+BackgroundSync::ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv)
 {
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
   RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
   if (NS_WARN_IF(aRv.Failed())) {
     return nullptr;
   }
 
+  nsAutoPtr<SyncOp> op(new SyncOp(*mPrincipalInfo, aArgs));
+  RefPtr<SyncOpRunnable> runnable = new SyncOpRunnable(p, op);
+
+  if (!mActor) {
+    mPendingOperations.AppendElement(runnable);
+    return p.forget();
+  }
+
+  runnable->SetActor(mActor);
+  nsresult rv = NS_DispatchToCurrentThread(runnable);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    p->MaybeReject(rv);
+  }
+
   return p.forget();
 }
 
+// WebIDL interface methods.
+
+already_AddRefed<Promise>
+BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
+{
+  MOZ_ASSERT(IsBackgroundSyncThread());
+
+  const SyncRegisterArgs args((nsString(aTag)));
+  return ExecuteOp(SyncOpArgs(args), aRv);
+}
+
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
-  RefPtr<Promise> p = Promise::Create(mGlobal, aRv);
-  if (NS_WARN_IF(aRv.Failed())) {
-    return nullptr;
-  }
+  MOZ_ASSERT(IsBackgroundSyncThread());
 
-  return p.forget();
+  const SyncGetTagsArgs args;
+  return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE(BackgroundSync, mGlobal)
 NS_IMPL_CYCLE_COLLECTING_ADDREF(BackgroundSync)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(BackgroundSync)
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(BackgroundSync)
   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
-  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsIIPCBackgroundChildCreateCallback)
+  NS_INTERFACE_MAP_ENTRY(nsIObserver)
 NS_INTERFACE_MAP_END
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/sync/BackgroundSync.h b/dom/sync/BackgroundSync.h
--- a/dom/sync/BackgroundSync.h
+++ b/dom/sync/BackgroundSync.h
@@ -2,49 +2,61 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSync_h
 #define mozilla_dom_BackgroundSync_h
 
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+
+#include "nsIIPCBackgroundChildCreateCallback.h"
+#include "nsIObserver.h"
 #include "nsIPrincipal.h"
 #include "nsWrapperCache.h"
 
 #include "mozilla/AlreadyAddRefed.h"
+#include "mozilla/dom/BindingDeclarations.h"
 #include "mozilla/ErrorResult.h"
-#include "mozilla/dom/BindingDeclarations.h"
 
 #include "nsCOMPtr.h"
 #include "jsapi.h"
 
 class nsIGlobalObject;
 
 namespace mozilla {
 
 namespace ipc {
   class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 namespace workers {
+  class WorkerFeature;
   class WorkerPrivate;
 } // namespace workers
 
 class Promise;
+class BackgroundSyncChild;
+class SyncOpRunnable;
+ 
+class BackgroundSync final : public nsIIPCBackgroundChildCreateCallback
+                           , public nsIObserver
+                           , public nsWrapperCache
+{
+  NS_DECL_NSIIPCBACKGROUNDCHILDCREATECALLBACK
+  NS_DECL_NSIOBSERVER
 
-class BackgroundSync final : public nsISupports
-                        , public nsWrapperCache
-{
 public:
   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
-  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(BackgroundSync)
-
+  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(
+      BackgroundSync, nsIIPCBackgroundChildCreateCallback)
+ 
   static already_AddRefed<BackgroundSync>
   CreateOnMainThread(nsIGlobalObject* aGlobal,
                      nsIPrincipal* aPrincipal,
                      ErrorResult& aRv);
 
   static already_AddRefed<BackgroundSync>
   CreateOnWorker(nsIGlobalObject* aGlobal,
                  workers::WorkerPrivate* aWorkerPrivate);
@@ -61,28 +73,46 @@ public:
   JSObject*
   WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;
 
   static bool PrefEnabled(JSContext* aCx, JSObject* aObj);
 
   // WebIDL interface methods.
 
   already_AddRefed<Promise>
-  Register(const nsAString& aName, ErrorResult& aRv);
+  Register(const nsAString& aTag, ErrorResult& aRv);
 
   already_AddRefed<Promise>
   GetTags(ErrorResult& aRv);
 
+  void Shutdown();
 private:
   BackgroundSync(nsIGlobalObject* aGlobal,
               const mozilla::ipc::PrincipalInfo& aPrincipalInfo);
 
   ~BackgroundSync();
 
+  bool IsBackgroundSyncThread();
+
+  already_AddRefed<Promise>
+  ExecuteOp(const SyncOpArgs& aArgs, ErrorResult& aRv);
+
+  uint64_t mInnerID;
+
   nsCOMPtr<nsIGlobalObject> mGlobal;
 
-  nsAutoPtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+  nsAutoPtr<workers::WorkerFeature> mWorkerFeature;
+
+  RefPtr<BackgroundSyncChild> mActor;
+
+  bool mShuttingDown;
+
+  UniquePtr<mozilla::ipc::PrincipalInfo> mPrincipalInfo;
+
+  nsCOMPtr<nsIThread> mThread;
+
+  nsTArray<RefPtr<SyncOpRunnable>> mPendingOperations;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSync_h
diff --git a/dom/sync/BackgroundSyncChild.cpp b/dom/sync/BackgroundSyncChild.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/BackgroundSyncChild.cpp
@@ -0,0 +1,130 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BackgroundSyncChild.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/PBackgroundChild.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+
+struct BackgroundSyncChild::PendingRequest final
+{
+  explicit PendingRequest(Promise* aPromise)
+    : mPromise(aPromise)
+  {}
+
+  RefPtr<Promise> mPromise;
+};
+
+BackgroundSyncChild::BackgroundSyncChild()
+  : mActorDestroyed(false)
+{
+}
+
+BackgroundSyncChild::~BackgroundSyncChild()
+{
+}
+
+void
+BackgroundSyncChild::ActorDestroy(ActorDestroyReason aWhy)
+{
+  mActorDestroyed = true;
+
+  // XXX Reject pending requests.
+/*  for (auto iter = mPendingRequests.Iter(); !iter.Done(); iter.Next()) {
+    PendingRequest* request = iter.Get();
+    if (NS_WARN_IF(!request)) {
+      continue;
+    }
+    request->mPromise->MaybeReject();
+  }
+*/
+  mPendingRequests.Clear();
+}
+
+nsresult
+BackgroundSyncChild::StorePendingRequest(Promise* aPromise, nsID& aID)
+{
+  nsresult rv;
+  nsCOMPtr<nsIUUIDGenerator> uuidGenerator =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsID id;
+  rv = uuidGenerator->GenerateUUIDInPlace(&id);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PendingRequest* request = new PendingRequest(aPromise);
+  mPendingRequests.Put(id, request);
+
+  aID = id;
+
+  return NS_OK;
+}
+
+Promise*
+BackgroundSyncChild::GetPendingRequest(const nsID& aID)
+{
+  PendingRequest* request = mPendingRequests.Get(aID);
+  if (NS_WARN_IF(!request)) {
+    return nullptr;
+  }
+
+  RefPtr<Promise> promise = request->mPromise;
+
+  mPendingRequests.Remove(const_cast<nsID&>(aID));
+  return promise;
+}
+
+nsresult
+BackgroundSyncChild::ExecuteOp(Promise* aPromise, SyncOp* aOp)
+{
+  if (mActorDestroyed) {
+    return NS_OK;
+  }
+
+  nsID requestId;
+  nsresult rv = StorePendingRequest(aPromise, requestId);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  Unused << SendRequest(requestId, *aOp);
+
+  return NS_OK;
+}
+
+bool
+BackgroundSyncChild::RecvResponse(const nsID& aRequestId,
+                                  const SyncOpResponse& aResponse)
+{
+  Promise* p = GetPendingRequest(aRequestId);
+  if (!p) {
+    return false;
+  }
+
+  switch(aResponse.type()) {
+    case SyncOpResponse::TSyncRegisterResponse:
+      p->MaybeResolve(true);
+      return true;
+    case SyncOpResponse::TSyncGetTagsResponse:
+      p->MaybeResolve(aResponse.get_SyncGetTagsResponse().mTags());
+      return true;
+    case SyncOpResponse::TSyncOpError:
+      p->MaybeReject(
+          static_cast<nsresult>(aResponse.get_SyncOpError().mCode()));
+      return true;
+    default:
+      MOZ_CRASH("Unknown BackgroundSync response");
+      return false;
+  }
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/BackgroundSyncChild.h b/dom/sync/BackgroundSyncChild.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/BackgroundSyncChild.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncChild_h
+#define mozilla_dom_BackgroundSyncChild_h
+
+#include "BackgroundSync.h"
+
+#include "mozilla/dom/PBackgroundSyncChild.h"
+
+#include "nsID.h"
+#include "nsClassHashtable.h"
+
+namespace mozilla {
+
+namespace ipc {
+class BackgroundChildImpl;
+} // namespace ipc
+
+namespace dom {
+
+class BackgroundSync;
+
+class BackgroundSyncChild final : public PBackgroundSyncChild
+{
+  friend class mozilla::ipc::BackgroundChildImpl;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncChild)
+
+  bool IsActorDestroyed() const
+  {
+    return mActorDestroyed;
+  }
+
+  nsresult ExecuteOp(Promise* aPromise, SyncOp* aOp);
+
+  virtual bool RecvResponse(const nsID& aRequestId,
+                            const SyncOpResponse& aResponse) override;
+
+private:
+  BackgroundSyncChild();
+  ~BackgroundSyncChild();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  nsresult StorePendingRequest(Promise* aPromise, nsID& aID);
+  Promise* GetPendingRequest(const nsID& aID);
+
+  bool mActorDestroyed;
+
+  struct PendingRequest;
+  nsClassHashtable<nsIDHashKey, PendingRequest> mPendingRequests;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncChild_h
diff --git a/dom/sync/BackgroundSyncIPCTypes.ipdlh b/dom/sync/BackgroundSyncIPCTypes.ipdlh
new file mode 100644
--- /dev/null
+++ b/dom/sync/BackgroundSyncIPCTypes.ipdlh
@@ -0,0 +1,54 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include PBackgroundSharedTypes;
+
+namespace mozilla {
+namespace dom {
+
+struct SyncRegisterArgs
+{
+  nsString mTag;
+};
+
+struct SyncGetTagsArgs
+{
+};
+
+union SyncOpArgs
+{
+  SyncRegisterArgs;
+  SyncGetTagsArgs;
+};
+
+struct SyncOp
+{
+  PrincipalInfo mPrincipal;
+  SyncOpArgs mArgs;
+};
+
+struct SyncRegisterResponse
+{
+  bool mSuccess;
+};
+
+struct SyncGetTagsResponse
+{
+  nsString[] mTags;
+};
+
+struct SyncOpError
+{
+  uint32_t mCode;
+};
+
+union SyncOpResponse
+{
+  SyncRegisterResponse;
+  SyncGetTagsResponse;
+  SyncOpError;
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/BackgroundSyncParent.cpp b/dom/sync/BackgroundSyncParent.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/BackgroundSyncParent.cpp
@@ -0,0 +1,73 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BackgroundSyncParent.h"
+
+#include "mozilla/unused.h"
+#include "mozilla/ipc/BackgroundParent.h"
+
+namespace mozilla {
+
+using namespace ipc;
+
+namespace dom {
+
+BackgroundSyncParent::BackgroundSyncParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+BackgroundSyncParent::~BackgroundSyncParent()
+{
+  AssertIsOnBackgroundThread();
+}
+
+void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+{
+  AssertIsOnBackgroundThread();
+}
+
+bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                       const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  switch(aOp.mArgs().type()) {
+    case SyncOpArgs::TSyncRegisterArgs:
+    {
+      // XXX Do registration.
+      const SyncRegisterResponse response(true);
+      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    case SyncOpArgs::TSyncGetTagsArgs:
+    {
+      //XXX Do GetTags.
+      nsTArray<nsString> tags;
+      const SyncGetTagsResponse response(tags);
+      Unused << SendResponse(aRequestId, response);
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync request");
+    }
+  }
+  return true;
+}
+
+bool BackgroundSyncParent::RecvShutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  Unused << Send__delete__(this);
+
+  return true;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/BackgroundSyncParent.h b/dom/sync/BackgroundSyncParent.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/BackgroundSyncParent.h
@@ -0,0 +1,44 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncParent_h
+#define mozilla_dom_BackgroundSyncParent_h
+
+#include "mozilla/dom/PBackgroundSyncParent.h"
+#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+
+#include "nsID.h"
+
+namespace mozilla {
+
+namespace ipc {
+class BackgroundParentImpl;
+} // namespace ipc
+
+namespace dom {
+
+class BackgroundSyncParent final : public PBackgroundSyncParent
+{
+  friend class mozilla::ipc::BackgroundParentImpl;
+
+public:
+  virtual bool RecvRequest(const nsID& aRequestId,
+                           const SyncOp& aOp) override;
+
+  virtual bool RecvShutdown() override;
+private:
+  BackgroundSyncParent();
+  ~BackgroundSyncParent();
+
+  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncParent_h
+
+
diff --git a/dom/sync/PBackgroundSync.ipdl b/dom/sync/PBackgroundSync.ipdl
new file mode 100644
--- /dev/null
+++ b/dom/sync/PBackgroundSync.ipdl
@@ -0,0 +1,28 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+include protocol PBackground;
+
+include BackgroundSyncIPCTypes;
+
+using struct nsID from "nsID.h";
+
+namespace mozilla {
+namespace dom {
+
+protocol PBackgroundSync
+{
+  manager PBackground;
+
+parent: // child -> parent messages
+  async Request(nsID aRequestId, SyncOp aOp);
+  async Shutdown();
+
+child: // parent -> child messages
+  async Response(nsID requestId, SyncOpResponse aResponse);
+  async __delete__();
+};
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -3,17 +3,24 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
-    'BackgroundSync.cpp'
+    'BackgroundSync.cpp',
+    'BackgroundSyncChild.cpp',
+    'BackgroundSyncParent.cpp'
+]
+
+IPDL_SOURCES += [
+    'BackgroundSyncIPCTypes.ipdlh',
+    'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
     '/dom/workers'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -2,16 +2,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundChildImpl.h"
 
 #include "ActorsChild.h" // IndexedDB
 #include "BroadcastChannelChild.h"
 #include "ServiceWorkerManagerChild.h"
+#include "BackgroundSyncChild.h"
 #include "FileDescriptorSetChild.h"
 #ifdef MOZ_WEBRTC
 #include "CamerasChild.h"
 #endif
 #include "mozilla/media/MediaChild.h"
 #include "mozilla/Assertions.h"
 #include "mozilla/dom/PBlobChild.h"
 #include "mozilla/dom/PFileSystemRequestChild.h"
@@ -64,16 +65,17 @@ namespace ipc {
 using mozilla::dom::UDPSocketChild;
 using mozilla::net::PUDPSocketChild;
 
 using mozilla::dom::asmjscache::PAsmJSCacheEntryChild;
 using mozilla::dom::cache::PCacheChild;
 using mozilla::dom::cache::PCacheStorageChild;
 using mozilla::dom::cache::PCacheStreamControlChild;
 using mozilla::dom::PNuwaChild;
+using mozilla::dom::BackgroundSyncChild;
 
 // -----------------------------------------------------------------------------
 // BackgroundChildImpl::ThreadLocal
 // -----------------------------------------------------------------------------
 
 BackgroundChildImpl::
 ThreadLocal::ThreadLocal()
   : mCurrentFileHandle(nullptr)
@@ -463,16 +465,36 @@ BackgroundChildImpl::DeallocPFileSystemR
 {
   // The reference is increased in FileSystemTaskBase::Start of
   // FileSystemTaskBase.cpp. We should decrease it after IPC.
   RefPtr<dom::FileSystemTaskChildBase> child =
     dont_AddRef(static_cast<dom::FileSystemTaskChildBase*>(aActor));
   return true;
 }
 
+// -----------------------------------------------------------------------------
+// Background Sync API
+// -----------------------------------------------------------------------------
+
+dom::PBackgroundSyncChild*
+BackgroundChildImpl::AllocPBackgroundSyncChild()
+{
+  RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
+  return agent.forget().take();
+}
+
+bool
+BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
+{
+  RefPtr<BackgroundSyncChild> child =
+    dont_AddRef(static_cast<BackgroundSyncChild*>(aActor));
+  MOZ_ASSERT(child);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 bool
 TestChild::Recv__delete__(const nsCString& aTestArg)
 {
   MOZ_RELEASE_ASSERT(aTestArg == mTestArg,
                      "BackgroundTest message was corrupted!");
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -160,16 +160,21 @@ protected:
   DeallocPQuotaChild(PQuotaChild* aActor) override;
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
+  virtual PBackgroundSyncChild*
+  AllocPBackgroundSyncChild() override;
+
+  virtual bool
+  DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
 
 public:
   nsAutoPtr<mozilla::dom::indexedDB::ThreadLocal> mIndexedDBThreadLocal;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -36,16 +36,17 @@
 #include "nsNetUtil.h"
 #include "nsIScriptSecurityManager.h"
 #include "nsProxyRelease.h"
 #include "mozilla/RefPtr.h"
 #include "nsThreadUtils.h"
 #include "nsTraceRefcnt.h"
 #include "nsXULAppAPI.h"
 #include "ServiceWorkerManagerParent.h"
+#include "BackgroundSyncParent.h"
 
 #ifdef DISABLE_ASSERTS_FOR_FUZZING
 #define ASSERT_UNLESS_FUZZING(...) do { } while (0)
 #else
 #define ASSERT_UNLESS_FUZZING(...) MOZ_ASSERT(false)
 #endif
 
 using mozilla::ipc::AssertIsOnBackgroundThread;
@@ -54,16 +55,17 @@ using mozilla::dom::cache::PCacheParent;
 using mozilla::dom::cache::PCacheStorageParent;
 using mozilla::dom::cache::PCacheStreamControlParent;
 using mozilla::dom::FileSystemBase;
 using mozilla::dom::FileSystemRequestParent;
 using mozilla::dom::MessagePortParent;
 using mozilla::dom::NuwaParent;
 using mozilla::dom::PMessagePortParent;
 using mozilla::dom::PNuwaParent;
+using mozilla::dom::BackgroundSyncParent;
 using mozilla::dom::UDPSocketParent;
 
 namespace {
 
 void
 AssertIsOnMainThread()
 {
   MOZ_ASSERT(NS_IsMainThread());
@@ -92,16 +94,17 @@ public:
 } // namespace
 
 namespace mozilla {
 namespace ipc {
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::BroadcastChannelParent;
 using mozilla::dom::ServiceWorkerRegistrationData;
+using mozilla::dom::BackgroundSyncParent;
 using mozilla::dom::workers::ServiceWorkerManagerParent;
 
 BackgroundParentImpl::BackgroundParentImpl()
 {
   AssertIsInMainProcess();
   AssertIsOnMainThread();
 
   MOZ_COUNT_CTOR(mozilla::ipc::BackgroundParentImpl);
@@ -885,16 +888,36 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
+mozilla::dom::PBackgroundSyncParent*
+BackgroundParentImpl::AllocPBackgroundSyncParent()
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+
+  return new BackgroundSyncParent();
+}
+
+bool
+BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
+{
+  AssertIsInMainProcess();
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aActor);
+
+  delete static_cast<BackgroundSyncParent*>(aActor);
+  return true;
+}
+
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   mozilla::ipc::AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -192,14 +192,19 @@ protected:
 
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
+  virtual PBackgroundSyncParent*
+  AllocPBackgroundSyncParent() override;
+
+  virtual bool
+  DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
 #endif // mozilla_ipc_backgroundparentimpl_h__
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -13,16 +13,17 @@ include protocol PCacheStorage;
 include protocol PCacheStreamControl;
 include protocol PFileDescriptorSet;
 include protocol PFileSystemRequest;
 include protocol PMessagePort;
 include protocol PCameras;
 include protocol PNuwa;
 include protocol PQuota;
 include protocol PServiceWorkerManager;
+include protocol PBackgroundSync;
 include protocol PUDPSocket;
 include protocol PVsync;
 
 include DOMTypes;
 include PBackgroundSharedTypes;
 include PBackgroundIDBSharedTypes;
 include PFileSystemParams;
 
@@ -40,16 +41,17 @@ using mozilla::dom::asmjscache::WritePar
 namespace mozilla {
 namespace ipc {
 
 sync protocol PBackground
 {
   manages PAsmJSCacheEntry;
   manages PBackgroundIDBFactory;
   manages PBackgroundIndexedDBUtils;
+  manages PBackgroundSync;
   manages PBackgroundTest;
   manages PBlob;
   manages PBroadcastChannel;
   manages PCache;
   manages PCacheStorage;
   manages PCacheStreamControl;
   manages PFileDescriptorSet;
   manages PFileSystemRequest;
@@ -95,16 +97,18 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
+  async PBackgroundSync();
+
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
   async PFileDescriptorSet(FileDescriptor fd);
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -141,16 +141,17 @@ if CONFIG['_MSC_VER']:
     # 'reinterpret_cast': conversion from 'DWORD' to 'HANDLE' of greater size
     SOURCES['BackgroundChildImpl.cpp'].flags += ['-wd4312']
     SOURCES['BackgroundParentImpl.cpp'].flags += ['-wd4312']
 
 LOCAL_INCLUDES += [
     '/caps',
     '/dom/broadcastchannel',
     '/dom/indexedDB',
+    '/dom/sync',
     '/dom/workers',
     '/media/webrtc/trunk',
     '/xpcom/build',
 ]
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
     'PBackground.ipdl',
