# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Parent  8f4d2d35cb317235f30f4e3738ad3df16d2f9f3f
Bug 1365674 - stylo: Simulate compute values failure for tests. r?hiro

diff --git a/dom/animation/Keyframe.h b/dom/animation/Keyframe.h
--- a/dom/animation/Keyframe.h
+++ b/dom/animation/Keyframe.h
@@ -30,16 +30,22 @@ struct PropertyValuePair
   // property values, we store the specified property value as a token stream
   // (string).
   nsCSSValue mValue;
 
   // The specified value when using the Servo backend.
   RefPtr<RawServoDeclarationBlock> mServoDeclarationBlock;
 
   bool operator==(const PropertyValuePair&) const;
+
+  // XXX
+  nsString mStringValue;
+
+  // XXX
+  bool mSimulateComputeValuesFailure;
 };
 
 /**
  * A single keyframe.
  *
  * This is the canonical form in which keyframe effects are stored and
  * corresponds closely to the type of objects returned via the getKeyframes()
  * API.
diff --git a/dom/animation/KeyframeEffectReadOnly.cpp b/dom/animation/KeyframeEffectReadOnly.cpp
--- a/dom/animation/KeyframeEffectReadOnly.cpp
+++ b/dom/animation/KeyframeEffectReadOnly.cpp
@@ -1223,16 +1223,17 @@ KeyframeEffectReadOnly::GetProperties(
   }
 }
 
 void
 KeyframeEffectReadOnly::GetKeyframes(JSContext*& aCx,
                                      nsTArray<JSObject*>& aResult,
                                      ErrorResult& aRv)
 {
+  printf_stderr("GetKeyFrames\n");
   MOZ_ASSERT(aResult.IsEmpty());
   MOZ_ASSERT(!aRv.Failed());
 
   if (!aResult.SetCapacity(mKeyframes.Length(), mozilla::fallible)) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return;
   }
 
@@ -1260,16 +1261,22 @@ KeyframeEffectReadOnly::GetKeyframes(JSC
     if (!ToJSValue(aCx, keyframeDict, &keyframeJSValue)) {
       aRv.Throw(NS_ERROR_FAILURE);
       return;
     }
 
     JS::Rooted<JSObject*> keyframeObject(aCx, &keyframeJSValue.toObject());
     for (const PropertyValuePair& propertyValue : keyframe.mPropertyValues) {
       nsAutoString stringValue;
+
+      if (KeyframeUtils::IsComputeValuesFailureKey(propertyValue)) {
+        printf_stderr("UUUUUUUUU %s\n", NS_ConvertUTF16toUTF8(stringValue).get());
+        stringValue = propertyValue.mStringValue;
+      }
+      
       if (isServo) {
         if (propertyValue.mServoDeclarationBlock) {
           Servo_DeclarationBlock_SerializeOneValue(
             propertyValue.mServoDeclarationBlock,
             propertyValue.mProperty, &stringValue);
         } else {
           RawServoAnimationValue* value =
             mBaseStyleValuesForServo.GetWeak(propertyValue.mProperty);
diff --git a/dom/animation/KeyframeUtils.cpp b/dom/animation/KeyframeUtils.cpp
--- a/dom/animation/KeyframeUtils.cpp
+++ b/dom/animation/KeyframeUtils.cpp
@@ -379,28 +379,23 @@ AppendStringOrStringSequenceToArray(JSCo
 
 static bool
 AppendValueAsString(JSContext* aCx,
                     nsTArray<nsString>& aValues,
                     JS::Handle<JS::Value> aValue);
 
 static PropertyValuePair
 MakePropertyValuePair(nsCSSPropertyID aProperty, const nsAString& aStringValue,
-                      nsCSSParser& aParser, nsIDocument* aDocument);
+                      nsCSSParser& aParser, nsIDocument* aDocument,
+                      bool aSimulateComputeValuesFailure);
 
 static bool
 HasValidOffsets(const nsTArray<Keyframe>& aKeyframes);
 
 static void
-MarkAsComputeValuesFailureKey(PropertyValuePair& aPair);
-
-static bool
-IsComputeValuesFailureKey(const PropertyValuePair& aPair);
-
-static void
 BuildSegmentsFromValueEntries(nsTArray<KeyframeValueEntry>& aEntries,
                               nsTArray<AnimationProperty>& aResult);
 
 static void
 GetKeyframeListFromPropertyIndexedKeyframe(JSContext* aCx,
                                            nsIDocument* aDocument,
                                            JS::Handle<JS::Value> aValue,
                                            nsTArray<Keyframe>& aResult,
@@ -606,16 +601,17 @@ KeyframeUtils::GetComputedKeyframeValues
     ->GetComputedKeyframeValuesFor(aKeyframes, aElement, aServoValues);
 }
 
 /* static */ nsTArray<ComputedKeyframeValues>
 KeyframeUtils::GetComputedKeyframeValues(const nsTArray<Keyframe>& aKeyframes,
                                          dom::Element* aElement,
                                          nsStyleContext* aStyleContext)
 {
+  printf_stderr("GetComputedKeyframeValues\n");
   MOZ_ASSERT(aStyleContext);
   MOZ_ASSERT(aElement);
 
   const size_t len = aKeyframes.Length();
   nsTArray<ComputedKeyframeValues> result(len);
 
   for (const Keyframe& frame : aKeyframes) {
     nsCSSPropertyIDSet propertiesOnThisKeyframe;
@@ -864,30 +860,27 @@ ConvertKeyframeSequence(JSContext* aCx,
                                   ListAllowance::eDisallow,
                                   propertyValuePairs)) {
         return false;
       }
     }
 
     for (PropertyValuesPair& pair : propertyValuePairs) {
       MOZ_ASSERT(pair.mValues.Length() == 1);
-      keyframe->mPropertyValues.AppendElement(
-        MakePropertyValuePair(pair.mProperty, pair.mValues[0], parser,
-                              aDocument));
-
       // When we go to convert keyframes into arrays of property values we
       // call StyleAnimation::ComputeValues. This should normally return true
       // but in order to test the case where it does not, BaseKeyframeDict
       // includes a chrome-only member that can be set to indicate that
       // ComputeValues should fail for shorthand property values on that
       // keyframe.
-      if (nsCSSProps::IsShorthand(pair.mProperty) &&
-          keyframeDict.mSimulateComputeValuesFailure) {
-        MarkAsComputeValuesFailureKey(keyframe->mPropertyValues.LastElement());
-      }
+      keyframe->mPropertyValues.AppendElement(
+        MakePropertyValuePair(pair.mProperty, pair.mValues[0], parser,
+                              aDocument,
+                              keyframeDict.mSimulateComputeValuesFailure)
+      );
     }
   }
 
   return true;
 }
 
 /**
  * Reads the property-values pairs from the specified JS object.
@@ -1021,23 +1014,31 @@ AppendValueAsString(JSContext* aCx,
  * @param aProperty The CSS property.
  * @param aStringValue The property value to parse.
  * @param aParser The CSS parser object to use.
  * @param aDocument The document to use when parsing.
  * @return The constructed PropertyValuePair object.
  */
 static PropertyValuePair
 MakePropertyValuePair(nsCSSPropertyID aProperty, const nsAString& aStringValue,
-                      nsCSSParser& aParser, nsIDocument* aDocument)
+                      nsCSSParser& aParser, nsIDocument* aDocument,
+                      bool aSimulateComputeValuesFailure)
 {
+  printf_stderr("MAKE PROP\n");
   MOZ_ASSERT(aDocument);
   PropertyValuePair result;
 
   result.mProperty = aProperty;
 
+  result.mSimulateComputeValuesFailure = aSimulateComputeValuesFailure;
+  if (nsCSSProps::IsShorthand(aProperty) &&
+      result.mSimulateComputeValuesFailure) {
+    result.mStringValue = aStringValue;
+  }
+
   if (aDocument->GetStyleBackendType() == StyleBackendType::Servo) {
     RefPtr<RawServoDeclarationBlock> servoDeclarationBlock =
       KeyframeUtils::ParseProperty(aProperty, aStringValue, aDocument);
 
     if (servoDeclarationBlock) {
       result.mServoDeclarationBlock = servoDeclarationBlock.forget();
     }
     return result;
@@ -1100,59 +1101,23 @@ HasValidOffsets(const nsTArray<Keyframe>
         return false;
       }
       offset = thisOffset;
     }
   }
   return true;
 }
 
-/**
- * Takes a property-value pair for a shorthand property and modifies the
- * value to indicate that when we call StyleAnimationValue::ComputeValues on
- * that value we should behave as if that function had failed.
- *
- * @param aPair The PropertyValuePair to modify. |aPair.mProperty| must be
- *              a shorthand property.
- */
-static void
-MarkAsComputeValuesFailureKey(PropertyValuePair& aPair)
+/* static */ bool
+KeyframeUtils::IsComputeValuesFailureKey(const PropertyValuePair& aPair)
 {
-  MOZ_ASSERT(nsCSSProps::IsShorthand(aPair.mProperty),
-             "Only shorthand property values can be marked as failure values");
-
-  // We store shorthand values as nsCSSValueTokenStream objects whose mProperty
-  // and mShorthandPropertyID are eCSSProperty_UNKNOWN and whose mTokenStream
-  // member contains the shorthand property's value as a string.
-  //
-  // We need to leave mShorthandPropertyID as eCSSProperty_UNKNOWN so that
-  // nsCSSValue::AppendToString returns the mTokenStream value, but we can
-  // update mPropertyID to a special value to indicate that this is
-  // a special failure sentinel.
-  nsCSSValueTokenStream* tokenStream = aPair.mValue.GetTokenStreamValue();
-  MOZ_ASSERT(tokenStream->mPropertyID == eCSSProperty_UNKNOWN,
-             "Shorthand value should initially have an unknown property ID");
-  tokenStream->mPropertyID = eCSSPropertyExtra_no_properties;
-}
-
-/**
- * Returns true if |aPair| is a property-value pair on which we have
- * previously called MarkAsComputeValuesFailureKey (and hence we should
- * simulate failure when calling StyleAnimationValue::ComputeValues using its
- * value).
- *
- * @param aPair The property-value pair to test.
- * @return True if |aPair| represents a failure value.
- */
-static bool
-IsComputeValuesFailureKey(const PropertyValuePair& aPair)
-{
-  return nsCSSProps::IsShorthand(aPair.mProperty) &&
-         aPair.mValue.GetTokenStreamValue()->mPropertyID ==
-           eCSSPropertyExtra_no_properties;
+  bool result = nsCSSProps::IsShorthand(aPair.mProperty) &&
+         aPair.mSimulateComputeValuesFailure;
+  printf_stderr("IS COMPUTED VALUE FAILUER %d\n", result);
+  return result;
 }
 
 static void
 AppendInitialSegment(AnimationProperty* aAnimationProperty,
                      const KeyframeValueEntry& aFirstEntry)
 {
   AnimationPropertySegment* segment =
     aAnimationProperty->mSegments.AppendElement();
@@ -1480,17 +1445,19 @@ GetKeyframeListFromPropertyIndexedKeyfra
       double offset = n ? i++ / double(n) : 1;
       Keyframe* keyframe = processedKeyframes.LookupOrAdd(offset);
       if (keyframe->mPropertyValues.IsEmpty()) {
         keyframe->mTimingFunction = easing;
         keyframe->mComposite = composite;
         keyframe->mComputedOffset = offset;
       }
       keyframe->mPropertyValues.AppendElement(
-        MakePropertyValuePair(pair.mProperty, stringValue, parser, aDocument));
+        MakePropertyValuePair(pair.mProperty, stringValue, parser, aDocument,
+                              false /* aSimulateComputeValuesFailure */)
+      );
     }
   }
 
   aResult.SetCapacity(processedKeyframes.Count());
   for (auto iter = processedKeyframes.Iter(); !iter.Done(); iter.Next()) {
     aResult.AppendElement(Move(*iter.UserData()));
   }
 
diff --git a/dom/animation/KeyframeUtils.h b/dom/animation/KeyframeUtils.h
--- a/dom/animation/KeyframeUtils.h
+++ b/dom/animation/KeyframeUtils.h
@@ -2,16 +2,17 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_KeyframeUtils_h
 #define mozilla_KeyframeUtils_h
 
+#include "Keyframe.h"
 #include "nsTArrayForwardDeclare.h" // For nsTArray
 #include "js/RootingAPI.h" // For JS::Handle
 #include "mozilla/KeyframeEffectParams.h" // SpacingMode
 
 struct JSContext;
 class JSObject;
 class nsIDocument;
 class nsStyleContext;
@@ -173,13 +174,25 @@ public:
    * @return The parsed value as a RawServoDeclarationBlock. We put the value
    *   in a declaration block since that is how we represent specified values
    *   in Servo.
    */
   static already_AddRefed<RawServoDeclarationBlock> ParseProperty(
     nsCSSPropertyID aProperty,
     const nsAString& aValue,
     nsIDocument* aDocument);
+  
+  /**
+   * Returns true if |aPair| is a property-value pair on which we have
+   * set the mSimulateComputeValuesFailure (and hence we should
+   * simulate failure when calling StyleAnimationValue::ComputeValues using its
+   * value).
+   *
+   * @param aPair The property-value pair to test.
+   * @return True if |aPair| represents a failure value.
+   */
+  static bool
+  IsComputeValuesFailureKey(const PropertyValuePair& aPair);
 };
 
 } // namespace mozilla
 
 #endif // mozilla_KeyframeUtils_h
