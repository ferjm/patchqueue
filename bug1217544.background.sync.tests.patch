# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  b5f346c43e92939591f35e6a004ac361342f7692
Bug 1217544 - Implement one-off BackgroundSync API. Tests. r=baku

diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -24,16 +24,24 @@ LOCAL_INCLUDES += [
     '/dom/workers',
     '/netwerk/base'
 ]
 
 XPIDL_SOURCES += [
     'nsISyncRegistry.idl'
 ]
 
+MOCHITEST_MANIFESTS += [
+    'tests/mochitest.ini'
+]
+
+XPCSHELL_TESTS_MANIFESTS += [
+    'tests/xpcshell.ini'
+]
+
 XPIDL_MODULE = 'dom_sync'
 
 EXTRA_COMPONENTS += [
     'SyncRegistry.js',
     'SyncRegistry.manifest'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
diff --git a/dom/sync/tests/mochitest.ini b/dom/sync/tests/mochitest.ini
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/mochitest.ini
@@ -0,0 +1,7 @@
+[DEFAULT]
+support-files=
+  test_utils.js
+  worker.js
+
+[test_basic.html]
+[test_preference.html]
diff --git a/dom/sync/tests/test_basic.html b/dom/sync/tests/test_basic.html
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_basic.html
@@ -0,0 +1,113 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Bug 1217544: Background Sync.
+
+Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/licenses/publicdomain/
+
+-->
+<head>
+  <title>Test for Bug 1217544</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SpawnTask.js"></script>
+  <script type="text/javascript" src="/tests/dom/sync/tests/test_utils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
+</head>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1217544">Mozilla Bug 1217544</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+
+<script class="testbody" type="text/javascript">
+
+  // Load chrome script to change offline status in the
+  // parent process.
+  var chromeScript = SpecialPowers.loadChromeScript(_ => {
+    var { classes: Cc, interfaces: Ci } = Components;
+    var ioService = Cc["@mozilla.org/network/io-service;1"]
+                      .getService(Ci.nsIIOService);
+    addMessageListener("change-status", function(offline) {
+      ioService.offline = offline;
+    });
+  });
+
+  function offlineObserver(res) {
+    this._res = res;
+  }
+  offlineObserver.prototype = {
+    _res: null,
+
+    observe: function(subject, topic, data) {
+      debug("observe: " + subject + " " + topic + " " + data);
+      if (topic === "network:offline-status-changed") {
+        var obsService = SpecialPowers.Cc["@mozilla.org/observer-service;1"]
+                           .getService(SpecialPowers.Ci.nsIObserverService);
+        obsService.removeObserver(this, topic);
+        this._res(null);
+      }
+    }
+  }
+
+  function changeOfflineState(offline) {
+    return new Promise(function(res, rej) {
+      var obsService = SpecialPowers.Cc["@mozilla.org/observer-service;1"]
+                         .getService(SpecialPowers.Ci.nsIObserverService);
+      obsService.addObserver(SpecialPowers.wrapCallbackObject(new offlineObserver(res)),
+                             "network:offline-status-changed",
+                             false);
+      chromeScript.sendAsyncMessage("change-status", offline);
+    });
+  }
+
+  var registration;
+  add_task(function* start() {
+    yield setupPrefs(true /* backgroundSyncEnabled */);
+    var url = "worker.js" + "?" + (Math.random());
+    registration = yield navigator.serviceWorker.register(url, {scope: "."});
+  });
+
+  add_task(function* goOffline() {
+    yield changeOfflineState(true);
+  });
+
+  add_task(function* subscribe() {
+    yield registration.sync.register("tag");
+    var tags = yield registration.sync.getTags();
+    is(tags.length, 1, "Should have 1 registered tag");
+    is(tags[0], "tag", "Should have a tag named 'tag' registered");
+  });
+
+  add_task(function* subscribeFromWorker() {
+    var result = yield sendRequestToWorker({
+      type: "subscribe"
+    });
+    is(result.tags.length, 2, "Should have 2 registered tags");
+    ok(result.tags.indexOf("workerTag") > -1,
+       "Should have a tag named 'workerTag' registered");
+  });
+
+  add_task(function* goOnline() {
+    yield changeOfflineState(false);
+  });
+
+  add_task(function* getSyncEvents() {
+    yield sendRequestToWorker({
+      type: "waitForEvents",
+      expectedEvents: ["tag", "workerTag"]
+    });
+  });
+
+  add_task(function* testNoRegistrations() {
+    var tags = yield registration.sync.getTags();
+    is(tags.length, 0, "Should have 0 registered tag");
+    yield unregisterWorker(".");
+  });
+
+</script>
+</body>
+</html>
diff --git a/dom/sync/tests/test_preference.html b/dom/sync/tests/test_preference.html
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_preference.html
@@ -0,0 +1,38 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Bug 1217544: Background Sync.
+
+Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/licenses/publicdomain/
+
+-->
+<head>
+  <title>Test for Bug 1217544</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SpawnTask.js"></script>
+  <script type="text/javascript" src="/tests/dom/sync/tests/test_utils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
+</head>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1217544">Mozilla Bug 1217544</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+
+<script class="testbody" type="text/javascript">
+
+  add_task(function* testPermission() {
+    yield setupPrefs(false /* backgroundSyncEnabled */);
+    var url = "worker.js" + "?" + (Math.random());
+    var registration = yield navigator.serviceWorker.register(url, {scope: "."});
+    is(registration.sync, undefined, "Background Sync API is undefined");
+    yield unregisterWorker(".");
+  });
+
+</script>
+</body>
+</html>
diff --git a/dom/sync/tests/test_sync_registry.js b/dom/sync/tests/test_sync_registry.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_sync_registry.js
@@ -0,0 +1,171 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+let {classes: Cc, interfaces: Ci, utils: Cu} = Components;
+
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+const registry = Cc["@mozilla.org/dom/sync/registry;1"]
+                  .createInstance(Ci.nsISyncRegistry);
+
+const registration1 = {
+  tag: "tag1",
+  scope: "scope1",
+  originSuffix: "originSuffix1"
+};
+
+add_test(function() {
+  do_print("= Sync Registry Tests =");
+
+  do_get_profile();
+
+  do_test_pending();
+
+  ok(registry);
+
+  const listener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistryListener]),
+    notifyAddSuccess() {
+      ok(false, "Unexpected notifyAddSuccess");
+    },
+    notifyGetAllSuccess(aRegistrations) {
+      ok(true, "Expected notifyGetAllSuccess");
+      equal(aRegistrations.length, 0, "No registrations");
+      do_test_finished();
+      run_next_test();
+    },
+    notifyChangeStateSuccess() {
+      ok(false, "Unexpected notifyChangeStateSuccess");
+    },
+    notifyError() {
+      ok(false, "Unexpected notifyError");
+    }
+  };
+
+  do_print("= Should have no registrations =");
+
+  registry.getAll(listener);
+});
+
+add_test(function() {
+  do_print("= Should add a new registration =");
+
+  do_test_pending();
+
+  const listener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistryListener]),
+    notifyAddSuccess() {
+      ok(true, "Expected notifyAddSuccess");
+      do_test_finished();
+      run_next_test();
+    },
+    notifyGetAllSuccess(aRegistrations) {
+      ok(false, "Unexpected notifyGetAllSuccess");
+    },
+    notifyChangeStateSuccess() {
+      ok(false, "Unexpected notifyChangeStateSuccess");
+    },
+    notifyError() {
+      ok(false, "Unexpected notifyError");
+    }
+  };
+
+  registry.add(registration1, listener);
+});
+
+add_test(function() {
+  do_print("= Should error adding a invalid registration =");
+
+  do_test_pending();
+
+  const listener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistryListener]),
+    notifyAddSuccess() {
+      ok(false, "Unexpected notifyAddSuccess");
+    },
+    notifyGetAllSuccess(aRegistrations) {
+      ok(false, "Unexpected notifyGetAllSuccess");
+    },
+    notifyChangeStateSuccess() {
+      ok(false, "Unexpected notifyChangeStateSuccess");
+    },
+    notifyError() {
+      ok(true, "Expected notifyError");
+      do_test_finished();
+      run_next_test();
+    }
+  };
+
+  registry.add({ tag: null }, listener);
+});
+
+add_test(function() {
+  do_print("= Should error adding same registration twice =");
+
+  do_test_pending();
+
+  const listener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistryListener]),
+    notifyAddSuccess() {
+      ok(false, "Unexpected notifyAddSuccess");
+    },
+    notifyGetAllSuccess(aRegistrations) {
+      ok(false, "Unexpected notifyGetAllSuccess");
+    },
+    notifyChangeStateSuccess() {
+      ok(false, "Unexpected notifyChangeStateSuccess");
+    },
+    notifyError() {
+      ok(true, "Expected notifyError");
+      do_test_finished();
+      run_next_test();
+    }
+  };
+
+  registry.add(registration1, listener);
+});
+
+add_test(function() {
+  do_print("= Should have one registration =");
+
+  do_test_pending();
+
+  let expectedGetAllSuccess = true;
+  let expectedChangeStateSuccess = false;
+
+  const listener = {
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsISyncRegistryListener]),
+    notifyAddSuccess() {
+      ok(false, "Unexpected notifyAddSuccess");
+    },
+    notifyGetAllSuccess(aRegistrations) {
+      ok(expectedGetAllSuccess, "Got notifyGetAllSuccess");
+      equal(aRegistrations.length, 1, "Should have one registration");
+      let registration = aRegistrations.queryElementAt(0, Ci.nsISyncRegistration);
+      equal(registration.tag, registration1.tag);
+      equal(registration.scope, registration1.scope);
+      equal(registration.state, Ci.nsISyncRegistry.STATE_PENDING);
+      equal(registration.lastChance, true);
+      notEqual(registration.id, undefined);
+
+      do_print("= Should have one registration =");
+
+      expectedChangeStateSuccess = true;
+      expectedGetAllSuccess = false;
+
+      registry.changeState(registration.id, Ci.nsISyncRegistry.STATE_FIRING, this);
+    },
+    notifyChangeStateSuccess(aRegistration) {
+      ok(expectedChangeStateSuccess, "Got notifyChangeStateSuccess");
+      do_test_finished();
+      run_next_test();
+    },
+    notifyError() {
+      ok(false, "Unexpected notifyError");
+    }
+  };
+
+  registry.getAll(listener);
+});
diff --git a/dom/sync/tests/test_utils.js b/dom/sync/tests/test_utils.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_utils.js
@@ -0,0 +1,41 @@
+function debug(str) {
+  console.log(str + "\n");
+}
+
+// Remove permissions and prefs when the test finishes.
+SimpleTest.registerCleanupFunction(() =>
+  new Promise(resolve => {
+    SpecialPowers.flushPermissions(_ => {
+      SpecialPowers.flushPrefEnv(resolve);
+    });
+  })
+);
+
+function setupPrefs(backgroundSyncEnabled) {
+  return new Promise(resolve => {
+    SpecialPowers.pushPrefEnv({"set": [
+      ["dom.backgroundSync.enabled", backgroundSyncEnabled],
+      ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+      ["dom.serviceWorkers.enabled", true],
+      ["dom.serviceWorkers.testing.enabled", true]
+      ]}, resolve);
+  });
+}
+
+function sendRequestToWorker(request) {
+  return navigator.serviceWorker.ready.then(registration => {
+    return new Promise((resolve, reject) => {
+      var channel = new MessageChannel();
+      channel.port1.onmessage = e => {
+        (e.data.error ? reject : resolve)(e.data);
+      };
+      registration.active.postMessage(request, [channel.port2]);
+    });
+  });
+}
+
+function unregisterWorker(scope) {
+  return navigator.serviceWorker.getRegistration(scope).then(registration => {
+    return registration.unregister();
+  });
+}
diff --git a/dom/sync/tests/worker.js b/dom/sync/tests/worker.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/worker.js
@@ -0,0 +1,61 @@
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/licenses/publicdomain/
+
+function assert(value, message) {
+  if (!value) {
+    throw new Error(message);
+  }
+}
+
+var waitForEventsPort;
+var expectedEvents;
+var receivedEvents = [];
+
+function checkExpectedEventsReceived() {
+  assert(waitForEventsPort);
+  assert(expectedEvents);
+
+  if (expectedEvents.toString() == receivedEvents.toString()) {
+    waitForEventsPort.postMessage({});
+  }
+}
+
+function reply(event, promise) {
+  event.waitUntil(Promise.resolve(promise).then(result => {
+    event.ports[0].postMessage(result);
+  }).catch(error => {
+    event.ports[0].postMessage({
+      error: String(error),
+    });
+  }));
+}
+
+self.addEventListener("message", function(event) {
+  switch (event.data.type) {
+    case "subscribe":
+      reply(event, self.registration.sync.register("workerTag").then(
+        () => {
+          return self.registration.sync.getTags();
+        }
+      ).then(tags => {
+        return {
+          tags: tags
+        };
+      }));
+      break;
+    case "waitForEvents":
+      waitForEventsPort = event.ports[0];
+      expectedEvents = event.data.expectedEvents;
+      checkExpectedEventsReceived();
+      break;
+    default:
+      reply(event, Promise.reject("Invalid message type: " + event.data.type));
+      break;
+  }
+});
+
+self.addEventListener("sync", function(event) {
+  console.log("Got sync event", event.tag);
+  receivedEvents.push(event.tag);
+  checkExpectedEventsReceived();
+});
diff --git a/dom/sync/tests/xpcshell.ini b/dom/sync/tests/xpcshell.ini
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/xpcshell.ini
@@ -0,0 +1,5 @@
+[DEFAULT]
+head =
+tail =
+
+[test_sync_registry.js]
