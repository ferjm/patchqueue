# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  f6e16b621a97f7bc8ba101f6cfa545da6d6fc6e7
Bug 1217544 - Implement one-off BackgroundSync API. Tests. r=baku

diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -24,16 +24,20 @@ LOCAL_INCLUDES += [
     '/dom/workers',
     '/netwerk/base'
 ]
 
 XPIDL_SOURCES += [
     'nsISyncRegistry.idl'
 ]
 
+MOCHITEST_MANIFESTS += [
+    'tests/mochitest.ini'
+]
+
 XPIDL_MODULE = 'dom_sync'
 
 EXTRA_COMPONENTS += [
     'SyncRegistry.js',
     'SyncRegistry.manifest'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
diff --git a/dom/sync/tests/mochitest.ini b/dom/sync/tests/mochitest.ini
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/mochitest.ini
@@ -0,0 +1,6 @@
+[DEFAULT]
+support-files=
+  test_utils.js
+  worker.js
+
+[test_backgroundsync_basic.html]
diff --git a/dom/sync/tests/test_backgroundsync_basic.html b/dom/sync/tests/test_backgroundsync_basic.html
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_backgroundsync_basic.html
@@ -0,0 +1,103 @@
+<!DOCTYPE HTML>
+<html>
+<!--
+Bug 1217544: Background Sync.
+
+Any copyright is dedicated to the Public Domain.
+http://creativecommons.org/licenses/publicdomain/
+
+-->
+<head>
+  <title>Test for Bug 1217544</title>
+  <script type="text/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
+  <script type="text/javascript" src="/tests/SimpleTest/SpawnTask.js"></script>
+  <script type="text/javascript" src="/tests/dom/sync/tests/test_utils.js"></script>
+  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
+  <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
+</head>
+<a target="_blank" href="https://bugzilla.mozilla.org/show_bug.cgi?id=1217544">Mozilla Bug 1217544</a>
+<p id="display"></p>
+<div id="content" style="display: none">
+
+</div>
+<pre id="test">
+</pre>
+
+<script class="testbody" type="text/javascript">
+
+  function debug(str) {
+    console.log(str + "\n");
+  }
+
+  SimpleTest.waitForExplicitFinish()
+
+  // Load chrome script to change offline status in the
+  // parent process.
+  var chromeScript = SpecialPowers.loadChromeScript(_ => {
+    var { classes: Cc, interfaces: Ci } = Components;
+    var ioService = Cc["@mozilla.org/network/io-service;1"]
+                      .getService(Ci.nsIIOService);
+    addMessageListener("change-status", function(offline) {
+      ioService.offline = offline;
+    });
+  });
+
+  function offlineObserver(res) {
+    this._res = res;
+  }
+  offlineObserver.prototype = {
+    _res: null,
+
+    observe: function(subject, topic, data) {
+      debug("observe: " + subject + " " + topic + " " + data);
+      if (topic === "network:offline-status-changed") {
+        var obsService = SpecialPowers.Cc["@mozilla.org/observer-service;1"]
+                           .getService(SpecialPowers.Ci.nsIObserverService);
+        obsService.removeObserver(this, topic);
+        this._res(null);
+      }
+    }
+  }
+
+  function changeOfflineState(offline) {
+    return new Promise(function(res, rej) {
+      var obsService = SpecialPowers.Cc["@mozilla.org/observer-service;1"]
+                         .getService(SpecialPowers.Ci.nsIObserverService);
+      obsService.addObserver(SpecialPowers.wrapCallbackObject(new offlineObserver(res)),
+                             "network:offline-status-changed",
+                             false);
+      chromeScript.sendAsyncMessage("change-status", offline);
+    });
+  }
+
+  add_task(function* goOffline() {
+    yield changeOfflineState(true);
+  });
+
+  var registration;
+  add_task(function* start() {
+    yield setupPrefs();
+    var url = "worker.js" + "?" + (Math.random());
+    registration = yield navigator.serviceWorker.register(url, {scope: "."});
+  });
+
+  add_task(function* subscribe() {
+    yield registration.sync.register("tag");
+    var tags = yield registration.sync.getTags();
+    is(tags.length, 1, "Should have 1 registered tag");
+    is(tags[0], "tag", "Should have a tag named 'tag' registered");
+  });
+
+  add_task(function* subscribeFromWorker() {
+    var result = yield sendRequestToWorker({
+      type: "subscribe"
+    });
+    is(result.tags.length, 2, "Should have 2 registered tags");
+    ok(result.tags.indexOf("workerTag") > -1,
+       "Should have a tag named 'workerTag' registered");
+    yield unregisterWorker(".");
+  });
+
+</script>
+</body>
+</html>
diff --git a/dom/sync/tests/test_utils.js b/dom/sync/tests/test_utils.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/test_utils.js
@@ -0,0 +1,37 @@
+// Remove permissions and prefs when the test finishes.
+SimpleTest.registerCleanupFunction(() =>
+  new Promise(resolve => {
+    SpecialPowers.flushPermissions(_ => {
+      SpecialPowers.flushPrefEnv(resolve);
+    });
+  })
+);
+
+function setupPrefs() {
+  return new Promise(resolve => {
+    SpecialPowers.pushPrefEnv({"set": [
+      ["dom.backgroundsync.enabled", true],
+      ["dom.serviceWorkers.exemptFromPerDomainMax", true],
+      ["dom.serviceWorkers.enabled", true],
+      ["dom.serviceWorkers.testing.enabled", true]
+      ]}, resolve);
+  });
+}
+
+function sendRequestToWorker(request) {
+  return navigator.serviceWorker.ready.then(registration => {
+    return new Promise((resolve, reject) => {
+      var channel = new MessageChannel();
+      channel.port1.onmessage = e => {
+        (e.data.error ? reject : resolve)(e.data);
+      };
+      registration.active.postMessage(request, [channel.port2]);
+    });
+  });
+}
+
+function unregisterWorker(scope) {
+  return navigator.serviceWorker.getRegistration(scope).then(registration => {
+    return registration.unregister();
+  });
+}
diff --git a/dom/sync/tests/worker.js b/dom/sync/tests/worker.js
new file mode 100644
--- /dev/null
+++ b/dom/sync/tests/worker.js
@@ -0,0 +1,37 @@
+// Any copyright is dedicated to the Public Domain.
+// http://creativecommons.org/licenses/publicdomain/
+
+function assert(value, message) {
+  if (!value) {
+    throw new Error(message);
+  }
+}
+
+function reply(event, promise) {
+  event.waitUntil(Promise.resolve(promise).then(result => {
+    event.ports[0].postMessage(result);
+  }).catch(error => {
+    event.ports[0].postMessage({
+      error: String(error),
+    });
+  }));
+}
+
+this.onmessage = function(event) {
+  switch (event.data.type) {
+    case "subscribe":
+      reply(event, self.registration.sync.register("workerTag").then(
+        () => {
+          return self.registration.sync.getTags();
+        }
+      ).then(tags => {
+        return {
+          tags: tags
+        };
+      }));
+      break;
+    default:
+      reply(event, Promise.reject("Invalid message type: " + event.data.type));
+      break;
+  }
+};
