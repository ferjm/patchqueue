# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  01782c62ad21050a8e6acd295909696f64298558

diff --git a/dom/backgroundsync/ChromeDBSchema.cpp b/dom/backgroundsync/ChromeDBSchema.cpp
--- a/dom/backgroundsync/ChromeDBSchema.cpp
+++ b/dom/backgroundsync/ChromeDBSchema.cpp
@@ -1,57 +1,81 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ChromeDBSchema.h"
-#include "DBSchemaUtils.h"
+#include "DBCommon.h"
 
 #include "ipc/IPCMessageUtils.h"
+#include "mozilla/storage.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "mozStorageHelper.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 namespace chromedb {
 
-const int32_t kFirstShippedSchemaVersion = 1;
+using namespace mozilla::dom::backgroundsync::dbcommon;
+
+using storage::utils::Expect;
+using storage::utils::Migration;
 
 namespace {
 
 // Update this whenever the DB schema is changed.
 const int32_t kLatestSchemaVersion = 1;
 
+// We will wipe out databases with schema versions less than this. Newer
+// versions will be migrated on open to the latest schema version.
+const int32_t kFirstShippedSchemaVersion = 1;
+
 // ---------
-const char* const kTableRegistrations =
+const char* const kTableOrigins =
   "CREATE TABLE origins ("
     "origin TEXT NOT NULL PRIMARY KEY"
   ")";
 // ---------
 // End schema definition
 // ---------
 
 } // namespace
 
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn)
 {
-  return dbutils::CreateOrMigrateSchema(aConn, kLatestSchemaVersion,
-                                        kTableRegistrations,
-                                        "origins");
+  nsTArray<nsCString> tablesSql;
+  tablesSql.AppendElement(nsCString(kTableOrigins));
+
+  nsTArray<Expect> expect;
+  expect.AppendElement(Expect("origins", "table", kTableOrigins));
+  expect.AppendElement(Expect("sqlite_autoindex_origins_1", "index"));
+
+  return storage::utils::CreateOrMigrateSchema(aConn,
+                                               kFirstShippedSchemaVersion,
+                                               kLatestSchemaVersion, tablesSql,
+                                               expect, nsTArray<Migration>());
 }
 
 nsresult
 InitializeConnection(mozIStorageConnection* aConn)
 {
-  return dbutils::InitializeConnection(aConn);
+  return storage::utils::InitializeConnection(aConn, kPageSize, kGrowthSize,
+                                              kWalAutoCheckpointPages,
+                                              kWalAutoCheckpointSize);
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return storage::utils::IncrementalVacuum(aConn, kMaxFreePages);
 }
 
 nsresult
 Register(mozIStorageConnection* aConn,
          const nsAString& aOrigin)
 {
   MOZ_ASSERT(!NS_IsMainThread());
   MOZ_ASSERT(aConn);
@@ -119,18 +143,12 @@ GetAll(mozIStorageConnection* aConn,
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     aOrigins.AppendElement(origin);
   }
 
   return rv;
 }
 
-nsresult
-IncrementalVacuum(mozIStorageConnection* aConn)
-{
-  return dbutils::IncrementalVacuum(aConn);
-}
-
 } // namespace chromedb
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/ChromeDBSchema.h b/dom/backgroundsync/ChromeDBSchema.h
--- a/dom/backgroundsync/ChromeDBSchema.h
+++ b/dom/backgroundsync/ChromeDBSchema.h
@@ -34,18 +34,14 @@ Unregister(mozIStorageConnection* aConn,
 nsresult
 GetAll(mozIStorageConnection* aConn,
        nsTArray<nsString>& aOrigins);
 
 // Note, this works best when its NOT executed within a transaction.
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn);
 
-// We will wipe out databases with schema versions less than this. Newer
-// versions will be migrated on open to the latest schema version.
-extern const int32_t kFirstShippedSchemaVersion;
-
 } // namespace chromedb
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ChromeDBSchema_h
diff --git a/dom/backgroundsync/DBAction.cpp b/dom/backgroundsync/DBAction.cpp
--- a/dom/backgroundsync/DBAction.cpp
+++ b/dom/backgroundsync/DBAction.cpp
@@ -1,20 +1,20 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "DBAction.h"
-#include "DBConnection.h"
 #include "DBSchema.h"
 
 #include "mozilla/dom/quota/PersistenceType.h"
 #include "mozilla/net/nsFileProtocolHandler.h"
+#include "mozilla/storage.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageService.h"
 #include "mozStorageCID.h"
 #include "nsIFile.h"
 #include "nsIURI.h"
 #include "nsIFileURL.h"
 #include "nsThreadUtils.h"
 
@@ -79,17 +79,18 @@ DBAction::RunOnTarget(Resolver* aResolve
     // Save this connection in the shared Data object so later ClientActions
     // can use it.  This avoids opening a new connection for every
     // ClientAction.
     if (aOptionalData) {
       // Since we know this connection will be around for as long as the
       // storage is open, use our special wrapped connection class.  This
       // will let us perform certain operations once the storage origin
       // is closed.
-      nsCOMPtr<mozIStorageConnection> wrapped = new DBConnection(conn);
+      nsCOMPtr<mozIStorageConnection> wrapped =
+        new storage::IncrementalVacuumConnection(conn, db::kMaxFreePages);
       aOptionalData->SetConnection(wrapped);
     }
   }
 
   RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
 }
 
 nsresult
diff --git a/dom/backgroundsync/DBCommon.h b/dom/backgroundsync/DBCommon.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBCommon.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSync_DBCommon_h
+#define mozilla_dom_BackgroundSync_DBCommon_h
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace dbcommon {
+
+const uint32_t kPageSize = 4 * 1024;
+
+// Grow the database in chunks to reduce fragmentation
+const uint32_t kGrowthSize = 32 * 1024;
+const uint32_t kGrowthPages = kGrowthSize / kPageSize;
+static_assert(kGrowthSize % kPageSize == 0,
+              "Growth size must be multiple of page size");
+
+// Only release free pages when we have more than this limit
+const int32_t kMaxFreePages = kGrowthPages;
+
+const uint32_t kWalAutoCheckpointSize = 512 * 1024;
+const uint32_t kWalAutoCheckpointPages = kWalAutoCheckpointSize / kPageSize;
+static_assert(kWalAutoCheckpointSize % kPageSize == 0,
+              "WAL checkpoint size must be multiple of page size");
+
+} // namespace dbcommon
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSync_DBCommon_h
diff --git a/dom/backgroundsync/DBConnection.cpp b/dom/backgroundsync/DBConnection.cpp
deleted file mode 100644
--- a/dom/backgroundsync/DBConnection.cpp
+++ /dev/null
@@ -1,287 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "DBConnection.h"
-#include "DBSchema.h"
-
-#include "mozStorageHelper.h"
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-
-using quota::QuotaObject;
-
-NS_IMPL_ISUPPORTS(DBConnection, mozIStorageAsyncConnection,
-                  mozIStorageConnection);
-
-DBConnection::DBConnection(mozIStorageConnection* aBase)
-  : mBase(aBase)
-  , mClosed(false)
-{
-  MOZ_ASSERT(mBase);
-}
-
-DBConnection::~DBConnection()
-{
-  NS_ASSERT_OWNINGTHREAD(DBConnection);
-  MOZ_ALWAYS_SUCCEEDS(Close());
-}
-
-NS_IMETHODIMP
-DBConnection::Close()
-{
-  NS_ASSERT_OWNINGTHREAD(DBConnection);
-
-  if (mClosed) {
-    return NS_OK;
-  }
-  mClosed = true;
-
-  // If we are closing here, then we must not have a transaction
-  // open anywhere else. This should be guaranteed to succeed.
-  MOZ_ALWAYS_SUCCEEDS(dbutils::IncrementalVacuum(this));
-
-  return mBase->Close();
-}
-
-// The following methods are all boilerplate that either forward to the
-// base connection or block the method. All the async execution methods
-// are blocked because we do not use them and they would require more
-// work to wrap properly.
-
-// mozIStorageAsyncConnection methods
-
-NS_IMETHODIMP
-DBConnection::AsyncClose(mozIStorageCompletionCallback*)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::AsyncClone(bool, mozIStorageCompletionCallback*)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::GetDatabaseFile(nsIFile** aFileOut)
-{
-  return mBase->GetDatabaseFile(aFileOut);
-}
-
-NS_IMETHODIMP
-DBConnection::CreateAsyncStatement(const nsACString&, mozIStorageAsyncStatement**)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::ExecuteAsync(mozIStorageBaseStatement**, uint32_t,
-                           mozIStorageStatementCallback*,
-                           mozIStoragePendingStatement**)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::ExecuteSimpleSQLAsync(const nsACString&,
-                                    mozIStorageStatementCallback*,
-                                    mozIStoragePendingStatement**)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::CreateFunction(const nsACString& aFunctionName,
-                             int32_t aNumArguments,
-                             mozIStorageFunction* aFunction)
-{
-  // async methods are not supported.
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-DBConnection::CreateAggregateFunction(const nsACString& aFunctionName,
-                                      int32_t aNumArguments,
-                                      mozIStorageAggregateFunction* aFunction)
-{
-  return mBase->CreateAggregateFunction(aFunctionName, aNumArguments,
-                                        aFunction);
-}
-
-NS_IMETHODIMP
-DBConnection::RemoveFunction(const nsACString& aFunctionName)
-{
-  return mBase->RemoveFunction(aFunctionName);
-}
-
-NS_IMETHODIMP
-DBConnection::SetProgressHandler(int32_t aGranularity,
-                                 mozIStorageProgressHandler* aHandler,
-                                 mozIStorageProgressHandler** aHandlerOut)
-{
-  return mBase->SetProgressHandler(aGranularity, aHandler, aHandlerOut);
-}
-
-NS_IMETHODIMP
-DBConnection::RemoveProgressHandler(mozIStorageProgressHandler** aHandlerOut)
-{
-  return mBase->RemoveProgressHandler(aHandlerOut);
-}
-
-// mozIStorageConnection methods
-
-NS_IMETHODIMP
-DBConnection::Clone(bool aReadOnly, mozIStorageConnection** aConnectionOut)
-{
-  nsCOMPtr<mozIStorageConnection> conn;
-  nsresult rv = mBase->Clone(aReadOnly, getter_AddRefs(conn));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  nsCOMPtr<mozIStorageConnection> wrapped = new DBConnection(conn);
-  wrapped.forget(aConnectionOut);
-
-  return rv;
-}
-
-NS_IMETHODIMP
-DBConnection::GetDefaultPageSize(int32_t* aSizeOut)
-{
-  return mBase->GetDefaultPageSize(aSizeOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetConnectionReady(bool* aReadyOut)
-{
-  return mBase->GetConnectionReady(aReadyOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetLastInsertRowID(int64_t* aRowIdOut)
-{
-  return mBase->GetLastInsertRowID(aRowIdOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetAffectedRows(int32_t* aCountOut)
-{
-  return mBase->GetAffectedRows(aCountOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetLastError(int32_t* aErrorOut)
-{
-  return mBase->GetLastError(aErrorOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetLastErrorString(nsACString& aErrorOut)
-{
-  return mBase->GetLastErrorString(aErrorOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetSchemaVersion(int32_t* aVersionOut)
-{
-  return mBase->GetSchemaVersion(aVersionOut);
-}
-
-NS_IMETHODIMP
-DBConnection::SetSchemaVersion(int32_t aVersion)
-{
-  return mBase->SetSchemaVersion(aVersion);
-}
-
-NS_IMETHODIMP
-DBConnection::CreateStatement(const nsACString& aQuery,
-                              mozIStorageStatement** aStatementOut)
-{
-  return mBase->CreateStatement(aQuery, aStatementOut);
-}
-
-NS_IMETHODIMP
-DBConnection::ExecuteSimpleSQL(const nsACString& aQuery)
-{
-  return mBase->ExecuteSimpleSQL(aQuery);
-}
-
-NS_IMETHODIMP
-DBConnection::TableExists(const nsACString& aTableName, bool* aExistsOut)
-{
-  return mBase->TableExists(aTableName, aExistsOut);
-}
-
-NS_IMETHODIMP
-DBConnection::IndexExists(const nsACString& aIndexName, bool* aExistsOut)
-{
-  return mBase->IndexExists(aIndexName, aExistsOut);
-}
-
-NS_IMETHODIMP
-DBConnection::GetTransactionInProgress(bool* aResultOut)
-{
-  return mBase->GetTransactionInProgress(aResultOut);
-}
-
-NS_IMETHODIMP
-DBConnection::BeginTransaction()
-{
-  return mBase->BeginTransaction();
-}
-
-NS_IMETHODIMP
-DBConnection::BeginTransactionAs(int32_t aType)
-{
-  return mBase->BeginTransactionAs(aType);
-}
-
-NS_IMETHODIMP
-DBConnection::CommitTransaction()
-{
-  return mBase->CommitTransaction();
-}
-
-NS_IMETHODIMP
-DBConnection::RollbackTransaction()
-{
-  return mBase->RollbackTransaction();
-}
-
-NS_IMETHODIMP
-DBConnection::CreateTable(const char* aTable, const char* aSchema)
-{
-  return mBase->CreateTable(aTable, aSchema);
-}
-
-NS_IMETHODIMP
-DBConnection::SetGrowthIncrement(int32_t aIncrement,
-                                 const nsACString& aDatabase)
-{
-  return mBase->SetGrowthIncrement(aIncrement, aDatabase);
-}
-
-NS_IMETHODIMP
-DBConnection::EnableModule(const nsACString& aModule)
-{
-  return mBase->EnableModule(aModule);
-}
-
-NS_IMETHODIMP
-DBConnection::GetQuotaObjects(QuotaObject** aDatabaseQuotaObject,
-                              QuotaObject** aJournalQuotaObject)
-{
-  return mBase->GetQuotaObjects(aDatabaseQuotaObject, aJournalQuotaObject);
-}
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/backgroundsync/DBConnection.h b/dom/backgroundsync/DBConnection.h
deleted file mode 100644
--- a/dom/backgroundsync/DBConnection.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_Connection_h
-#define mozilla_dom_Connection_h
-
-#include "mozIStorageConnection.h"
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-
-class DBConnection final : public mozIStorageConnection
-{
-public:
-  explicit DBConnection(mozIStorageConnection* aBase);
-
-private:
-  ~DBConnection();
-
-  nsCOMPtr<mozIStorageConnection> mBase;
-  bool mClosed;
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_MOZISTORAGEASYNCCONNECTION
-  NS_DECL_MOZISTORAGECONNECTION
-};
-
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_Connection_h
diff --git a/dom/backgroundsync/DBSchema.cpp b/dom/backgroundsync/DBSchema.cpp
--- a/dom/backgroundsync/DBSchema.cpp
+++ b/dom/backgroundsync/DBSchema.cpp
@@ -1,30 +1,35 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "DBSchema.h"
+#include "DBCommon.h"
 #include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
 
 #include "ipc/IPCMessageUtils.h"
 #include "mozIStorageConnection.h"
 #include "mozIStorageStatement.h"
 #include "mozStorageHelper.h"
 #include "nsICryptoHash.h"
 #include "nsNetCID.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 namespace db {
 
+using namespace mozilla::dom::backgroundsync::dbcommon;
+
 using mozilla::dom::backgroundsync::Registration;
+using storage::utils::Expect;
+using storage::utils::Migration;
 
 const int32_t kFirstShippedSchemaVersion = 1;
 
 namespace {
 
 // Update this whenever the DB schema is changed.
 const int32_t kLatestSchemaVersion = 1;
 
@@ -51,31 +56,41 @@ const char* const kTableRegistrations =
 // ---------
 
 } // namespace
 
 
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn)
 {
-  return dbutils::CreateOrMigrateSchema(aConn, kLatestSchemaVersion,
-                                        kTableRegistrations,
-                                        "registrations");
+  nsTArray<nsCString> tablesSql;
+  tablesSql.AppendElement(nsCString(kTableRegistrations));
+
+  nsTArray<Expect> expect;
+  expect.AppendElement(Expect("registrations", "table", kTableRegistrations));
+  expect.AppendElement(Expect("sqlite_autoindex_registrations_1", "index"));
+
+  return storage::utils::CreateOrMigrateSchema(aConn,
+                                               kFirstShippedSchemaVersion,
+                                               kLatestSchemaVersion, tablesSql,
+                                               expect, nsTArray<Migration>());
 }
 
 nsresult
 InitializeConnection(mozIStorageConnection* aConn)
 {
-  return dbutils::InitializeConnection(aConn);
+  return storage::utils::InitializeConnection(aConn, kPageSize, kGrowthSize,
+                                              kWalAutoCheckpointPages,
+                                              kWalAutoCheckpointSize);
 }
 
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn)
 {
-  return dbutils::IncrementalVacuum(aConn);
+  return storage::utils::IncrementalVacuum(aConn, kMaxFreePages);
 }
 
 nsresult
 GetId(const nsAString& aScope, const nsAString& aTag, nsAString& aId)
 {
   nsresult rv;
 
   nsCOMPtr<nsICryptoHash> crypto =
diff --git a/dom/backgroundsync/DBSchema.h b/dom/backgroundsync/DBSchema.h
--- a/dom/backgroundsync/DBSchema.h
+++ b/dom/backgroundsync/DBSchema.h
@@ -59,14 +59,25 @@ ChangeState(mozIStorageConnection* aConn
 // Note, this works best when its NOT executed within a transaction.
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn);
 
 // We will wipe out databases with schema versions less than this. Newer
 // versions will be migrated on open to the latest schema version.
 extern const int32_t kFirstShippedSchemaVersion;
 
+const uint32_t kPageSize = 4 * 1024;
+
+// Grow the database in chunks to reduce fragmentation
+const uint32_t kGrowthSize = 32 * 1024;
+const uint32_t kGrowthPages = kGrowthSize / kPageSize;
+static_assert(kGrowthSize % kPageSize == 0,
+              "Growth size must be multiple of page size");
+
+// Only release free pages when we have more than this limit
+extern const int32_t kMaxFreePages = kGrowthPages;
+
 } // namespace db
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_DBSchema_h
diff --git a/dom/backgroundsync/DBSchemaUtils.cpp b/dom/backgroundsync/DBSchemaUtils.cpp
deleted file mode 100644
--- a/dom/backgroundsync/DBSchemaUtils.cpp
+++ /dev/null
@@ -1,368 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "DBSchemaUtils.h"
-
-#include "ipc/IPCMessageUtils.h"
-#include "mozIStorageConnection.h"
-#include "mozIStorageStatement.h"
-#include "mozStorageHelper.h"
-#include "nsPrintfCString.h"
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-namespace dbutils {
-
-namespace {
-
-const int32_t kMaxEntriesPerStatement = 255;
-
-const uint32_t kPageSize = 4 * 1024;
-
-// Grow the database in chunks to reduce fragmentation
-const uint32_t kGrowthSize = 32 * 1024;
-const uint32_t kGrowthPages = kGrowthSize / kPageSize;
-static_assert(kGrowthSize % kPageSize == 0,
-              "Growth size must be multiple of page size");
-
-// Only release free pages when we have more than this limit
-const int32_t kMaxFreePages = kGrowthPages;
-
-// Limit WAL journal to a reasonable size
-const uint32_t kWalAutoCheckpointSize = 512 * 1024;
-const uint32_t kWalAutoCheckpointPages = kWalAutoCheckpointSize / kPageSize;
-static_assert(kWalAutoCheckpointSize % kPageSize == 0,
-              "WAL checkpoint size must be multiple of page size");
-
-nsresult Validate(mozIStorageConnection* aConn,
-                  int32_t aLatestSchemaVersion,
-                  const char* aTableSql,
-                  const char* aExpectedTableName);
-nsresult Migrate(mozIStorageConnection* aConn);
-
-} // namespace
-
-nsresult
-CreateOrMigrateSchema(mozIStorageConnection* aConn,
-                      int32_t aLatestSchemaVersion,
-                      const char* aTableSql,
-                      const char* aExpectedTableName)
-{
-  MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-
-  int32_t schemaVersion;
-  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (schemaVersion == aLatestSchemaVersion) {
-    // We already have the correct schema version. Validate it matches
-    // our expected schema and then proceed.
-    rv = Validate(aConn, aLatestSchemaVersion, aTableSql, aExpectedTableName);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    return rv;
-  }
-
-  mozStorageTransaction trans(aConn, false,
-                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
-  bool needVacuum = false;
-
-  if (schemaVersion) {
-    // A schema exists, but its not the current version. Attempt to
-    // migrate it to our new schema.
-    rv = Migrate(aConn);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    // Migrations happen infrequently and reflect a change in DB structure.
-    // This is a good time to rebuild the database.  It also helps catch
-    // if a new migration is incorrect by fast failing on the corruption.
-    needVacuum = true;
-  } else {
-    // There is no schema installed.  Create the database from scratch.
-    rv = aConn->ExecuteSimpleSQL(nsDependentCString(aTableSql));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->SetSchemaVersion(aLatestSchemaVersion);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    rv = aConn->GetSchemaVersion(&schemaVersion);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  }
-
-  rv = Validate(aConn, aLatestSchemaVersion, aTableSql, aExpectedTableName);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  rv = trans.Commit();
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (needVacuum) {
-    // Unfortunately, this must be performed outside of the transaction.
-    aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("VACUUM"));
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-  }
-
-  return rv;
-}
-
-nsresult
-InitializeConnection(mozIStorageConnection* aConn)
-{
-  MOZ_ASSERT(!NS_IsMainThread());
-  MOZ_ASSERT(aConn);
-
-  // This function needs to perform per-connection initialization tasks that
-  // need to happen regardless of the schema.
-
-  nsPrintfCString pragmas(
-    // Use a smaller page size to improve perf/footprint; default is too large
-    "PRAGMA page_size = %u; "
-    // Enable auto_vacuum; this must happen after page_size and before WAL
-    "PRAGMA auto_vacuum = INCREMENTAL; "
-    "PRAGMA foreign_keys = ON; ",
-    kPageSize
-  );
-
-  // Note, the default encoding of UTF-8 is preferred.  mozStorage does all
-  // the work necessary to convert UTF-16 nsString values for us.  We don't
-  // need ordering and the binary equality operations are correct.  So, do
-  // NOT set PRAGMA encoding to UTF-16.
-
-  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Limit fragmentation by growing the database by many pages at once.
-  rv = aConn->SetGrowthIncrement(kGrowthSize, EmptyCString());
-  if (rv == NS_ERROR_FILE_TOO_BIG) {
-    NS_WARNING("Not enough disk space to set sqlite growth increment.");
-    rv = NS_OK;
-  }
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Enable WAL journaling. This must be performed in a separate transaction
-  // after changing the page_size and enabling auto_vacuum.
-  nsPrintfCString wal(
-    // WAL journal can grow to given number of *pages*
-    "PRAGMA wal_autocheckpoint = %u; "
-    // Always truncate the journal back to given number of *bytes*
-    "PRAGMA journal_size_limit = %u; "
-    // WAL must be enabled at the end to allow page size to be changed, etc.
-    "PRAGMA journal_mode = WAL; ",
-    kWalAutoCheckpointPages,
-    kWalAutoCheckpointSize
-  );
-
-  rv = aConn->ExecuteSimpleSQL(wal);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Verify that we successfully set the vacuum mode to incremental.  It
-  // is very easy to put the database in a state where the auto_vacuum
-  // pragma above fails silently.
-#ifdef DEBUG
-  nsCOMPtr<mozIStorageStatement> state;
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA auto_vacuum;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  int32_t mode;
-  rv = state->GetInt32(0, &mode);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // integer value 2 is incremental mode
-  if (NS_WARN_IF(mode != 2)) { return NS_ERROR_UNEXPECTED; }
-#endif
-
-  return NS_OK;
-}
-
-nsresult
-IncrementalVacuum(mozIStorageConnection* aConn)
-{
-  // Determine how much free space is in the database.
-  nsCOMPtr<mozIStorageStatement> state;
-  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA freelist_count;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  int32_t freePages = 0;
-  rv = state->GetInt32(0, &freePages);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // We have a relatively small page size, so we want to be careful to avoid
-  // fragmentation.  We already use a growth incremental which will cause
-  // sqlite to allocate and release multiple pages at the same time.  We can
-  // further reduce fragmentation by making our allocated chunks a bit
-  // "sticky".  This is done by creating some hysteresis where we allocate
-  // pages/chunks as soon as we need them, but we only release pages/chunks
-  // when we have a large amount of free space.  This helps with the case
-  // where a page is adding and remove resources causing it to dip back and
-  // forth across a chunk boundary.
-  //
-  // So only proceed with releasing pages if we have more than our constant
-  // threshold.
-  if (freePages <= kMaxFreePages) {
-    return NS_OK;
-  }
-
-  // Release the excess pages back to the sqlite VFS.  This may also release
-  // chunks of multiple pages back to the OS.
-  int32_t pagesToRelease = freePages - kMaxFreePages;
-
-  rv = aConn->ExecuteSimpleSQL(nsPrintfCString(
-    "PRAGMA incremental_vacuum(%d);", pagesToRelease
-  ));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  // Verify that our incremental vacuum actually did something
-#ifdef DEBUG
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "PRAGMA freelist_count;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  hasMoreData = false;
-  rv = state->ExecuteStep(&hasMoreData);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  freePages = 0;
-  rv = state->GetInt32(0, &freePages);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  MOZ_ASSERT(freePages <= kMaxFreePages);
-#endif
-
-  return NS_OK;
-}
-
-namespace {
-
-#ifdef DEBUG
-struct Expect
-{
-  // Expect exact SQL
-  Expect(const char* aName, const char* aType, const char* aSql)
-    : mName(aName)
-    , mType(aType)
-    , mSql(aSql)
-    , mIgnoreSql(false)
-  { }
-
-  // Ignore SQL
-  Expect(const char* aName, const char* aType)
-    : mName(aName)
-    , mType(aType)
-    , mIgnoreSql(true)
-  { }
-
-  const nsCString mName;
-  const nsCString mType;
-  const nsCString mSql;
-  const bool mIgnoreSql;
-};
-#endif
-
-nsresult
-Validate(mozIStorageConnection* aConn,
-         int32_t aLatestSchemaVersion,
-         const char* aExpectedTableSql,
-         const char* aExpectedTableName)
-{
-  int32_t schemaVersion;
-  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  if (NS_WARN_IF(schemaVersion != aLatestSchemaVersion)) {
-    return NS_ERROR_FAILURE;
-  }
-
-#ifdef DEBUG
-  nsPrintfCString autoindex("sqlite_autoindex_%s_1", aExpectedTableName);
-
-  Expect expect[] = {
-    Expect(aExpectedTableName, "table", aExpectedTableSql),
-    // auto-gen by sqlite.
-    Expect("sqlite_sequence", "table"),
-    // auto-gen by sqlite.
-    Expect(autoindex.get(), "index")
-  };
-
-  const uint32_t expectLength = sizeof(expect) / sizeof(Expect);
-
-  // Read the schema from the sqlite_master table and compare.
-  nsCOMPtr<mozIStorageStatement> state;
-  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
-    "SELECT name, type, sql FROM sqlite_master;"
-  ), getter_AddRefs(state));
-  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-  bool hasMoreData = false;
-  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
-    nsAutoCString name;
-    rv = state->GetUTF8String(0, name);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    nsAutoCString type;
-    rv = state->GetUTF8String(1, type);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    nsAutoCString sql;
-    rv = state->GetUTF8String(2, sql);
-    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
-
-    bool foundMatch = false;
-    for (uint32_t i = 0; i < expectLength; ++i) {
-      if (name == expect[i].mName) {
-        if (type != expect[i].mType) {
-          NS_WARNING(nsPrintfCString("Unexpected type for schema entry %s",
-                     name.get()).get());
-          return NS_ERROR_FAILURE;
-        }
-
-        if (!expect[i].mIgnoreSql && sql != expect[i].mSql) {
-          NS_WARNING(nsPrintfCString("Unexpected SQL for schema entry %s",
-                     name.get()).get());
-          return NS_ERROR_FAILURE;
-        }
-
-        foundMatch = true;
-        break;
-      }
-    }
-
-    if (NS_WARN_IF(!foundMatch)) {
-      NS_WARNING(nsPrintfCString("Unexpected schema entry %s in BSync database",
-                 name.get()).get());
-      return NS_ERROR_FAILURE;
-    }
-  }
-#endif
-
-  return rv;
-}
-
-nsresult
-Migrate(mozIStorageConnection* aConn)
-{
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-} // anonymous namespace
-
-} // namespace dbutils
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/backgroundsync/DBSchemaUtils.h b/dom/backgroundsync/DBSchemaUtils.h
deleted file mode 100644
--- a/dom/backgroundsync/DBSchemaUtils.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_DBSchemaUtils_h
-#define mozilla_dom_DBSchemaUtils_h
-
-class mozIStorageConnection;
-struct nsID;
-
-namespace mozilla {
-namespace dom {
-namespace backgroundsync {
-namespace dbutils {
-
-// Note, this cannot be executed within a transaction.
-nsresult
-CreateOrMigrateSchema(mozIStorageConnection* aConn,
-                      int32_t aLatestSchemaVersion,
-                      const char* aTableSql,
-                      const char* aExpectedTableName);
-
-// Note, this cannot be executed within a transaction.
-nsresult
-InitializeConnection(mozIStorageConnection* aConn);
-
-// Note, this works best when its NOT executed within a transaction.
-nsresult
-IncrementalVacuum(mozIStorageConnection* aConn);
-
-} // namespace dbutils
-} // namespace backgroundsync
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_DBSchemaUtils_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -11,19 +11,17 @@ EXPORTS.mozilla.dom.backgroundsync += [
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
     'BackgroundSyncParent.cpp',
     'ChromeDBSchema.cpp',
     'ChromeStorageManager.cpp',
     'DBAction.cpp',
-    'DBConnection.cpp',
     'DBSchema.cpp',
-    'DBSchemaUtils.cpp',
     'QuotaClient.cpp',
     'StorageManager.cpp',
     'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
