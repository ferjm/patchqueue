
# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Date 1492534783 -7200
# Node ID e0bb7a4e558489b3cd1514bd7a3571b9113bdb28
# Parent  c697e756f738ce37abc56f31bfbc48f55625d617
Bug 1355408 - stylo: Support @-moz-document rule. f?xidorn

MozReview-Commit-ID: 7eUhoPjmIjb

diff --git a/layout/style/ServoBindings.cpp b/layout/style/ServoBindings.cpp
--- a/layout/style/ServoBindings.cpp
+++ b/layout/style/ServoBindings.cpp
@@ -22,16 +22,17 @@
 #include "nsIDOMNode.h"
 #include "nsIDocument.h"
 #include "nsIDocumentInlines.h"
 #include "nsIFrame.h"
 #include "nsINode.h"
 #include "nsIPresShell.h"
 #include "nsIPresShellInlines.h"
 #include "nsIPrincipal.h"
+#include "nsIURI.h"
 #include "nsFontMetrics.h"
 #include "nsMappedAttributes.h"
 #include "nsMediaFeatures.h"
 #include "nsNameSpaceManager.h"
 #include "nsNetUtil.h"
 #include "nsRuleNode.h"
 #include "nsString.h"
 #include "nsStyleStruct.h"
@@ -1797,16 +1798,42 @@ Gecko_RegisterProfilerThread(const char*
 }
 
 void
 Gecko_UnregisterProfilerThread()
 {
   profiler_unregister_thread();
 }
 
+bool
+Gecko_nsIURI_ToString(nsIURI* aURI, nsACString* aResult)
+{
+  nsresult rv = aURI->GetSpec(*aResult);
+  return NS_SUCCEEDED(rv);
+}
+
+bool
+Gecko_isPatternMatching(const uint8_t* aValue, uint32_t aValueLength,
+                        const uint8_t* aPattern, uint32_t aPatternLength,
+                        RawGeckoDocumentBorrowedOrNull aDocument)
+{
+  nsString valueStr;
+  nsDependentCSubstring value(reinterpret_cast<const char*>(aValue),
+                              aValueLength);
+  AppendUTF8toUTF16(value, valueStr);
+
+  nsString patternStr;
+  nsDependentCSubstring pattern(reinterpret_cast<const char*>(aPattern),
+                                aPatternLength);
+  AppendUTF8toUTF16(pattern, patternStr);
+
+  return nsContentUtils::IsPatternMatching(valueStr, patternStr,
+    const_cast<nsIDocument*>(reinterpret_cast<const nsIDocument*>(aDocument)));
+}
+
 #include "nsStyleStructList.h"
 
 #undef STYLE_STRUCT
 
 #ifndef MOZ_STYLO
 #define SERVO_BINDING_FUNC(name_, return_, ...)                               \
   return_ name_(__VA_ARGS__) {                                                \
     MOZ_CRASH("stylo: shouldn't be calling " #name_ "in a non-stylo build");  \
diff --git a/layout/style/ServoBindings.h b/layout/style/ServoBindings.h
--- a/layout/style/ServoBindings.h
+++ b/layout/style/ServoBindings.h
@@ -454,15 +454,20 @@ bool Gecko_MatchStringArgPseudo(RawGecko
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 
 void Gecko_Construct_nsStyleVariables(nsStyleVariables* ptr);
 
 void Gecko_RegisterProfilerThread(const char* name);
 void Gecko_UnregisterProfilerThread();
 
+bool Gecko_nsIURI_ToString(nsIURI* aURI, nsACString* aResult);
+bool Gecko_isPatternMatching(const uint8_t* aValue, uint32_t aValueLength,
+                             const uint8_t* aPattern, uint32_t aPatternLength,
+                             RawGeckoDocumentBorrowedOrNull aDocument);
+
 #define SERVO_BINDING_FUNC(name_, return_, ...) return_ name_(__VA_ARGS__);
 #include "mozilla/ServoBindingList.h"
 #undef SERVO_BINDING_FUNC
 
 } // extern "C"
 
 #endif // mozilla_ServoBindings_h
diff --git a/servo/Cargo.lock b/servo/Cargo.lock
--- a/servo/Cargo.lock
+++ b/servo/Cargo.lock
@@ -944,16 +944,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.12.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
  "stylo_tests 0.0.1",
 ]
 
 [[package]]
@@ -2765,16 +2766,17 @@ dependencies = [
  "serde_derive 0.9.11 (registry+https://github.com/rust-lang/crates.io-index)",
  "servo_atoms 0.0.1",
  "servo_config 0.0.1",
  "servo_url 0.0.1",
  "smallvec 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "style_traits 0.0.1",
  "time 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)",
  "unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "style_tests"
 version = "0.0.1"
 dependencies = [
  "app_units 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
diff --git a/servo/components/script/stylesheet_loader.rs b/servo/components/script/stylesheet_loader.rs
--- a/servo/components/script/stylesheet_loader.rs
+++ b/servo/components/script/stylesheet_loader.rs
@@ -20,16 +20,17 @@ use hyper_serde::Serde;
 use ipc_channel::ipc;
 use ipc_channel::router::ROUTER;
 use net_traits::{FetchResponseListener, FetchMetadata, FilteredMetadata, Metadata, NetworkError, ReferrerPolicy};
 use net_traits::request::{CorsSettings, CredentialsMode, Destination, RequestInit, RequestMode, Type as RequestType};
 use network_listener::{NetworkListener, PreInvoke};
 use servo_url::ServoUrl;
 use std::mem;
 use std::sync::{Arc, Mutex};
+use style::document::Document as StyleDocument;
 use style::media_queries::MediaList;
 use style::shared_lock::Locked as StyleLocked;
 use style::stylesheets::{ImportRule, Stylesheet, Origin};
 use style::stylesheets::StylesheetLoader as StyleStylesheetLoader;
 
 pub trait StylesheetOwner {
     /// Returns whether this element was inserted by the parser (i.e., it should
     /// trigger a document-load-blocking load).
@@ -277,9 +278,19 @@ impl<'a> StyleStylesheetLoader for Style
 
         // TODO (mrnayak) : Whether we should use the original loader's CORS
         // setting? Fix this when spec has more details.
         let source = StylesheetContextSource::Import(import.stylesheet.clone());
         self.load(source, url, None, "".to_owned());
 
         make_arc(import)
     }
+
+    fn get_document_url_as_string(&self) -> Option<String> {
+        // TODO (ferjm): Implement as part of @-moz-document support for Servo.
+        None
+    }
+
+    fn get_document(&self) -> StyleDocument {
+        // This is only used by Gecko, so we return None here.
+        None
+    }
 }
diff --git a/servo/components/style/Cargo.toml b/servo/components/style/Cargo.toml
--- a/servo/components/style/Cargo.toml
+++ b/servo/components/style/Cargo.toml
@@ -13,17 +13,17 @@ path = "lib.rs"
 doctest = false
 
 [features]
 gecko = ["nsstring_vendor", "rayon/unstable", "num_cpus"]
 use_bindgen = ["bindgen", "regex"]
 servo = ["serde/unstable", "serde", "serde_derive", "heapsize", "heapsize_derive",
          "style_traits/servo", "servo_atoms", "servo_config", "html5ever-atoms",
          "cssparser/heapsize", "cssparser/serde", "encoding",
-         "rayon/unstable", "servo_url"]
+         "rayon/unstable", "servo_url", "regex"]
 testing = []
 
 [dependencies]
 app_units = "0.4"
 atomic_refcell = "0.1"
 bitflags = "0.7"
 bit-vec = "0.4.3"
 byteorder = "1.0"
@@ -42,28 +42,30 @@ nsstring_vendor = {path = "gecko_binding
 num_cpus = {version = "1.1.0", optional = true}
 num-integer = "0.1.32"
 num-traits = "0.1.32"
 ordered-float = "0.4"
 parking_lot = "0.3.3"
 pdqsort = "0.1.0"
 precomputed-hash = "0.1"
 rayon = "0.6"
+regex = {version = "0.2", optional = true}
 selectors = { path = "../selectors" }
 serde = {version = "0.9", optional = true}
 serde_derive = {version = "0.9", optional = true}
 servo_atoms = {path = "../atoms", optional = true}
 servo_config = {path = "../config", optional = true}
 smallvec = "0.3"
 style_traits = {path = "../style_traits"}
 servo_url = {path = "../url", optional = true}
 time = "0.1"
 unicode-segmentation = "1.0"
+url = "1.2"
 
 [target.'cfg(windows)'.dependencies]
 kernel32-sys = "0.2"
 
 [build-dependencies]
 lazy_static = "0.2"
 log = "0.3"
 bindgen = { version = "0.22", optional = true }
-regex = {version = "0.2", optional = true}
+regex = "0.2"
 walkdir = "1.0"
diff --git a/servo/components/style/build_gecko.rs b/servo/components/style/build_gecko.rs
--- a/servo/components/style/build_gecko.rs
+++ b/servo/components/style/build_gecko.rs
@@ -298,16 +298,17 @@ mod bindings {
             .include(add_include("mozilla/ServoElementSnapshot.h"))
             .include(add_include("mozilla/dom/Element.h"))
             .include(add_include("mozilla/dom/NameSpaceConstants.h"))
             .include(add_include("mozilla/LookAndFeel.h"))
             .include(add_include("mozilla/ServoBindings.h"))
             .include(add_include("nsCSSFontFaceRule.h"))
             .include(add_include("nsMediaFeatures.h"))
             .include(add_include("nsMediaList.h"))
+            .include(add_include("mozilla/css/Loader.h"))
             // FIXME(emilio): Incrementally remove these "pub use"s. Probably
             // mozilla::css and mozilla::dom are easier.
             .raw_line("pub use self::root::*;")
             .raw_line("pub use self::root::mozilla::*;")
             .raw_line("pub use self::root::mozilla::css::*;")
             .raw_line("pub use self::root::mozilla::dom::*;")
             .raw_line("use atomic_refcell::AtomicRefCell;")
             .raw_line("use data::ElementData;")
@@ -664,16 +665,17 @@ mod bindings {
             "nsCSSShadowArray",
             "nsCSSUnit",
             "nsCSSValue",
             "nsCSSValueSharedList",
             "nsChangeHint",
             "nsCursorImage",
             "nsFont",
             "nsIAtom",
+            "nsIURI",
             "nsMediaFeature",
             "nsRestyleHint",
             "nsStyleBackground",
             "nsStyleBorder",
             "nsStyleColor",
             "nsStyleColumn",
             "nsStyleContent",
             "nsStyleContentData",
diff --git a/servo/components/style/document.rs b/servo/components/style/document.rs
new file mode 100644
--- /dev/null
+++ b/servo/components/style/document.rs
@@ -0,0 +1,195 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+//! [@document rules](https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#at-document)
+//! initially in CSS Conditional Rules Module Level 3, @document has been postponed to the level 4.
+//! We implement the prefixed `@-moz-document`.
+
+use cssparser::Parser;
+#[cfg(feature = "gecko")]
+use gecko_bindings::bindings::RawGeckoDocumentBorrowedOrNull;
+#[cfg(feature = "gecko")]
+use gecko_bindings::bindings::Gecko_isPatternMatching;
+use parser::{Parse, ParserContext};
+#[cfg(not(feature = "gecko"))]
+use regex::Regex;
+use std::fmt;
+use style_traits::ToCss;
+use values::specified::url::SpecifiedUrl;
+use url::Url;
+
+/// Gecko nsIDocument.
+/// Not pretty, but we need this to be able to call nsContentUtils::IsPatternMatching
+#[cfg(feature = "gecko")]
+pub type Document<'a> = RawGeckoDocumentBorrowedOrNull<'a>;
+
+/// Useless Document type for non-gecko platforms.
+#[cfg(not(feature = "gecko"))]
+pub type Document = Option<()>;
+
+#[cfg(feature = "gecko")]
+fn is_pattern_matching(document_url: &str, pattern: &str, document: Document) -> bool {
+    unsafe {
+        Gecko_isPatternMatching(document_url.as_ptr(), document_url.len() as u32,
+                                pattern.as_ptr(), pattern.len() as u32,
+                                document)
+    }
+}
+
+#[cfg(not(feature = "gecko"))]
+fn is_pattern_matching(document_url: &str, pattern: &str, _: Document) -> bool {
+    if let Ok(regex) = Regex::new(pattern) {
+        regex.is_match(document_url)
+    } else {
+        false
+    }
+}
+
+/// A URL matching function for a `@document` rule's condition.
+#[derive(Debug)]
+pub enum UrlMatchingFunction {
+    /// Exact url matching function.
+    Url(SpecifiedUrl),
+    /// Url prefix matching function.
+    UrlPrefix(String),
+    /// Domain matching function.
+    Domain(String),
+    /// Regular expression matching function.
+    RegExp(String),
+}
+
+impl UrlMatchingFunction {
+    /// Parse a URL matching function for a`@document` rule's condition.
+    pub fn parse(context: &ParserContext, input: &mut Parser)
+        -> Result<UrlMatchingFunction, ()> {
+        if input.try(|input| input.expect_function_matching("url-prefix")).is_ok() {
+            input.parse_nested_block(|input| {
+                Ok(UrlMatchingFunction::UrlPrefix(input.expect_string()?.into_owned()))
+            })
+        } else if input.try(|input| input.expect_function_matching("domain")).is_ok() {
+            input.parse_nested_block(|input| {
+                Ok(UrlMatchingFunction::Domain(input.expect_string()?.into_owned()))
+            })
+        } else if input.try(|input| input.expect_function_matching("regexp")).is_ok() {
+            input.parse_nested_block(|input| {
+                Ok(UrlMatchingFunction::RegExp(input.expect_string()?.into_owned()))
+            })
+        } else if let Ok(url) = input.try(|input| SpecifiedUrl::parse(context, input)) {
+            Ok(UrlMatchingFunction::Url(url))
+        } else {
+            Err(())
+        }
+    }
+
+    /// Evaluate a URL matching function.
+    pub fn eval(&self, document_url: &str, document: Document) -> bool {
+        match *self {
+            /// Exact URL matching function. It evaluates to true whenever the
+            /// URL of the document being styled is exactly the URL given.
+            UrlMatchingFunction::Url(ref url) => {
+                url.as_str() == document_url
+            },
+            /// URL prefix matching function. It evaluates to true whenever the
+            /// URL of the document being styled has the argument to the
+            /// function as an initial substring (which is true when the two
+            /// strings are equal). When the argument is the empty string,
+            /// it evaluates to true for all documents.
+            UrlMatchingFunction::UrlPrefix(ref url_prefix) => {
+                document_url.starts_with(url_prefix)
+            },
+            /// Domain matching function. It evaluates to true whenever the URL
+            /// of the document being styled has a host subcomponent and that
+            /// host subcomponent is exactly the argument to the ‘domain()’
+            /// function or a final substring of the host component is a
+            /// period (U+002E) immediately followed by the argument to the
+            /// ‘domain()’ function.
+            UrlMatchingFunction::Domain(ref domain) => {
+                match Url::parse(document_url) {
+                    Ok(url) => match url.host_str() {
+                        Some(document_host) => document_host == domain,
+                        None => false,
+                    },
+                    Err(_) => false,
+                }
+            },
+            /// Regular expression matching function. It evaluates to true
+            /// whenever the regular expression matches the entirety of the URL
+            /// of the document being styled.
+            UrlMatchingFunction::RegExp(ref pattern) => {
+                is_pattern_matching(document_url, pattern, document)
+            },
+        }
+    }
+}
+
+impl ToCss for UrlMatchingFunction {
+    fn to_css<W>(&self, dest: &mut W) -> fmt::Result
+        where W: fmt::Write {
+        match *self {
+            UrlMatchingFunction::Url(ref url) => {
+                url.to_css(dest)
+            },
+            UrlMatchingFunction::UrlPrefix(ref url_prefix) => {
+                dest.write_str("url-prefix(")?;
+                dest.write_str(url_prefix)?;
+                dest.write_str(")")
+            },
+            UrlMatchingFunction::Domain(ref domain) => {
+                dest.write_str("domain(")?;
+                dest.write_str(domain)?;
+                dest.write_str(")")
+            },
+            UrlMatchingFunction::RegExp(ref regex) => {
+                dest.write_str("regexp(")?;
+                dest.write_str(regex)?;
+                dest.write_str(")")
+            },
+        }
+    }
+}
+
+/// A `@document` rule's condition.
+///
+/// https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#at-document
+///
+/// The `@document` rule's condition is written as a comma-separated list of
+/// URL matching functions, and the condition evaluates to true whenever any
+/// one of those functions evaluates to true.
+#[derive(Debug)]
+pub struct DocumentCondition(Vec<UrlMatchingFunction>);
+
+impl DocumentCondition {
+    /// Parse a document condition.
+    pub fn parse(context: &ParserContext, input: &mut Parser)
+        -> Result<Self, ()> {
+        input.parse_comma_separated(|input| UrlMatchingFunction::parse(context, input))
+             .map(DocumentCondition)
+    }
+
+    /// Evaluate a document condition.
+    pub fn eval(&self, document_url: Option<String>, document: Document) -> bool {
+        if let Some(url) = document_url {
+            self.0.iter().any(|ref url_matching_function|
+                url_matching_function.eval(&url, document)
+            )
+        } else {
+            false
+        }
+    }
+}
+
+impl ToCss for DocumentCondition {
+    fn to_css<W>(&self, dest: &mut W) -> fmt::Result
+        where W: fmt::Write {
+        let mut iter = self.0.iter();
+        let first = iter.next()
+            .expect("Empty DocumentCondition, should contain at least one URL matching function");
+        first.to_css(dest)?;
+        for url_matching_function in iter {
+            dest.write_str(", ")?;
+            url_matching_function.to_css(dest)?;
+        }
+        Ok(())
+    }
+}
diff --git a/servo/components/style/lib.rs b/servo/components/style/lib.rs
--- a/servo/components/style/lib.rs
+++ b/servo/components/style/lib.rs
@@ -64,38 +64,42 @@ extern crate nsstring_vendor as nsstring
 #[cfg(feature = "gecko")] extern crate num_cpus;
 extern crate num_integer;
 extern crate num_traits;
 extern crate ordered_float;
 extern crate parking_lot;
 extern crate pdqsort;
 #[cfg(feature = "gecko")] extern crate precomputed_hash;
 extern crate rayon;
+#[cfg(not(feature = "gecko"))]
+extern crate regex;
 extern crate selectors;
 #[cfg(feature = "servo")] #[macro_use] extern crate serde_derive;
 #[cfg(feature = "servo")] #[macro_use] extern crate servo_atoms;
 #[cfg(feature = "servo")] extern crate servo_config;
 #[cfg(feature = "servo")] extern crate servo_url;
 extern crate smallvec;
 #[macro_use]
 extern crate style_traits;
 extern crate time;
 #[allow(unused_extern_crates)]
 extern crate unicode_segmentation;
+extern crate url;
 
 pub mod animation;
 #[allow(missing_docs)] // TODO.
 #[cfg(feature = "servo")] pub mod attr;
 pub mod bezier;
 pub mod bloom;
 pub mod cache;
 pub mod cascade_info;
 pub mod context;
 pub mod custom_properties;
 pub mod data;
+pub mod document;
 pub mod dom;
 pub mod element_state;
 #[cfg(feature = "servo")] mod encoding_support;
 pub mod error_reporting;
 pub mod font_face;
 pub mod font_metrics;
 #[cfg(feature = "gecko")] #[allow(unsafe_code)] pub mod gecko;
 #[cfg(feature = "gecko")] #[allow(unsafe_code)] pub mod gecko_bindings;
diff --git a/servo/components/style/stylesheets.rs b/servo/components/style/stylesheets.rs
--- a/servo/components/style/stylesheets.rs
+++ b/servo/components/style/stylesheets.rs
@@ -5,16 +5,17 @@
 //! Style sheets and their CSS rules.
 
 #![deny(missing_docs)]
 
 use {Atom, Prefix, Namespace};
 use cssparser::{AtRuleParser, Parser, QualifiedRuleParser};
 use cssparser::{AtRuleType, RuleListParser, SourcePosition, Token, parse_one_rule};
 use cssparser::ToCss as ParserToCss;
+use document::{Document, DocumentCondition};
 use error_reporting::ParseErrorReporter;
 #[cfg(feature = "servo")]
 use font_face::FontFaceRuleData;
 use font_face::parse_font_face_block;
 #[cfg(feature = "gecko")]
 pub use gecko::rules::FontFaceRule;
 #[cfg(feature = "gecko")]
 use gecko_bindings::structs::URLExtraData;
@@ -287,16 +288,17 @@ pub enum CssRule {
     Import(Arc<Locked<ImportRule>>),
     Style(Arc<Locked<StyleRule>>),
     Media(Arc<Locked<MediaRule>>),
     FontFace(Arc<Locked<FontFaceRule>>),
     Viewport(Arc<Locked<ViewportRule>>),
     Keyframes(Arc<Locked<KeyframesRule>>),
     Supports(Arc<Locked<SupportsRule>>),
     Page(Arc<Locked<PageRule>>),
+    Document(Arc<Locked<DocumentRule>>),
 }
 
 #[allow(missing_docs)]
 #[derive(PartialEq, Eq, Copy, Clone)]
 pub enum CssRuleType {
     // https://drafts.csswg.org/cssom/#the-cssrule-interface
     Style               = 1,
     Charset             = 2,
@@ -309,16 +311,18 @@ pub enum CssRuleType {
     Keyframe            = 8,
     // https://drafts.csswg.org/cssom/#the-cssrule-interface
     Margin              = 9,
     Namespace           = 10,
     // https://drafts.csswg.org/css-counter-styles-3/#extentions-to-cssrule-interface
     CounterStyle        = 11,
     // https://drafts.csswg.org/css-conditional-3/#extentions-to-cssrule-interface
     Supports            = 12,
+    // https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#extentions-to-cssrule-interface
+    Document            = 13,
     // https://drafts.csswg.org/css-fonts-3/#om-fontfeaturevalues
     FontFeatureValues   = 14,
     // https://drafts.csswg.org/css-device-adapt/#css-rule-interface
     Viewport            = 15,
 }
 
 /// Error reporter which silently forgets errors
 pub struct MemoryHoleReporter;
@@ -348,16 +352,17 @@ impl CssRule {
             CssRule::Import(_)    => CssRuleType::Import,
             CssRule::Media(_)     => CssRuleType::Media,
             CssRule::FontFace(_)  => CssRuleType::FontFace,
             CssRule::Keyframes(_) => CssRuleType::Keyframes,
             CssRule::Namespace(_) => CssRuleType::Namespace,
             CssRule::Viewport(_)  => CssRuleType::Viewport,
             CssRule::Supports(_)  => CssRuleType::Supports,
             CssRule::Page(_)      => CssRuleType::Page,
+            CssRule::Document(_)  => CssRuleType::Document,
         }
     }
 
     fn rule_state(&self) -> State {
         match *self {
             // CssRule::Charset(..) => State::Start,
             CssRule::Import(..) => State::Imports,
             CssRule::Namespace(..) => State::Namespaces,
@@ -401,16 +406,26 @@ impl CssRule {
                 let enabled = supports_rule.enabled;
                 if enabled {
                     let rules = &supports_rule.rules.read_with(guard).0;
                     f(rules, None)
                 } else {
                     f(&[], None)
                 }
             }
+            CssRule::Document(ref lock) => {
+                let document_rule = lock.read_with(guard);
+                let enabled = document_rule.enabled;
+                if enabled {
+                    let rules = &document_rule.rules.read_with(guard).0;
+                    f(rules, None)
+                } else {
+                    f(&[], None)
+                }
+            }
         }
     }
 
     // input state is None for a nested rule
     // Returns a parsed CSS rule and the final state of the parser
     #[allow(missing_docs)]
     pub fn parse(css: &str,
                  parent_stylesheet: &Stylesheet,
@@ -458,16 +473,17 @@ impl ToCssWithGuard for CssRule {
             CssRule::Import(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Style(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::FontFace(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Viewport(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Keyframes(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Media(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Supports(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Page(ref lock) => lock.read_with(guard).to_css(guard, dest),
+            CssRule::Document(ref lock) => lock.read_with(guard).to_css(guard, dest),
         }
     }
 }
 
 #[derive(Debug, PartialEq)]
 #[allow(missing_docs)]
 pub struct NamespaceRule {
     /// `None` for the default Namespace
@@ -650,16 +666,41 @@ impl ToCssWithGuard for StyleRule {
         Ok(())
     }
 }
 
 /// A @font-face rule
 #[cfg(feature = "servo")]
 pub type FontFaceRule = FontFaceRuleData;
 
+#[derive(Debug)]
+/// A @-moz-document rule
+pub struct DocumentRule {
+    /// The parsed condition
+    pub condition: DocumentCondition,
+    /// Child rules
+    pub rules: Arc<Locked<CssRules>>,
+    /// The result of evaluating the condition
+    pub enabled: bool,
+}
+
+impl ToCssWithGuard for DocumentRule {
+    fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
+    where W: fmt::Write {
+        try!(dest.write_str("@-moz-document "));
+        try!(self.condition.to_css(dest));
+        try!(dest.write_str(" {"));
+        for rule in self.rules.read_with(guard).0.iter() {
+            try!(dest.write_str(" "));
+            try!(rule.to_css(guard, dest));
+        }
+        dest.write_str(" }")
+    }
+}
+
 impl Stylesheet {
     /// Updates an empty stylesheet from a given string of text.
     pub fn update_from_str(existing: &Stylesheet,
                            css: &str,
                            url_data: &UrlExtraData,
                            stylesheet_loader: Option<&StylesheetLoader>,
                            error_reporter: &ParseErrorReporter) {
         let mut namespaces = Namespaces::default();
@@ -844,16 +885,17 @@ macro_rules! rule_filter {
 rule_filter! {
     effective_style_rules(Style => StyleRule),
     effective_media_rules(Media => MediaRule),
     effective_font_face_rules(FontFace => FontFaceRule),
     effective_viewport_rules(Viewport => ViewportRule),
     effective_keyframes_rules(Keyframes => KeyframesRule),
     effective_supports_rules(Supports => SupportsRule),
     effective_page_rules(Page => PageRule),
+    effective_document_rules(Document => DocumentRule),
 }
 
 /// The stylesheet loader is the abstraction used to trigger network requests
 /// for `@import` rules.
 pub trait StylesheetLoader {
     /// Request a stylesheet after parsing a given `@import` rule.
     ///
     /// The called code is responsible to update the `stylesheet` rules field
@@ -862,29 +904,43 @@ pub trait StylesheetLoader {
     /// The convoluted signature allows impls to look at MediaList and ImportRule
     /// before they’re locked, while keeping the trait object-safe.
     fn request_stylesheet(
         &self,
         media: Arc<Locked<MediaList>>,
         make_import: &mut FnMut(Arc<Locked<MediaList>>) -> ImportRule,
         make_arc: &mut FnMut(ImportRule) -> Arc<Locked<ImportRule>>,
     ) -> Arc<Locked<ImportRule>>;
+
+    /// Get the URL of the document loading the stylesheet as a string.
+    fn get_document_url_as_string(&self) -> Option<String>;
+
+    /// Get the document loading the stylesheet.
+    fn get_document(&self) -> Document;
 }
 
 struct NoOpLoader;
 
 impl StylesheetLoader for NoOpLoader {
     fn request_stylesheet(
         &self,
         media: Arc<Locked<MediaList>>,
         make_import: &mut FnMut(Arc<Locked<MediaList>>) -> ImportRule,
         make_arc: &mut FnMut(ImportRule) -> Arc<Locked<ImportRule>>,
     ) -> Arc<Locked<ImportRule>> {
         make_arc(make_import(media))
     }
+
+    fn get_document_url_as_string(&self) -> Option<String> {
+        None
+    }
+
+    fn get_document(&self) -> Document {
+        None
+    }
 }
 
 
 struct TopLevelRuleParser<'a> {
     stylesheet_origin: Origin,
     namespaces: &'a mut Namespaces,
     shared_lock: &'a SharedRwLock,
     loader: Option<&'a StylesheetLoader>,
@@ -894,16 +950,17 @@ struct TopLevelRuleParser<'a> {
 
 impl<'b> TopLevelRuleParser<'b> {
     fn nested<'a: 'b>(&'a self) -> NestedRuleParser<'a, 'b> {
         NestedRuleParser {
             stylesheet_origin: self.stylesheet_origin,
             shared_lock: self.shared_lock,
             context: &self.context,
             namespaces: self.namespaces,
+            loader: self.loader
         }
     }
 }
 
 #[derive(Eq, PartialEq, Ord, PartialOrd, Copy, Clone)]
 #[allow(missing_docs)]
 pub enum State {
     Start = 1,
@@ -922,16 +979,18 @@ enum AtRulePrelude {
     /// An @supports rule, with its conditional
     Supports(SupportsCondition),
     /// A @viewport rule prelude.
     Viewport,
     /// A @keyframes rule, with its animation name.
     Keyframes(Atom),
     /// A @page rule prelude.
     Page,
+    /// A @document rule, with its conditional.
+    Document(DocumentCondition),
 }
 
 
 impl<'a> AtRuleParser for TopLevelRuleParser<'a> {
     type Prelude = AtRulePrelude;
     type AtRule = CssRule;
 
     fn parse_prelude(&mut self, name: &str, input: &mut Parser)
@@ -1043,26 +1102,28 @@ impl<'a> QualifiedRuleParser for TopLeve
 }
 
 #[derive(Clone)]  // shallow, relatively cheap .clone
 struct NestedRuleParser<'a, 'b: 'a> {
     stylesheet_origin: Origin,
     shared_lock: &'a SharedRwLock,
     context: &'a ParserContext<'b>,
     namespaces: &'b Namespaces,
+    loader: Option<&'a StylesheetLoader>,
 }
 
 impl<'a, 'b> NestedRuleParser<'a, 'b> {
     fn parse_nested_rules(&self, input: &mut Parser, rule_type: CssRuleType) -> Arc<Locked<CssRules>> {
         let context = ParserContext::new_with_rule_type(self.context, Some(rule_type));
         let nested_parser = NestedRuleParser {
             stylesheet_origin: self.stylesheet_origin,
             shared_lock: self.shared_lock,
             context: &context,
             namespaces: self.namespaces,
+            loader: self.loader,
         };
         let mut iter = RuleListParser::new_for_nested_rule(input, nested_parser);
         let mut rules = Vec::new();
         while let Some(result) = iter.next() {
             match result {
                 Ok(rule) => rules.push(rule),
                 Err(range) => {
                     let pos = range.start;
@@ -1122,16 +1183,20 @@ impl<'a, 'b> AtRuleParser for NestedRule
             },
             "page" => {
                 if cfg!(feature = "gecko") {
                     Ok(AtRuleType::WithBlock(AtRulePrelude::Page))
                 } else {
                     Err(())
                 }
             },
+            "-moz-document" => {
+                let cond = DocumentCondition::parse(self.context, input)?;
+                Ok(AtRuleType::WithBlock(AtRulePrelude::Document(cond)))
+            },
             _ => Err(())
         }
     }
 
     fn parse_block(&mut self, prelude: AtRulePrelude, input: &mut Parser) -> Result<CssRule, ()> {
         match prelude {
             AtRulePrelude::FontFace => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::FontFace));
@@ -1166,16 +1231,25 @@ impl<'a, 'b> AtRuleParser for NestedRule
             }
             AtRulePrelude::Page => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Page));
                 let declarations = parse_property_declaration_list(&context, input);
                 Ok(CssRule::Page(Arc::new(self.shared_lock.wrap(PageRule(
                     Arc::new(self.shared_lock.wrap(declarations))
                 )))))
             }
+            AtRulePrelude::Document(cond) => {
+                let loader = self.loader.expect("Expected a stylesheet loader for @-moz-document");
+                let enabled = cond.eval(loader.get_document_url_as_string(), loader.get_document());
+                Ok(CssRule::Document(Arc::new(self.shared_lock.wrap(DocumentRule {
+                    condition: cond,
+                    rules: self.parse_nested_rules(input, CssRuleType::Document),
+                    enabled: enabled,
+                }))))
+            }
         }
     }
 }
 
 impl<'a, 'b> QualifiedRuleParser for NestedRuleParser<'a, 'b> {
     type Prelude = SelectorList<SelectorImpl>;
     type QualifiedRule = CssRule;
 
diff --git a/servo/ports/geckolib/Cargo.toml b/servo/ports/geckolib/Cargo.toml
--- a/servo/ports/geckolib/Cargo.toml
+++ b/servo/ports/geckolib/Cargo.toml
@@ -14,15 +14,16 @@ bindgen = ["style/use_bindgen"]
 testing = ["style/testing"]
 
 [dependencies]
 atomic_refcell = "0.1"
 cssparser = "0.12.1"
 env_logger = {version = "0.4", default-features = false} # disable `regex` to reduce code size
 libc = "0.2"
 log = {version = "0.3.5", features = ["release_max_level_info"]}
+nsstring_vendor = {path = "../../components/style/gecko_bindings/nsstring_vendor"}
 parking_lot = "0.3"
 selectors = {path = "../../components/selectors"}
 style = {path = "../../components/style", features = ["gecko"]}
 style_traits = {path = "../../components/style_traits"}
 
 [dev-dependencies]
 stylo_tests = {path = "../../tests/unit/stylo"}
diff --git a/servo/ports/geckolib/lib.rs b/servo/ports/geckolib/lib.rs
--- a/servo/ports/geckolib/lib.rs
+++ b/servo/ports/geckolib/lib.rs
@@ -5,16 +5,17 @@
 #![deny(warnings)]
 
 extern crate atomic_refcell;
 extern crate cssparser;
 extern crate env_logger;
 extern crate libc;
 #[macro_use] extern crate log;
 extern crate parking_lot;
+#[macro_use] extern crate nsstring_vendor as nsstring;
 extern crate selectors;
 #[macro_use] extern crate style;
 extern crate style_traits;
 
 #[allow(non_snake_case)]
 pub mod glue;
 mod stylesheet_loader;
 
diff --git a/servo/ports/geckolib/stylesheet_loader.rs b/servo/ports/geckolib/stylesheet_loader.rs
--- a/servo/ports/geckolib/stylesheet_loader.rs
+++ b/servo/ports/geckolib/stylesheet_loader.rs
@@ -1,16 +1,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 use std::sync::Arc;
-use style::gecko_bindings::bindings::Gecko_LoadStyleSheet;
+use style::gecko_bindings::bindings::{Gecko_LoadStyleSheet, Gecko_nsIURI_ToString};
 use style::gecko_bindings::structs::{Loader, ServoStyleSheet};
 use style::gecko_bindings::sugar::ownership::{HasArcFFI, FFIArcHelpers};
+use style::document::Document;
 use style::media_queries::MediaList;
 use style::shared_lock::Locked;
 use style::stylesheets::{ImportRule, Stylesheet, StylesheetLoader as StyleStylesheetLoader};
 
 pub struct StylesheetLoader(*mut Loader, *mut ServoStyleSheet);
 
 impl StylesheetLoader {
     pub fn new(loader: *mut Loader, parent: *mut ServoStyleSheet) -> Self {
@@ -40,9 +41,26 @@ impl StyleStylesheetLoader for Styleshee
                                  Stylesheet::arc_as_borrowed(&import.stylesheet),
                                  base_url_data,
                                  spec_bytes,
                                  spec_len as u32,
                                  media.into_strong())
         }
         make_arc(import)
     }
+
+    fn get_document_url_as_string(&self) -> Option<String> {
+        ns_auto_cstring!(spec);
+        unsafe {
+            if Gecko_nsIURI_ToString((*(*self.0).mDocument).mDocumentURI.raw(), &mut *spec) {
+                Some(format!("{}", spec))
+            } else {
+                None
+            }
+        }
+    }
+
+    fn get_document(&self) -> Document {
+        unsafe {
+            Some(&*(*self.0).mDocument)
+        }
+    }
 }
diff --git a/toolkit/library/gtest/rust/Cargo.lock b/toolkit/library/gtest/rust/Cargo.lock
--- a/toolkit/library/gtest/rust/Cargo.lock
+++ b/toolkit/library/gtest/rust/Cargo.lock
@@ -285,16 +285,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.12.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
 ]
 
 [[package]]
 name = "gkrust-shared"
@@ -746,16 +747,17 @@ dependencies = [
  "precomputed-hash 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "rayon 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "smallvec 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "style_traits 0.0.1",
  "time 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)",
  "unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "style_traits"
 version = "0.0.1"
 dependencies = [
  "app_units 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
diff --git a/toolkit/library/rust/Cargo.lock b/toolkit/library/rust/Cargo.lock
--- a/toolkit/library/rust/Cargo.lock
+++ b/toolkit/library/rust/Cargo.lock
@@ -283,16 +283,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.12.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
 ]
 
 [[package]]
 name = "gkrust-shared"
@@ -733,16 +734,17 @@ dependencies = [
  "precomputed-hash 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "rayon 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "regex 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "smallvec 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "style_traits 0.0.1",
  "time 0.1.36 (registry+https://github.com/rust-lang/crates.io-index)",
  "unicode-segmentation 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "url 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "walkdir 1.0.7 (registry+https://github.com/rust-lang/crates.io-index)",
 ]
 
 [[package]]
 name = "style_traits"
 version = "0.0.1"
 dependencies = [
  "app_units 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
