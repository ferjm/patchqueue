# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Parent  cc65f9233e5b16265ae44b643c7d255556da14fb
Bug 1355345 - stylo: Support font-display descriptor in @font-face rule. r?emilio

diff --git a/layout/style/test/stylo-failures.md b/layout/style/test/stylo-failures.md
--- a/layout/style/test/stylo-failures.md
+++ b/layout/style/test/stylo-failures.md
@@ -78,19 +78,16 @@ to mochitest command.
   * test_counter_descriptor_storage.html asserts [110]
 * symbols() function and string value on list-style-type bug 1363596
   * test_value_storage.html `symbols(` [30]
   * ... `list-style-type` [8]
   * ... `'list-style'` [18]
 * @page support:
   * test_bug887741_at-rules_in_declaration_lists.html `exception` [1]
 * Unimplemented \@font-face descriptors:
-  * font-display bug 1355345
-    * test_descriptor_storage.html `font-display` [5]
-    * test_font_face_parser.html `font-display` [15]
   * test_font_face_parser.html `font-language-override`: bug 1355364 [8]
   * ... `font-feature-settings`: bug 1355366 [10]
 * test_font_face_parser.html `font-weight`: keyword values should be preserved in \@font-face [4]
 * @namespace support:
   * test_namespace_rule.html: bug 1355715 [8]
 * test_dont_use_document_colors.html: support of disabling document color bug 1355716 [21]
 * test_font_feature_values_parsing.html: \@font-feature-values support bug 1355721 [107]
 * Grid support bug 1341802
diff --git a/servo/components/style/font_face.rs b/servo/components/style/font_face.rs
--- a/servo/components/style/font_face.rs
+++ b/servo/components/style/font_face.rs
@@ -67,16 +67,39 @@ pub struct UrlSource {
 impl ToCss for UrlSource {
     fn to_css<W>(&self, dest: &mut W) -> fmt::Result
         where W: fmt::Write,
     {
         dest.write_str(self.url.as_str())
     }
 }
 
+/// A font-display value for a @font-face rule.
+/// The font-display descriptor determines how a font face is displayed based
+/// on whether and when it is downloaded and ready to use.
+define_css_keyword_enum!(FontDisplay:
+                         "auto" => Auto,
+                         "block" => Block,
+                         "swap" => Swap,
+                         "fallback" => Fallback,
+                         "optional" => Optional);
+
+impl Parse for FontDisplay {
+    fn parse(_: &ParserContext, input: &mut Parser) -> Result<FontDisplay, ()> {
+        Ok(match_ignore_ascii_case! { &*input.expect_ident()?,
+            "auto" => FontDisplay::Auto,
+            "block" => FontDisplay::Block,
+            "swap" => FontDisplay::Swap,
+            "fallback" => FontDisplay::Fallback,
+            "optional" => FontDisplay::Optional,
+            _ => return Err(())
+        })
+    }
+}
+
 /// Parse the block inside a `@font-face` rule.
 ///
 /// Note that the prelude parsing code lives in the `stylesheets` module.
 pub fn parse_font_face_block(context: &ParserContext, input: &mut Parser, location: SourceLocation)
     -> FontFaceRuleData {
     let mut rule = FontFaceRuleData::empty();
     rule.source_location = location;
     {
@@ -327,22 +350,25 @@ font_face_descriptors! {
         "font-style" style / mStyle: font_style::T = font_style::T::normal,
 
         /// The weight of this font face
         "font-weight" weight / mWeight: font_weight::T = font_weight::T::Weight400 /* normal */,
 
         /// The stretch of this font face
         "font-stretch" stretch / mStretch: font_stretch::T = font_stretch::T::normal,
 
+        /// The display of this font face
+        "font-display" display / mDisplay: FontDisplay = FontDisplay::Auto,
+
         /// The ranges of code points outside of which this font face should not be used.
         "unicode-range" unicode_range / mUnicodeRange: Vec<UnicodeRange> = vec![
             UnicodeRange { start: 0, end: 0x10FFFF }
         ],
 
-        // FIXME: add font-feature-settings, font-language-override, and font-display
+        // FIXME: add font-feature-settings and font-language-override
     ]
 }
 
 #[cfg(feature = "servo")]
 font_face_descriptors! {
     mandatory descriptors = [
         /// The name of this font face
         "font-family" family / mFamily: FamilyName,
diff --git a/servo/components/style/gecko/rules.rs b/servo/components/style/gecko/rules.rs
--- a/servo/components/style/gecko/rules.rs
+++ b/servo/components/style/gecko/rules.rs
@@ -3,17 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 //! Bindings for CSS Rule objects
 
 use computed_values::{font_style, font_weight, font_stretch};
 use computed_values::font_family::FamilyName;
 use counter_style;
 use cssparser::UnicodeRange;
-use font_face::{FontFaceRuleData, Source};
+use font_face::{FontFaceRuleData, Source, FontDisplay};
 use gecko_bindings::bindings;
 use gecko_bindings::structs::{self, nsCSSFontFaceRule, nsCSSValue};
 use gecko_bindings::structs::{nsCSSCounterDesc, nsCSSCounterStyleRule};
 use gecko_bindings::sugar::ns_css_value::ToNsCssValue;
 use gecko_bindings::sugar::refptr::{RefPtr, UniqueRefPtr};
 use shared_lock::{ToCssWithGuard, SharedRwLockReadGuard};
 use std::fmt;
 
@@ -110,16 +110,28 @@ impl ToNsCssValue for Vec<UnicodeRange> 
             .as_mut_slice().chunks_mut(2);
         for (range, target) in self.iter().zip(target_ranges) {
             target[0].set_integer(range.start as i32);
             target[1].set_integer(range.end as i32);
         }
     }
 }
 
+impl ToNsCssValue for FontDisplay {
+    fn convert(self, nscssvalue: &mut nsCSSValue) {
+        nscssvalue.set_enum(match self {
+            FontDisplay::Auto => structs::NS_FONT_DISPLAY_AUTO,
+            FontDisplay::Block => structs::NS_FONT_DISPLAY_BLOCK,
+            FontDisplay::Swap => structs::NS_FONT_DISPLAY_SWAP,
+            FontDisplay::Fallback => structs::NS_FONT_DISPLAY_FALLBACK,
+            FontDisplay::Optional => structs::NS_FONT_DISPLAY_OPTIONAL,
+        } as i32)
+    }
+}
+
 impl From<FontFaceRuleData> for FontFaceRule {
     fn from(data: FontFaceRuleData) -> FontFaceRule {
         let mut result = unsafe {
             UniqueRefPtr::from_addrefed(bindings::Gecko_CSSFontFaceRule_Create(
                 data.source_location.line as u32, data.source_location.column as u32
             ))
         };
         data.set_descriptors(&mut result.mDecl.mDescriptors);
