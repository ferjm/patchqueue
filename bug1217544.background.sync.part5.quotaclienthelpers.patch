# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  093c3e7979e639561ac179da9aab2f392d452c47
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: QuotaClient helpers. r=bkelly

diff --git a/dom/quota/ClientAction.cpp b/dom/quota/ClientAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.cpp
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/quota/ClientAction.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+void
+QuotaClientAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaClientAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual storage could have its QuotaClientActions canceled and then
+  // shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+QuotaClientAction::QuotaClientAction()
+  : mCanceled(false)
+{
+}
+
+QuotaClientAction::~QuotaClientAction()
+{
+}
+
+bool
+QuotaClientAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
diff --git a/dom/quota/ClientAction.h b/dom/quota/ClientAction.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.h
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_QuotaClientAction_h
+#define mozilla_dom_quota_QuotaClientAction_h
+
+#include "QuotaInfo.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+class QuotaClientAction
+{
+public:
+  class Resolver
+  {
+  public:
+    // Note: QuotaClientAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       QuotaClientAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple QuotaClientActions running on the same thread/QuotaClientContext.
+  // In theory this could be abstracted to a generic key/value map, but for now
+  // just explicitly provide accessors for the data we need.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread. Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: QuotaClientAction should hold Resolver ref until its ready to call
+  //       Resolve().
+  // Note: The "target" thread is determined when the QuotaClientAction is
+  //       scheduled on QuotaClientContext. The QuotaClientAction should not
+  //       assume any particular thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the QuotaClientAction is canceled. The
+  // QuotaClientAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT.
+  // If CancelOnInitiatingThread() is called after Resolve() has already ocurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the QuotaClientAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent calls
+  // should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread. If this QuotaClientAction will operate
+  // on the give storage ID then override this to return true.
+  // XXX virtual bool MatchesStorageId
+
+  NS_INLINE_DECL_REFCOUNTING(QuotaClientAction)
+
+protected:
+  QuotaClientAction();
+
+  // virtual because deleted through base class pointer.
+  virtual ~QuotaClientAction();
+
+  // Check if this QuotaClientAction has been canceled. May be called from any
+  // thread but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
+
+#endif // mozilla_dom_quota_QuotaClientAction_h
diff --git a/dom/quota/ClientContext.h b/dom/quota/ClientContext.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientContext.h
@@ -0,0 +1,223 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_ClientContext_h
+#define mozilla_dom_quota_ClientContext_h
+
+#include "Client.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+class DirectoryLock;
+class ClientAction;
+
+// The ClientContext class is RAII-style class for managing IO operations done
+// by quota clients.
+//
+// When a ClientContext is created it performs the complicated steps necessary
+// to initialize the QuotaManager. ClientAction objects dispatched on the
+// ClientContext are delayed until this initialization is complete. Once all
+// references to the ClientContext are gone, then the steps necessary to release
+// the QuotaManager are performed. After initialization the ClientContext holds
+// a self reference, so it will stay alive until one of three conditions occur:
+//
+// 1) The quota client will call ClientContext::AllowToClose() when all of the
+//    actors have removed themselves as listener.
+// 2) The QuotaManager aborts all operations so it can delete the files. In this
+//    case the QuotaManager calls ClientContext::AbortOperations() which in turn
+//    cancels all existing ClientAction objects.
+// 3) Browser shutdown occurs and the quota client calls
+//    ClientContext::CancelAll().
+//    XXX Maybe (3) needs to be handled inside ClientContext
+//
+// In either case, though, the ClientAction objects must be destroyed first to
+// allow the ClientContext to be destroyed.
+//
+// While the ClientContext performs operations asynchronously on threads, all of
+// methods in its public interface must be called on the same thread originally
+// used to create the ClientContext.
+//
+// As an invariant, all ClientContext objects must be destroyed before
+// permitting the "profile-before-change" shutdown event to complete.
+class ClientContext final
+{
+public:
+  // Define a class allowing other threads to hold the ClientContext alive. This
+  // also allows these other threads to safely close or cancel the ClientContext.
+  class ThreadsafeHandle final
+  {
+    friend class ClientContext;
+
+  public:
+    void AllowToClose();
+    void InvalidateAndAllowToClose();
+
+  private:
+    explicit ThreadsafeHandle(ClientContext* aContext);
+    ~ThreadsafeHandle();
+
+    // Disallow copying.
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
+    void ContextDestroyed(ClientContext* aContext);
+
+    // Cleared to allow the ClientContext to close. Only safe to access on
+    // owning thread.
+    RefPtr<ClientContext> mStrongRef;
+
+    // Used to support cancelation even while the ClientContext is already
+    // allowed to close. Cleared by ~ClientContext() calling ContextDestroyed().
+    // Only safe to access on owning thread.
+    ClientContext* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(quota::ClientContext::ThreadsafeHandle)
+  };
+
+  // An interface to be implemented by code wishing to use the ClientContext.
+  // XXX lifetime.
+  class Listener
+  {
+  public:
+    virtual void NoteClosing() = 0;
+  };
+
+  // Different objects hold references to the ClientContext while some work is
+  // being performed asynchronously. These objects must implement the Activity
+  // interface and register themselves with the AddActivity() method. When they
+  // are destroyed they must call RemoveActivity(). This allows the ClientContext
+  // to cancel any outstanding Activity work when the ClientContext is cancelled.
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+    // XXX
+    // virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
+  };
+
+  // Create a ClientContext. The given ClientAction will run on the QuotaManager
+  // IO thread. Note, this Action must be execute asynchronously.
+  static already_AddRefed<ClientContext>
+  Create(Listener* aListener, nsIPrincipal* aPrincipal,
+         Client::Type aClientType, nsIThread* aTarget,
+         ClientAction* aInitAction, ClientContext* aOldContext);
+
+  // Execute a given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the ClientContext.
+  void Dispatch(ClientAction* aAction);
+
+  // Cancel any ClientActions running or waiting to run. This should allow the
+  // ClientContext to be released.
+  //
+  // Only callable from the thread that created the ClientContext.
+  void CancelAll();
+
+  // True if CancelAll() has been called.
+  bool IsCanceled() const;
+
+  // Like CancelAll(), but also calls Listener::NoteClosing().
+  void Invalidate();
+
+  // Remove any self references and allow the ClientContext to be released when
+  // there are no more ClientActions to process.
+  void AllowToClose();
+
+  //XXX Cancel any ClientActions running or waiting to run that operate on the
+  // given storage ID.
+  //
+
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo&
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
+  // Tell the ClientContext that some state information has been orphaned in the
+  // data store and won't be cleaned up. The ClientContext will leave the marker
+  // in place to trigger cleanup the next times its opened.
+  void NoteOrphanedData();
+
+private:
+  class Data;
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_PREINIT,
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    RefPtr<ClientAction> mAction;
+  };
+
+  ClientContext(Listener* aListener, nsIPrincipal* principal,
+                Client::Type aClientType, nsIThread* aTarget,
+                ClientAction* aInitAction);
+  ~ClientContext();
+  void Init(ClientContext* aOldContext);
+  void Start();
+  void DispatchAction(ClientAction* aAction, bool aDoomData = false);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                   already_AddRefed<DirectoryLock> aDirectoryLock);
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
+
+  void
+  SetNextContext(ClientContext* aNextContext);
+
+  void
+  DoomTargetData();
+
+  RefPtr<Listener> mListener;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+  nsCOMPtr<nsIThread> mTarget;
+  Client::Type mClientType;
+  RefPtr<Data> mData;
+  State mState;
+  bool mOrphanedData;
+  QuotaInfo mQuotaInfo;
+  RefPtr<QuotaInitRunnable> mInitRunnable;
+  RefPtr<ClientAction> mInitAction;
+  nsTArray<PendingAction> mPendingActions;
+
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us. This creates
+  // a ref-cycle that keeps the ClientContext alive. The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  RefPtr<DirectoryLock> mDirectoryLock;
+  RefPtr<Context> mNextContext;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(ClientContext)
+};
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_quota_ClientContext_h
diff --git a/dom/quota/QuotaInfo.h b/dom/quota/QuotaInfo.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/QuotaInfo.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_QuotaInfo_h
+#define mozilla_dom_quota_QuotaInfo_h
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mSuffix;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+};
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_quota_QuotaInfo_h
diff --git a/dom/quota/moz.build b/dom/quota/moz.build
--- a/dom/quota/moz.build
+++ b/dom/quota/moz.build
@@ -10,30 +10,34 @@ XPIDL_SOURCES += [
     'nsIQuotaRequests.idl',
 ]
 
 XPIDL_MODULE = 'dom_quota'
 
 EXPORTS.mozilla.dom.quota += [
     'ActorsParent.h',
     'Client.h',
+    'ClientAction.h',
+    'ClientContext.h',
     'FileStreams.h',
     'OriginScope.h',
     'PersistenceType.h',
     'QuotaCommon.h',
+    'QuotaInfo.h',
     'QuotaManager.h',
     'QuotaManagerService.h',
     'QuotaObject.h',
     'SerializationHelpers.h',
     'UsageInfo.h',
 ]
 
 UNIFIED_SOURCES += [
     'ActorsChild.cpp',
     'ActorsParent.cpp',
+    'ClientAction.cpp',
     'FileStreams.cpp',
     'QuotaManagerService.cpp',
     'QuotaRequests.cpp',
 ]
 
 IPDL_SOURCES += [
     'PQuota.ipdl',
     'PQuotaRequest.ipdl',
