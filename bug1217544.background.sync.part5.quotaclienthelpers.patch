# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  093c3e7979e639561ac179da9aab2f392d452c47
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: QuotaClient helpers. r=bkelly

diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
--- a/dom/cache/Context.cpp
+++ b/dom/cache/Context.cpp
@@ -462,17 +462,17 @@ Context::QuotaInitRunnable::Run()
       // Execute the provided initialization Action.  The Action must Resolve()
       // before returning.
       mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
       MOZ_ASSERT(resolver->Resolved());
 
       mData = nullptr;
 
       // If the database was opened, then we should always succeed when creating
-      // the marker file.  If it wasn't opened successfully, then no need to
+      // the marker file. If it wasn't opened successfully, then no need to
       // create a marker file anyway.
       if (NS_SUCCEEDED(resolver->Result())) {
         MOZ_ALWAYS_SUCCEEDS(CreateMarkerFile(mQuotaInfo));
       }
 
       break;
     }
     // -------------------
diff --git a/dom/quota/ClientAction.cpp b/dom/quota/ClientAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.cpp
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/quota/ClientAction.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+void
+ClientAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual storage could have its ClientActions canceled and then
+  // shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+ClientAction::ClientAction()
+  : mCanceled(false)
+{
+}
+
+ClientAction::~ClientAction()
+{
+}
+
+bool
+ClientAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
diff --git a/dom/quota/ClientAction.h b/dom/quota/ClientAction.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.h
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_ClientAction_h
+#define mozilla_dom_quota_ClientAction_h
+
+#include "QuotaInfo.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+class ClientAction
+{
+public:
+  class Resolver
+  {
+  public:
+    // Note: ClientAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       ClientAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple ClientActions running on the same thread/ClientContext.
+  // In theory this could be abstracted to a generic key/value map, but for now
+  // just explicitly provide accessors for the data we need.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread. Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: ClientAction should hold Resolver ref until its ready to call
+  //       Resolve().
+  // Note: The "target" thread is determined when the ClientAction is
+  //       scheduled on ClientContext. The ClientAction should not
+  //       assume any particular thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the ClientAction is canceled. The
+  // ClientAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT.
+  // If CancelOnInitiatingThread() is called after Resolve() has already ocurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the ClientAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent calls
+  // should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread. If this ClientAction will operate
+  // on the give storage ID then override this to return true.
+  // XXX virtual bool MatchesStorageId
+
+  NS_INLINE_DECL_REFCOUNTING(ClientAction)
+
+protected:
+  ClientAction();
+
+  // virtual because deleted through base class pointer.
+  virtual ~ClientAction();
+
+  // Check if this ClientAction has been canceled. May be called from any
+  // thread but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
+
+#endif // mozilla_dom_quota_ClientAction_h
diff --git a/dom/quota/ClientContext.cpp b/dom/quota/ClientContext.cpp
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientContext.cpp
@@ -0,0 +1,1249 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ClientContext.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/DebugOnly.h"
+#include "mozIStorageConnection.h"
+#include "nsIFile.h"
+#include "nsIPrincipal.h"
+#include "nsProxyRelease.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::quota::ClientAction;
+using mozilla::dom::quota::QuotaInfo;
+
+class NullClientAction final : public ClientAction
+{
+public:
+  NullClientAction()
+  {
+  }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
+  {
+    // Resolve success immediately. This ClientAction does no actual work.
+    MOZ_ASSERT(aResolver);
+    aResolver->Resolve(NS_OK);
+  }
+};
+
+} // namespace
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+using mozilla::DebugOnly;
+
+class ClientContext::Data final : public ClientAction::Data
+{
+public:
+  explicit Data(nsIThread* aTarget)
+    : mTarget(aTarget)
+  {
+    MOZ_ASSERT(mTarget);
+  }
+
+  virtual mozIStorageConnection*
+  GetConnection() const override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    return mConnection;
+  }
+
+  virtual void
+  SetConnection(mozIStorageConnection* aConn) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(!mConnection);
+    mConnection = aConn;
+    MOZ_ASSERT(mConnection);
+  }
+
+private:
+  ~Data()
+  {
+    // We could proxy release our data here, but instead just assert. The
+    // ClientContext code should guarantee that we are destroyed on the target
+    // thread once the connection is initialized. If we're not, then
+    // QuotaManager might race and try to clear the origin out from under us.
+    MOZ_ASSERT_IF(mConnection, mTarget == NS_GetCurrentThread());
+  }
+
+  nsCOMPtr<nsIThread> mTarget;
+  nsCOMPtr<mozIStorageConnection> mConnection;
+
+  // Threadsafe counting because we're created on the PBackground thread
+  // and destroyed on the target IO thread.
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ClientContext::Data)
+};
+
+// Executed to perform the complicated dance of steps necessary to initialize
+// the QuotaManager. This must be performed for each origin before any disk
+// IO occurrs.
+class ClientContext::QuotaInitRunnable final : public nsIRunnable
+                                             , public OpenDirectoryListener
+{
+public:
+  QuotaInitRunnable(ClientContext* aContext,
+                    nsIPrincipal* aPrincipal,
+                    Client::Type aClientType,
+                    const nsAString& aDirName,
+                    Data* aData,
+                    nsIThread* aTarget,
+                    ClientAction* aInitAction)
+    : mContext(aContext)
+    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
+    , mPrincipal(aPrincipal)
+    , mQuotaClientType(aClientType)
+    , mDirName(aDirName)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mInitAction(aInitAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mResult(NS_OK)
+    , mState(STATE_INIT)
+    , mCanceled(false)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mPrincipal);
+    MOZ_ASSERT(!mDirName.IsEmpty());
+    MOZ_ASSERT(mData);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mInitiatingThread);
+    MOZ_ASSERT(mInitAction);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_GET_INFO;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+
+    return rv;
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(!mCanceled);
+    mCanceled = true;
+    mInitAction->CancelOnInitiatingThread();
+  }
+
+  void OpenDirectory();
+
+  // OpenDirectoryListener methods.
+  virtual void
+  DirectoryLockAcquired(DirectoryLock* aLock) override;
+
+  virtual void
+  DirectoryLockFailed() override;
+
+private:
+  class SyncResolver final : public ClientAction::Resolver
+  {
+  public:
+    SyncResolver()
+      : mResolved(false)
+      , mResult(NS_OK)
+    { }
+
+    virtual void
+    Resolve(nsresult aRv) override
+    {
+      MOZ_ASSERT(!mResolved);
+      mResolved = true;
+      mResult = aRv;
+    }
+
+    bool Resolved() const { return mResolved; }
+    nsresult Result() const { return mResult; }
+
+  private:
+    ~SyncResolver() { }
+
+    bool mResolved;
+    nsresult mResult;
+
+    NS_INLINE_DECL_REFCOUNTING(ClientContext::QuotaInitRunnable::SyncResolver,
+                               override)
+  };
+
+  ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mInitAction);
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_GET_INFO,
+    STATE_CREATE_QUOTA_MANAGER,
+    STATE_OPEN_DIRECTORY,
+    STATE_WAIT_FOR_DIRECTORY_LOCK,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Complete(nsresult aResult)
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
+
+    MOZ_ASSERT(NS_SUCCEEDED(mResult));
+    mResult = aResult;
+
+    mState = STATE_COMPLETING;
+    MOZ_ALWAYS_SUCCEEDS(
+      mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mPrincipal = nullptr;
+    mInitAction = nullptr;
+  }
+
+  RefPtr<ClientContext> mContext;
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+  RefPtr<nsIPrincipal> mPrincipal;
+  Client::Type mQuotaClientType;
+  nsString mDirName;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<ClientAction> mInitAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsresult mResult;
+  QuotaInfo mQuotaInfo;
+  RefPtr<DirectoryLock> mDirectoryLock;
+  State mState;
+  Atomic<bool> mCanceled;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+void
+ClientContext::QuotaInitRunnable::OpenDirectory()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
+             mState == STATE_OPEN_DIRECTORY);
+  MOZ_ASSERT(QuotaManager::Get());
+
+  // QuotaManager::OpenDirectory() will hold a reference to us as
+  // a listener. We will then get DirectoryLockAcquired() on the owning
+  // thread when it is safe to access our storage directory.
+  mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
+  QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
+                                     mQuotaInfo.mGroup,
+                                     mQuotaInfo.mOrigin,
+                                     mQuotaInfo.mIsApp,
+                                     mQuotaClientType,
+                                     /* aExclusive */ false,
+                                     this);
+}
+
+void
+ClientContext::QuotaInitRunnable::DirectoryLockAcquired(DirectoryLock* aLock)
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  mDirectoryLock = aLock;
+
+  if (mCanceled) {
+    Complete(NS_ERROR_ABORT);
+    return;
+  }
+
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+
+  mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+  nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Complete(rv);
+    return;
+  }
+}
+
+void
+ClientContext::QuotaInitRunnable::DirectoryLockFailed()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  NS_WARNING("Failed to acquire a directory lock!");
+
+  Complete(NS_ERROR_FAILURE);
+}
+
+NS_IMPL_ISUPPORTS(ClientContext::QuotaInitRunnable, nsIRunnable);
+
+// The QuotaManager init state machine is represented in the following diagram:
+//
+//    +---------------+
+//    |     Start     |      Resolve(error)
+//    | (Orig Thread) +---------------------+
+//    +-------+-------+                     |
+//            |                             |
+// +----------v-----------+                 |
+// |       GetInfo        |  Resolve(error) |
+// |    (Main Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |  CreateQuotaManager  |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |    OpenDirectory     |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// | WaitForDirectoryLock |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v------------+                |
+// |EnsureOriginInitialized| Resolve(error) |
+// |   (Quota IO Thread)   +----------------+
+// +----------+------------+                |
+//            |                             |
+// +----------v------------+                |
+// |     RunOnTarget       | Resolve(error) |
+// |   (Target Thread)     +----------------+
+// +----------+------------+                |
+//            |                             |
+//  +---------v---------+            +------v------+
+//  |      Running      |            |  Completing |
+//  | (Target Thread)   +------------>(Orig Thread)|
+//  +-------------------+            +------+------+
+//                                          |
+//                                    +-----v----+
+//                                    | Complete |
+//                                    +----------+
+//
+// The initialization process proceeds through the main states. If an error
+// occurs, then we transition to Completing state back on the original thread.
+NS_IMETHODIMP
+ClientContext::QuotaInitRunnable::Run()
+{
+  // May run on different threads depending on the state. See individual
+  // state cases for thread assertions.
+
+  RefPtr<SyncResolver> resolver = new SyncResolver();
+
+  switch(mState) {
+    // -----------------------------------
+    case STATE_GET_INFO:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      nsresult rv = QuotaManager::GetInfoFromPrincipal(mPrincipal,
+                                                       &mQuotaInfo.mSuffix,
+                                                       &mQuotaInfo.mGroup,
+                                                       &mQuotaInfo.mOrigin,
+                                                       &mQuotaInfo.mIsApp);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_CREATE_QUOTA_MANAGER;
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // ----------------------------------
+    case STATE_CREATE_QUOTA_MANAGER:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (mCanceled || QuotaManager::IsShuttingDown()) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      if (QuotaManager::Get()) {
+        OpenDirectory();
+        return NS_OK;
+      }
+
+      mState = STATE_OPEN_DIRECTORY;
+      QuotaManager::GetOrCreate(this);
+      break;
+    }
+    // ----------------------------------
+    case STATE_OPEN_DIRECTORY:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (NS_WARN_IF(!QuotaManager::Get())) {
+        resolver->Resolve(NS_ERROR_FAILURE);
+        break;
+      }
+
+      OpenDirectory();
+      break;
+    }
+    // ----------------------------------
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+    {
+      AssertIsOnIOThread();
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
+                                                  mQuotaInfo.mSuffix,
+                                                  mQuotaInfo.mGroup,
+                                                  mQuotaInfo.mOrigin,
+                                                  mQuotaInfo.mIsApp,
+                                                  getter_AddRefs(mQuotaInfo.mDir));
+      if (NS_FAILED(rv)) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_RUN_ON_TARGET;
+
+      MOZ_ALWAYS_SUCCEEDS(
+        mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+
+      mState = STATE_RUNNING;
+
+      // Execute the provided initialization ClientAction. The ClientAction must
+      // Resolve() before returning.
+      mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
+      MOZ_ASSERT(resolver->Resolved());
+
+      mData = nullptr;
+
+      // If the database was opened, then we should always succeed when creating
+      // the marker file. If it wasn't opened successfully, then no need to
+      // create a marker file anyway.
+      if (NS_SUCCEEDED(resolver->Result())) {
+        MOZ_ALWAYS_SUCCEEDS(FileUtils::CreateMarkerFile(mQuotaInfo, mDirName));
+      }
+
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+      mInitAction->CompleteOnInitiatingThread(mResult);
+      mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
+      mState = STATE_COMPLETE;
+
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----
+    case STATE_WAIT_FOR_DIRECTORY_LOCK:
+    default:
+    {
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+    }
+  }
+
+  if (resolver->Resolved()) {
+    Complete(resolver->Result());
+  }
+
+  return NS_OK;
+}
+
+// Runnable wrapper around ClientAction objects dispatched on the ClientContext.
+// This runnable executes the ClientAction on the appropriate threads while the
+// ClientContext is initialized.
+class ClientContext::ClientActionRunnable final : public nsIRunnable
+                                                , public ClientAction::Resolver
+                                                , public ClientContext::Activity
+{
+public:
+  ClientActionRunnable(ClientContext* aContext, Data* aData,
+                       nsIEventTarget* aTarget, ClientAction* aAction,
+                       const QuotaInfo& aQuotaInfo)
+    : mContext(aContext)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaInfo(aQuotaInfo)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+    , mExecutingRunOnTarget(false)
+  {
+    MOZ_ASSERT(mContext);
+    // mData may be nullptr.
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed.
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(ClientActionRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  // XXX MatchesCacheId
+
+  virtual void
+  Cancel() override
+  {
+    NS_ASSERT_OWNINGTHREAD(ClientActionRunnable);
+    mAction->CancelOnInitiatingThread();
+  }
+
+  virtual void Resolve(nsresult aRv) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(mState == STATE_RUNNING);
+
+    mResult = aRv;
+
+    // We ultimately must complete on the initiating thread, but bounce through
+    // the current thread again to ensure that we don't destroy objects and
+    // state out from under the currently running action's stack.
+    mState = STATE_RESOLVING;
+
+    // If we were resolved synchronously within ClientAction::RunOnTarget()
+    // then we can avoid a thread bounce and just resolve once RunOnTarget()
+    // returns. The Run() method will handle this by looking at mState after
+    // RunOnTarget() returns.
+    if (mExecutingRunOnTarget) {
+      return;
+    }
+
+    // Otherwise we are in an asynchronous resolve. And must perform a thread
+    // bounce to run on the target thread again.
+    MOZ_ALWAYS_SUCCEEDS(
+      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+private:
+  ~ClientActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(ClientActionRunnable);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->RemoveActivity(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_RESOLVING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  RefPtr<ClientContext> mContext;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  RefPtr<ClientAction> mAction;
+  const QuotaInfo mQuotaInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+  // Only accessible on target thread;
+  bool mExecutingRunOnTarget;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(ClientContext::ClientActionRunnable, nsIRunnable);
+
+// The ClientActionRunnable has a simpler state machine.  It basically needs to
+// run the action on the target thread and then complete on the original thread.
+//
+//   +-------------+
+//   |    Start    |
+//   |(Orig Thread)|
+//   +-----+-------+
+//         |
+// +-------v---------+
+// |  RunOnTarget    |
+// |Target IO Thread)+---+ Resolve()
+// +-------+---------+   |
+//         |             |
+// +-------v----------+  |
+// |     Running      |  |
+// |(Target IO Thread)|  |
+// +------------------+  |
+//         | Resolve()   |
+// +-------v----------+  |
+// |     Resolving    <--+                   +-------------+
+// |                  |                      |  Completing |
+// |(Target IO Thread)+---------------------->(Orig Thread)|
+// +------------------+                      +-------+-----+
+//                                                   |
+//                                                   |
+//                                              +----v---+
+//                                              |Complete|
+//                                              +--------+
+//
+// Its important to note that synchronous actions will effectively Resolve()
+// out of the Running state immediately. Asynchronous ClientActions may remain
+// in the Running state for some time, but normally the ClientActionRunnable
+// itself does not see any execution there. Its all handled internal to the
+// ClientAction.
+NS_IMETHODIMP
+ClientContext::ClientActionRunnable::Run()
+{
+  switch(mState) {
+    // ----------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      MOZ_ASSERT(!mExecutingRunOnTarget);
+
+      // Note that we are calling RunOnTarget(). This lets us detect
+      // if Resolve() is called synchronously.
+      AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
+      mExecutingRunOnTarget = true;
+
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaInfo, mData);
+
+      mData = nullptr;
+
+      // Resolve was called synchronously from RunOnTarget(). We can
+      // immediately move to completing now since we are sure RunOnTarget()
+      // completed.
+      if (mState == STATE_RESOLVING) {
+        // Use recursion instead of switch case fall-through...  Seems slightly
+        // easier to understand.
+        Run();
+      }
+
+      break;
+    }
+    // -----------------
+    case STATE_RESOLVING:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // The call to ClientAction::RunOnTarget() must have returned now if we
+      // are running on the target thread again.  We may now proceed with
+      // completion.
+      mState = STATE_COMPLETING;
+      // Shutdown must be delayed until all ClientContexts are destroyed. Crash
+      // for this invariant violation.
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(ClientActionRunnable);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of the
+      // threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----------------
+    default:
+    {
+      MOZ_CRASH("unexpected state in ClientActionRunnable");
+      break;
+    }
+  }
+  return NS_OK;
+}
+
+void
+ClientContext::ThreadsafeHandle::AllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    AllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all ClientContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+void
+ClientContext::ThreadsafeHandle::InvalidateAndAllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    InvalidateAndAllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all ClientContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+ClientContext::ThreadsafeHandle::ThreadsafeHandle(ClientContext* aContext)
+  : mStrongRef(aContext)
+  , mWeakRef(aContext)
+  , mOwningThread(NS_GetCurrentThread())
+{
+}
+
+ClientContext::ThreadsafeHandle::~ThreadsafeHandle()
+{
+  // Normally we only touch mStrongRef on the owning thread. This is safe,
+  // however, because when we do use mStrongRef on the owning thread we are
+  // always holding a strong ref to the ThreadsafeHandle via the owning
+  // runnable. So we cannot run the ThreadsafeHandle destructor simultaneously.
+  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  NS_ProxyRelease(mOwningThread, mStrongRef.forget());
+}
+
+void
+ClientContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+
+  // A ClientContext "closes" when its ref count drops to zero. Dropping this
+  // strong ref is necessary, but not sufficient for the close to occur.
+  // Any outstanding IO will continue and keep the ClientContext alive. Once
+  // the ClientContext is idle, it will be destroyed.
+
+  // First, tell the context to flush any target thread shared data. This
+  // data must be released on the target thread prior to running the
+  // ClientContext destructor. This will schedule a ClientAction which ensures
+  // that the ~ClientContext() is not immediately executed when we drop the
+  // strong ref.
+  if (mStrongRef) {
+    mStrongRef->DoomTargetData();
+  }
+
+  // Now drop our strong ref and let ClientContext finish running any
+  // outstanding ClientActions.
+  mStrongRef = nullptr;
+}
+
+void
+ClientContext::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  // Cancel the ClientContext through the weak reference. This means we can
+  // allow the ClientContext to close by dropping the strong ref, but then
+  // still cancel ongoing IO if necessary.
+  if (mWeakRef) {
+    mWeakRef->Invalidate();
+  }
+  // We should synchronously have AllowToCloseOnOwningThread called when
+  // the ClientContext is canceled.
+  MOZ_ASSERT(!mStrongRef);
+}
+
+void
+ClientContext::ThreadsafeHandle::ContextDestroyed(ClientContext* aContext)
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  MOZ_ASSERT(!mStrongRef);
+  MOZ_ASSERT(mWeakRef);
+  MOZ_ASSERT(mWeakRef == aContext);
+  mWeakRef = nullptr;
+}
+
+// static
+already_AddRefed<ClientContext>
+ClientContext::Create(Listener* aListener, nsIPrincipal* aPrincipal,
+                      Client::Type aClientType, const nsAString& aDirName,
+                      nsIThread* aTarget, ClientAction* aInitAction,
+                      ClientContext* aOldContext)
+{
+  RefPtr<ClientContext> context = new ClientContext(aListener, aPrincipal,
+                                                    aClientType, aDirName,
+                                                    aTarget, aInitAction);
+  context->Init(aOldContext);
+  return context.forget();
+}
+
+ClientContext::ClientContext(Listener* aListener, nsIPrincipal* aPrincipal,
+                             Client::Type aClientType, const nsAString& aDirName,
+                             nsIThread* aTarget, ClientAction* aInitAction)
+  : mListener(aListener)
+  , mPrincipal(aPrincipal)
+  , mTarget(aTarget)
+  , mClientType(aClientType)
+  , mDirName(aDirName)
+  , mData(new Data(aTarget))
+  , mState(STATE_CONTEXT_PREINIT)
+  , mOrphanedData(false)
+  , mInitAction(aInitAction)
+{
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(mTarget);
+  MOZ_ASSERT(!mDirName.IsEmpty());
+}
+
+void
+ClientContext::Dispatch(ClientAction* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(aAction);
+
+  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT ||
+             mState == STATE_CONTEXT_PREINIT) {
+    PendingAction* pending = mPendingActions.AppendElement();
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aAction);
+}
+
+void
+ClientContext::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+
+  // In PREINIT state we have not dispatch the init action yet. Just
+  // forget it.
+  if (mState == STATE_CONTEXT_PREINIT) {
+    MOZ_ASSERT(!mInitRunnable);
+    mInitAction = nullptr;
+
+  // In INIT state we have dispatched the runnable, but not received the
+  // async completion yet. Cancel the runnable, but don't forget about it
+  // until we get OnQuotaInit() callback.
+  } else if (mState == STATE_CONTEXT_INIT) {
+    mInitRunnable->Cancel();
+  }
+
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  {
+    ActivityList::ForwardIterator iter(mActivityList);
+    while (iter.HasMore()) {
+      iter.GetNext()->Cancel();
+    }
+  }
+  AllowToClose();
+}
+
+bool
+ClientContext::IsCanceled() const
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  return mState == STATE_CONTEXT_CANCELED;
+}
+
+void
+ClientContext::Invalidate()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  mListener->NoteClosing();
+  CancelAll();
+}
+
+void
+ClientContext::AllowToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->AllowToClose();
+  }
+}
+
+/* XXX
+void
+ClientContext::CancelForCacheId(CacheId aCacheId)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  // Remove matching pending actions
+  for (int32_t i = mPendingActions.Length() - 1; i >= 0; --i) {
+    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
+      mPendingActions.RemoveElementAt(i);
+    }
+  }
+
+  // Cancel activities and let them remove themselves
+  ActivityList::ForwardIterator iter(mActivityList);
+  while (iter.HasMore()) {
+    Activity* activity = iter.GetNext();
+    if (activity->MatchesCacheId(aCacheId)) {
+      activity->Cancel();
+    }
+  }
+}*/
+
+ClientContext::~ClientContext()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(mListener);
+  MOZ_ASSERT(!mData);
+
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->ContextDestroyed(this);
+  }
+
+  mListener->RemoveClientContext(this);
+
+  if (mQuotaInfo.mDir && !mOrphanedData) {
+    MOZ_ALWAYS_SUCCEEDS(FileUtils::DeleteMarkerFile(mQuotaInfo, mDirName));
+  }
+
+  if (mNextContext) {
+    mNextContext->Start();
+  }
+}
+
+void
+ClientContext::Init(ClientContext* aOldContext)
+{
+  NS_ASSERT_OWNINGTHREAD(Context);
+
+  if (aOldContext) {
+    aOldContext->SetNextContext(this);
+    return;
+  }
+
+  Start();
+}
+
+void
+ClientContext::Start()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+
+  // Previous context closing delayed our start, but then we were canceled.
+  // In this case, just do nothing here.
+  if (mState == STATE_CONTEXT_CANCELED) {
+    MOZ_ASSERT(!mInitRunnable);
+    MOZ_ASSERT(!mInitAction);
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
+  MOZ_ASSERT(!mInitRunnable);
+
+  mInitRunnable = new QuotaInitRunnable(this, mPrincipal, mClientType, mDirName,
+                                        mData, mTarget, mInitAction);
+  mInitAction = nullptr;
+
+  mState = STATE_CONTEXT_INIT;
+
+  nsresult rv = mInitRunnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all ClientContexts are destroyed. Shutdown
+    // must also prevent any new ClientContexts from being constructed. Crash
+    // for this invariant violation.
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+ClientContext::DispatchAction(ClientAction* aAction, bool aDoomData)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+
+  RefPtr<ClientActionRunnable> runnable =
+    new ClientActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
+
+  if (aDoomData) {
+    mData = nullptr;
+  }
+
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all ClientContexts are destroyed. Crash
+    // for this invariant violation.
+    MOZ_CRASH("Failed to dispatch ClientActionRunnable to target thread.");
+  }
+  AddActivity(runnable);
+}
+
+void
+ClientContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                           already_AddRefed<DirectoryLock> aDirectoryLock)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+
+  MOZ_ASSERT(mInitRunnable);
+  mInitRunnable = nullptr;
+
+  mQuotaInfo = aQuotaInfo;
+
+  // Always save the directory lock to ensure QuotaManager does not shutdown
+  // before the ClientContext has gone away.
+  MOZ_ASSERT(!mDirectoryLock);
+  mDirectoryLock = aDirectoryLock;
+
+  // If we opening the context failed, but we were not explicitly canceled,
+  // still treat the entire context as canceled. We don't want to allow
+  // new actions to be dispatched. We also cannot leave the context in
+  // the INIT state after failing to open.
+  if (NS_FAILED(aRv)) {
+    mState = STATE_CONTEXT_CANCELED;
+  }
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    mThreadsafeHandle->AllowToClose();
+    // ClientContext will destruct after return here and last ref is released.
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+ClientContext::AddActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+  mActivityList.AppendElement(aActivity);
+}
+
+void
+ClientContext::RemoveActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+}
+
+void
+ClientContext::NoteOrphanedData()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  // This may be called more than once.
+  mOrphanedData = true;
+}
+
+already_AddRefed<ClientContext::ThreadsafeHandle>
+ClientContext::CreateThreadsafeHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  if (!mThreadsafeHandle) {
+    mThreadsafeHandle = new ThreadsafeHandle(this);
+  }
+  RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
+  return ref.forget();
+}
+
+void
+ClientContext::SetNextContext(ClientContext* aNextContext)
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(aNextContext);
+  MOZ_ASSERT(!mNextContext);
+  mNextContext = aNextContext;
+}
+
+void
+ClientContext::DoomTargetData()
+{
+  NS_ASSERT_OWNINGTHREAD(ClientContext);
+  MOZ_ASSERT(mData);
+
+  // We are about to drop our reference to the Data.We need to ensure that
+  // the ~ClientContext() destructor does not run until contents of Data have
+  // been released on the Target thread.
+
+  // Dispatch a no-op ClientAction. This will hold the ClientContext alive
+  // through a roundtrip to the target thread and back to the owning thread.
+  // The ref to the Data object is cleared on the owning thread after creating
+  // the ClientActionRunnable, but before dispatching it.
+  RefPtr<ClientAction> action = new NullClientAction();
+  DispatchAction(action, true /* doomed data */);
+
+  MOZ_ASSERT(!mData);
+}
+
+// FileUtils
+
+namespace {
+
+nsresult
+GetMarkerFileHandle(const QuotaInfo& aQuotaInfo,
+                    const nsAString& aDirName,
+                    nsIFile** aFileOut)
+{
+  MOZ_ASSERT(aFileOut);
+
+  nsCOMPtr<nsIFile> marker;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(marker));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = marker->Append(aDirName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = marker->Append(NS_LITERAL_STRING("context_open.marker"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  marker.forget(aFileOut);
+
+  return rv;
+}
+
+} // anonymous namespace
+
+nsresult
+FileUtils::CreateMarkerFile(const QuotaInfo& aQuotaInfo,
+                            const nsAString& aDirName)
+{
+  nsCOMPtr<nsIFile> marker;
+  nsresult rv = GetMarkerFileHandle(aQuotaInfo, aDirName,
+                                    getter_AddRefs(marker));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = marker->Create(nsIFile::NORMAL_FILE_TYPE, 0644);
+  if (rv == NS_ERROR_FILE_ALREADY_EXISTS) {
+    rv = NS_OK;
+  }
+
+  // Note, we don't need to fsync here. We only care about actually
+  // writing the marker if later modifications to the data store are
+  // actually flushed to the disk. If the OS crashes before the marker
+  // is written then we are ensured no other changes to the data store
+  // were flushed either.
+
+  return rv;
+}
+
+// static
+nsresult
+FileUtils::DeleteMarkerFile(const QuotaInfo& aQuotaInfo,
+                            const nsAString& aDirName)
+{
+  nsCOMPtr<nsIFile> marker;
+  nsresult rv = GetMarkerFileHandle(aQuotaInfo, aDirName,
+                                    getter_AddRefs(marker));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = marker->Remove(/* recursive = */ false);
+  if (rv == NS_ERROR_FILE_NOT_FOUND ||
+      rv == NS_ERROR_FILE_TARGET_DOES_NOT_EXIST) {
+    rv = NS_OK;
+  }
+
+  // Again, no fsync is necessary. If the OS crashes before the file
+  // removal is flushed, then the user should search for stale data on
+  // startup. This will cause the next data store access to be a bit slow,
+  // but it seems appropriate after an OS crash.
+
+  return NS_OK;
+}
+
+// static
+bool
+FileUtils::MarkerFileExists(const QuotaInfo& aQuotaInfo,
+                            const nsAString& aDirName)
+{
+  nsCOMPtr<nsIFile> marker;
+  nsresult rv = GetMarkerFileHandle(aQuotaInfo, aDirName,
+                                    getter_AddRefs(marker));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  bool exists = false;
+  rv = marker->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return false; }
+
+  return exists;
+}
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/quota/ClientContext.h b/dom/quota/ClientContext.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientContext.h
@@ -0,0 +1,255 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_ClientContext_h
+#define mozilla_dom_quota_ClientContext_h
+
+#include "Client.h"
+#include "ClientAction.h"
+#include "nsTObserverArray.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+class DirectoryLock;
+
+// The ClientContext class is RAII-style class for managing IO operations done
+// by quota clients.
+//
+// When a ClientContext is created it performs the complicated steps necessary
+// to initialize the QuotaManager. ClientAction objects dispatched on the
+// ClientContext are delayed until this initialization is complete. Once all
+// references to the ClientContext are gone, then the steps necessary to release
+// the QuotaManager are performed. After initialization the ClientContext holds
+// a self reference, so it will stay alive until one of three conditions occur:
+//
+// 1) The quota client will call ClientContext::AllowToClose() when all of the
+//    actors have removed themselves as listener.
+// 2) The QuotaManager aborts all operations so it can delete the files. In this
+//    case the QuotaManager calls ClientContext::AbortOperations() which in turn
+//    cancels all existing ClientAction objects.
+// 3) Browser shutdown occurs and the quota client calls
+//    ClientContext::CancelAll().
+//    XXX Maybe (3) needs to be handled inside ClientContext
+//
+// In either case, though, the ClientAction objects must be destroyed first to
+// allow the ClientContext to be destroyed.
+//
+// While the ClientContext performs operations asynchronously on threads, all of
+// methods in its public interface must be called on the same thread originally
+// used to create the ClientContext.
+//
+// As an invariant, all ClientContext objects must be destroyed before
+// permitting the "profile-before-change" shutdown event to complete.
+class ClientContext final
+{
+public:
+  // Define a class allowing other threads to hold the ClientContext alive. This
+  // also allows these other threads to safely close or cancel the ClientContext.
+  class ThreadsafeHandle final
+  {
+    friend class ClientContext;
+
+  public:
+    void AllowToClose();
+    void InvalidateAndAllowToClose();
+
+  private:
+    explicit ThreadsafeHandle(ClientContext* aContext);
+    ~ThreadsafeHandle();
+
+    // Disallow copying.
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
+    void AllowToCloseOnOwningThread();
+    void InvalidateAndAllowToCloseOnOwningThread();
+
+    void ContextDestroyed(ClientContext* aContext);
+
+    // Cleared to allow the ClientContext to close. Only safe to access on
+    // owning thread.
+    RefPtr<ClientContext> mStrongRef;
+
+    // Used to support cancelation even while the ClientContext is already
+    // allowed to close. Cleared by ~ClientContext() calling ContextDestroyed().
+    // Only safe to access on owning thread.
+    ClientContext* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(quota::ClientContext::ThreadsafeHandle)
+  };
+
+  // An interface to be implemented by code wishing to use the ClientContext.
+  class Listener
+  {
+    NS_INLINE_DECL_REFCOUNTING(quota::ClientContext::Listener)
+
+  public:
+    virtual void NoteClosing() = 0;
+    virtual void RemoveClientContext(ClientContext* aContext) = 0;
+
+  private:
+    Listener() {};
+    virtual ~Listener() {};
+  };
+
+  // Different objects hold references to the ClientContext while some work is
+  // being performed asynchronously. These objects must implement the Activity
+  // interface and register themselves with the AddActivity() method. When they
+  // are destroyed they must call RemoveActivity(). This allows the ClientContext
+  // to cancel any outstanding Activity work when the ClientContext is cancelled.
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+    // XXX
+    // virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
+  };
+
+  // Create a ClientContext. The given ClientAction will run on the QuotaManager
+  // IO thread. Note, this Action must be execute asynchronously.
+  static already_AddRefed<ClientContext>
+  Create(Listener* aListener, nsIPrincipal* aPrincipal,
+         Client::Type aClientType, const nsAString& aDirName,
+         nsIThread* aTarget, ClientAction* aInitAction,
+         ClientContext* aOldContext);
+
+  // Execute a given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the ClientContext.
+  void Dispatch(ClientAction* aAction);
+
+  // Cancel any ClientActions running or waiting to run. This should allow the
+  // ClientContext to be released.
+  //
+  // Only callable from the thread that created the ClientContext.
+  void CancelAll();
+
+  // True if CancelAll() has been called.
+  bool IsCanceled() const;
+
+  // Like CancelAll(), but also calls Listener::NoteClosing().
+  void Invalidate();
+
+  // Remove any self references and allow the ClientContext to be released when
+  // there are no more ClientActions to process.
+  void AllowToClose();
+
+  //XXX Cancel any ClientActions running or waiting to run that operate on the
+  // given storage ID.
+  //
+
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo&
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
+  // Tell the ClientContext that some state information has been orphaned in the
+  // data store and won't be cleaned up. The ClientContext will leave the marker
+  // in place to trigger cleanup the next times its opened.
+  void NoteOrphanedData();
+
+private:
+  class Data;
+  class QuotaInitRunnable;
+  class ClientActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_PREINIT,
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    RefPtr<ClientAction> mAction;
+  };
+
+  ClientContext(Listener* aListener, nsIPrincipal* principal,
+                Client::Type aClientType, const nsAString& aDirName,
+                nsIThread* aTarget, ClientAction* aInitAction);
+  ~ClientContext();
+  void Init(ClientContext* aOldContext);
+  void Start();
+  void DispatchAction(ClientAction* aAction, bool aDoomData = false);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                   already_AddRefed<DirectoryLock> aDirectoryLock);
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
+
+  void
+  SetNextContext(ClientContext* aNextContext);
+
+  void
+  DoomTargetData();
+
+  RefPtr<Listener> mListener;
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+  nsCOMPtr<nsIThread> mTarget;
+  Client::Type mClientType;
+  nsString mDirName;
+  RefPtr<Data> mData;
+  State mState;
+  bool mOrphanedData;
+  QuotaInfo mQuotaInfo;
+  RefPtr<QuotaInitRunnable> mInitRunnable;
+  RefPtr<ClientAction> mInitAction;
+  nsTArray<PendingAction> mPendingActions;
+
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us. This creates
+  // a ref-cycle that keeps the ClientContext alive. The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  RefPtr<DirectoryLock> mDirectoryLock;
+  RefPtr<ClientContext> mNextContext;
+
+public:
+  NS_INLINE_DECL_REFCOUNTING(ClientContext)
+};
+
+class FileUtils
+{
+  friend class ClientContext;
+
+public:
+  // The ClientContext marker file can be used by users of ClientContext to
+  // identify a previous session that was not cleanly shutdown.
+  static bool
+  MarkerFileExists(const QuotaInfo& aQuotaInfo, const nsAString& aDirName);
+
+private:
+  FileUtils() {}
+
+  static nsresult
+  CreateMarkerFile(const QuotaInfo& aQuotaInfo, const nsAString& aDirName);
+
+  static nsresult
+  DeleteMarkerFile(const QuotaInfo& aQuotaInfo, const nsAString& aDirName);
+};
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_quota_ClientContext_h
diff --git a/dom/quota/QuotaInfo.h b/dom/quota/QuotaInfo.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/QuotaInfo.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_QuotaInfo_h
+#define mozilla_dom_quota_QuotaInfo_h
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mSuffix;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+};
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_quota_QuotaInfo_h
diff --git a/dom/quota/moz.build b/dom/quota/moz.build
--- a/dom/quota/moz.build
+++ b/dom/quota/moz.build
@@ -10,30 +10,35 @@ XPIDL_SOURCES += [
     'nsIQuotaRequests.idl',
 ]
 
 XPIDL_MODULE = 'dom_quota'
 
 EXPORTS.mozilla.dom.quota += [
     'ActorsParent.h',
     'Client.h',
+    'ClientAction.h',
+    'ClientContext.h',
     'FileStreams.h',
     'OriginScope.h',
     'PersistenceType.h',
     'QuotaCommon.h',
+    'QuotaInfo.h',
     'QuotaManager.h',
     'QuotaManagerService.h',
     'QuotaObject.h',
     'SerializationHelpers.h',
     'UsageInfo.h',
 ]
 
 UNIFIED_SOURCES += [
     'ActorsChild.cpp',
     'ActorsParent.cpp',
+    'ClientAction.cpp',
+    'ClientContext.cpp',
     'FileStreams.cpp',
     'QuotaManagerService.cpp',
     'QuotaRequests.cpp',
 ]
 
 IPDL_SOURCES += [
     'PQuota.ipdl',
     'PQuotaRequest.ipdl',
