# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  093c3e7979e639561ac179da9aab2f392d452c47
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: QuotaClient helpers. r=bkelly

diff --git a/dom/quota/ClientAction.cpp b/dom/quota/ClientAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.cpp
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/quota/ClientAction.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+void
+QuotaClientAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaClientAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual storage could have its QuotaClientActions canceled and then
+  // shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+QuotaClientAction::QuotaClientAction()
+  : mCanceled(false)
+{
+}
+
+QuotaClientAction::~QuotaClientAction()
+{
+}
+
+bool
+QuotaClientAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
diff --git a/dom/quota/ClientAction.h b/dom/quota/ClientAction.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/ClientAction.h
@@ -0,0 +1,103 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_QuotaClientAction_h
+#define mozilla_dom_quota_QuotaClientAction_h
+
+#include "QuotaInfo.h"
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+class QuotaClientAction
+{
+public:
+  class Resolver
+  {
+  public:
+    // Note: QuotaClientAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       QuotaClientAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple QuotaClientActions running on the same thread/QuotaClientContext.
+  // In theory this could be abstracted to a generic key/value map, but for now
+  // just explicitly provide accessors for the data we need.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread. Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: QuotaClientAction should hold Resolver ref until its ready to call
+  //       Resolve().
+  // Note: The "target" thread is determined when the QuotaClientAction is
+  //       scheduled on QuotaClientContext. The QuotaClientAction should not
+  //       assume any particular thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the QuotaClientAction is canceled. The
+  // QuotaClientAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT.
+  // If CancelOnInitiatingThread() is called after Resolve() has already ocurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the QuotaClientAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent calls
+  // should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread. If this QuotaClientAction will operate
+  // on the give storage ID then override this to return true.
+  // XXX virtual bool MatchesStorageId
+
+  NS_INLINE_DECL_REFCOUNTING(QuotaClientAction)
+
+protected:
+  QuotaClientAction();
+
+  // virtual because deleted through base class pointer.
+  virtual ~QuotaClientAction();
+
+  // Check if this QuotaClientAction has been canceled. May be called from any
+  // thread but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace mozilla
+} // namespace dom
+} // namespace quota
+
+#endif // mozilla_dom_quota_QuotaClientAction_h
diff --git a/dom/quota/QuotaInfo.h b/dom/quota/QuotaInfo.h
new file mode 100644
--- /dev/null
+++ b/dom/quota/QuotaInfo.h
@@ -0,0 +1,28 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_quota_QuotaInfo_h
+#define mozilla_dom_quota_QuotaInfo_h
+
+namespace mozilla {
+namespace dom {
+namespace quota {
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mSuffix;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+};
+
+} // namespace quota
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_quota_QuotaInfo_h
diff --git a/dom/quota/moz.build b/dom/quota/moz.build
--- a/dom/quota/moz.build
+++ b/dom/quota/moz.build
@@ -10,30 +10,33 @@ XPIDL_SOURCES += [
     'nsIQuotaRequests.idl',
 ]
 
 XPIDL_MODULE = 'dom_quota'
 
 EXPORTS.mozilla.dom.quota += [
     'ActorsParent.h',
     'Client.h',
+    'ClientAction.h',
     'FileStreams.h',
     'OriginScope.h',
     'PersistenceType.h',
     'QuotaCommon.h',
+    'QuotaInfo.h',
     'QuotaManager.h',
     'QuotaManagerService.h',
     'QuotaObject.h',
     'SerializationHelpers.h',
     'UsageInfo.h',
 ]
 
 UNIFIED_SOURCES += [
     'ActorsChild.cpp',
     'ActorsParent.cpp',
+    'ClientAction.cpp',
     'FileStreams.cpp',
     'QuotaManagerService.cpp',
     'QuotaRequests.cpp',
 ]
 
 IPDL_SOURCES += [
     'PQuota.ipdl',
     'PQuotaRequest.ipdl',
