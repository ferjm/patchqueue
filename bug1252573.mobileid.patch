# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  2a8ca5caae8e3a300701b0a85e5051ead55e0648
Bug 1252573 - Remove MobileID API. r=sicking,fabrice

diff --git a/b2g/app/b2g.js b/b2g/app/b2g.js
--- a/b2g/app/b2g.js
+++ b/b2g/app/b2g.js
@@ -1059,19 +1059,16 @@ pref("layout.accessiblecaret.bar.enabled
 #ifdef MOZ_WIDGET_GONK
 pref("layout.accessiblecaret.use_long_tap_injector", false);
 #endif
 
 // Enable sync and mozId with Firefox Accounts.
 pref("services.sync.fxaccounts.enabled", true);
 pref("identity.fxaccounts.enabled", true);
 
-// Mobile Identity API.
-pref("services.mobileid.server.uri", "https://msisdn.services.mozilla.com");
-
 pref("identity.fxaccounts.remote.oauth.uri", "https://oauth.accounts.firefox.com/v1");
 pref("identity.fxaccounts.remote.profile.uri", "https://profile.accounts.firefox.com/v1");
 
 // Disable Firefox Accounts device registration until bug 1238895 is fixed.
 pref("identity.fxaccounts.skipDeviceRegistration", true);
 
 // Enable mapped array buffer.
 #ifndef XP_WIN
diff --git a/b2g/chrome/content/shell.js b/b2g/chrome/content/shell.js
--- a/b2g/chrome/content/shell.js
+++ b/b2g/chrome/content/shell.js
@@ -29,17 +29,16 @@ if (isGonk) {
 Cu.import('resource://gre/modules/KillSwitchMain.jsm');
 
 // Identity
 Cu.import('resource://gre/modules/SignInToWebsite.jsm');
 SignInToWebsiteController.init();
 
 Cu.import('resource://gre/modules/FxAccountsMgmtService.jsm');
 Cu.import('resource://gre/modules/DownloadsAPI.jsm');
-Cu.import('resource://gre/modules/MobileIdentityManager.jsm');
 Cu.import('resource://gre/modules/PresentationDeviceInfoManager.jsm');
 Cu.import('resource://gre/modules/AboutServiceWorkers.jsm');
 
 XPCOMUtils.defineLazyModuleGetter(this, "SystemAppProxy",
                                   "resource://gre/modules/SystemAppProxy.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "Screenshot",
                                   "resource://gre/modules/Screenshot.jsm");
diff --git a/b2g/components/B2GComponents.manifest b/b2g/components/B2GComponents.manifest
--- a/b2g/components/B2GComponents.manifest
+++ b/b2g/components/B2GComponents.manifest
@@ -105,20 +105,16 @@ contract @mozilla.org/commandlinehandler
 category command-line-handler m-b2gcmds @mozilla.org/commandlinehandler/general-startup;1?type=b2gcmds
 #endif
 
 # BootstrapCommandLine.js
 component {fd663ec8-cf3f-4c2b-aacb-17a6915ccb44} BootstrapCommandLine.js
 contract @mozilla.org/commandlinehandler/general-startup;1?type=b2gbootstrap {fd663ec8-cf3f-4c2b-aacb-17a6915ccb44}
 category command-line-handler m-b2gbootstrap @mozilla.org/commandlinehandler/general-startup;1?type=b2gbootstrap
 
-# MobileIdentityUIGlue.js
-component {83dbe26a-81f3-4a75-9541-3d0b7ca496b5} MobileIdentityUIGlue.js
-contract @mozilla.org/services/mobileid-ui-glue;1 {83dbe26a-81f3-4a75-9541-3d0b7ca496b5}
-
 # B2GAppMigrator.js
 component {7211ece0-b458-4635-9afc-f8d7f376ee95} B2GAppMigrator.js
 contract @mozilla.org/app-migrator;1 {7211ece0-b458-4635-9afc-f8d7f376ee95}
 
 # B2GPresentationDevicePrompt.js
 component {4a300c26-e99b-4018-ab9b-c48cf9bc4de1} B2GPresentationDevicePrompt.js
 contract @mozilla.org/presentation-device/prompt;1 {4a300c26-e99b-4018-ab9b-c48cf9bc4de1}
 
diff --git a/b2g/components/MobileIdentityUIGlue.js b/b2g/components/MobileIdentityUIGlue.js
deleted file mode 100644
--- a/b2g/components/MobileIdentityUIGlue.js
+++ /dev/null
@@ -1,162 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict"
-
-const { interfaces: Ci, utils: Cu, classes: Cc } = Components;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/ContentRequestHelper.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/MobileIdentityUIGlueCommon.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-
-XPCOMUtils.defineLazyServiceGetter(this, "uuidgen",
-                                   "@mozilla.org/uuid-generator;1",
-                                   "nsIUUIDGenerator");
-
-XPCOMUtils.defineLazyModuleGetter(this, "SystemAppProxy",
-                                  "resource://gre/modules/SystemAppProxy.jsm");
-
-const CHROME_EVENT = "mozMobileIdChromeEvent";
-const CONTENT_EVENT = "mozMobileIdContentEvent";
-const UNSOLICITED_CONTENT_EVENT = "mozMobileIdUnsolContentEvent";
-
-function MobileIdentityUIGlue() {
-  SystemAppProxy.addEventListener(UNSOLICITED_CONTENT_EVENT, this);
-}
-
-MobileIdentityUIGlue.prototype = {
-
-  __proto__: ContentRequestHelper.prototype,
-
-  _sendChromeEvent: function(aEventName, aData) {
-    SystemAppProxy._sendCustomEvent(CHROME_EVENT, {
-      eventName: aEventName,
-      id: uuidgen.generateUUID().toString(),
-      data: aData
-    });
-  },
-
-  _oncancel: null,
-
-  get oncancel() {
-    return this._oncancel;
-  },
-
-  set oncancel(aCallback) {
-    this._oncancel = aCallback;
-  },
-
-  _onresendcode: null,
-
-  get onresendcode() {
-    return this._onresendcode;
-  },
-
-  set onresendcode(aCallback) {
-    this._onresendcode = aCallback;
-  },
-
-  startFlow: function(aManifestURL, aIccInfo) {
-    let phoneNumberInfo;
-    if (aIccInfo) {
-      phoneNumberInfo = [];
-      for (var i = 0; i < aIccInfo.length; i++) {
-        let iccInfo = aIccInfo[i];
-        phoneNumberInfo.push({
-          primary: iccInfo.primary,
-          msisdn: iccInfo.msisdn,
-          operator: iccInfo.operator,
-          external: iccInfo.external,
-          serviceId: iccInfo.serviceId,
-          mcc: iccInfo.mcc
-        });
-      }
-    }
-
-    return this.contentRequest(CONTENT_EVENT,
-                               CHROME_EVENT,
-                               "onpermissionrequest",
-                               { phoneNumberInfo: phoneNumberInfo || [],
-                                 manifestURL: aManifestURL })
-    .then(
-      (result) => {
-        if (!result || !result.phoneNumber && !result.serviceId) {
-          return Promise.reject(ERROR_INVALID_PROMPT_RESULT);
-        }
-
-        let promptResult = new MobileIdentityUIGluePromptResult(
-          result.phoneNumber || null,
-          result.prefix || null,
-          result.mcc || null,
-          result.serviceId || null
-        );
-        return promptResult;
-      }
-    );
-  },
-
-  verificationCodePrompt: function(aRetriesLeft, aTimeout, aTimeLeft) {
-    return this.contentRequest(CONTENT_EVENT,
-                               CHROME_EVENT,
-                               "onverificationcode",
-                               { retriesLeft: aRetriesLeft,
-                                 verificationTimeout: aTimeout,
-                                 verificationTimeoutLeft: aTimeLeft })
-    .then(
-      (result) => {
-        if (!result || !result.verificationCode) {
-          return Promise.reject(ERROR_INVALID_VERIFICATION_CODE);
-        }
-
-        return result.verificationCode;
-      }
-    );
-  },
-
-  error: function(aError) {
-    log.error("UI error " + aError);
-    this._sendChromeEvent("onerror", {
-      error: aError
-    });
-  },
-
-  verify: function() {
-    this._sendChromeEvent("verify");
-  },
-
-  verified: function(aVerifiedPhoneNumber) {
-    this._sendChromeEvent("onverified", {
-      verifiedPhoneNumber: aVerifiedPhoneNumber
-    });
-  },
-
-  handleEvent: function(aEvent) {
-    let msg = aEvent.detail;
-    if (!msg) {
-      log.warning("Got invalid event");
-      return;
-    }
-    log.debug("Got content event ${}", msg);
-
-    switch(msg.eventName) {
-      case 'cancel':
-        this.oncancel();
-        break;
-      case 'resendcode':
-        this.onresendcode();
-        break;
-      default:
-        log.warning("Invalid event name");
-        break;
-    }
-  },
-
-  classID: Components.ID("{83dbe26a-81f3-4a75-9541-3d0b7ca496b5}"),
-
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMobileIdentityUIGlue])
-};
-
-this.NSGetFactory = XPCOMUtils.generateNSGetFactory([MobileIdentityUIGlue]);
diff --git a/b2g/components/moz.build b/b2g/components/moz.build
--- a/b2g/components/moz.build
+++ b/b2g/components/moz.build
@@ -15,17 +15,16 @@ EXTRA_COMPONENTS += [
     'BootstrapCommandLine.js',
     'ContentPermissionPrompt.js',
     'FilePicker.js',
     'FxAccountsUIGlue.js',
     'HelperAppDialog.js',
     'InterAppCommUIGlue.js',
     'KillSwitch.js',
     'MailtoProtocolHandler.js',
-    'MobileIdentityUIGlue.js',
     'OMAContentHandler.js',
     'PaymentGlue.js',
     'PaymentProviderStrategy.js',
     'PresentationRequestUIGlue.js',
     'ProcessGlobal.js',
     'SmsProtocolHandler.js',
     'SystemMessageGlue.js',
     'TelProtocolHandler.js',
diff --git a/b2g/installer/package-manifest.in b/b2g/installer/package-manifest.in
--- a/b2g/installer/package-manifest.in
+++ b/b2g/installer/package-manifest.in
@@ -935,22 +935,16 @@ bin/libfreebl_32int64_3.so
 
 @RESPATH@/components/FxAccountsUIGlue.js
 @RESPATH@/components/services_fxaccounts.xpt
 
 @RESPATH@/components/DataStore.manifest
 @RESPATH@/components/DataStoreImpl.js
 @RESPATH@/components/dom_datastore.xpt
 
-@RESPATH@/components/MobileIdentity.manifest
-@RESPATH@/components/MobileIdentity.js
-@RESPATH@/components/dom_mobileidentity.xpt
-@RESPATH@/components/MobileIdentityUIGlue.js
-@RESPATH@/components/services_mobileidentity.xpt
-
 #ifdef MOZ_WEBSPEECH
 @RESPATH@/components/dom_webspeechsynth.xpt
 #endif
 
 #ifdef XP_MACOSX
 @BINPATH@/@DLL_PREFIX@plugin_child_interpose@DLL_SUFFIX@
 #endif
 
diff --git a/dom/apps/PermissionsTable.jsm b/dom/apps/PermissionsTable.jsm
--- a/dom/apps/PermissionsTable.jsm
+++ b/dom/apps/PermissionsTable.jsm
@@ -410,21 +410,16 @@ this.PermissionsTable =  { geolocation: 
                              privileged: PROMPT_ACTION,
                              certified: ALLOW_ACTION
                            },
                            "feature-detection": {
                              app: DENY_ACTION,
                              privileged: ALLOW_ACTION,
                              certified: ALLOW_ACTION
                            },
-                           "mobileid": {
-                             app: DENY_ACTION,
-                             privileged: PROMPT_ACTION,
-                             certified: PROMPT_ACTION
-                           },
                            // This permission doesn't actually grant access to
                            // anything. It exists only to check the correctness
                            // of web prompt composed permissions in tests.
                            "test-permission": {
                              app: PROMPT_ACTION,
                              privileged: PROMPT_ACTION,
                              certified: ALLOW_ACTION,
                              access: ["read", "write", "create"]
diff --git a/dom/base/Navigator.cpp b/dom/base/Navigator.cpp
--- a/dom/base/Navigator.cpp
+++ b/dom/base/Navigator.cpp
@@ -51,19 +51,16 @@
 #include "mozilla/dom/workers/RuntimeService.h"
 #include "mozilla/Hal.h"
 #include "nsISiteSpecificUserAgent.h"
 #include "mozilla/ClearOnShutdown.h"
 #include "mozilla/StaticPtr.h"
 #include "Connection.h"
 #include "mozilla/dom/Event.h" // for nsIDOMEvent::InternalDOMEvent()
 #include "nsGlobalWindow.h"
-#ifdef MOZ_B2G
-#include "nsIMobileIdentityService.h"
-#endif
 #ifdef MOZ_B2G_RIL
 #include "mozilla/dom/MobileConnectionArray.h"
 #endif
 #include "nsIIdleObserver.h"
 #include "nsIPermissionManager.h"
 #include "nsMimeTypes.h"
 #include "nsNetUtil.h"
 #include "nsStringStream.h"
@@ -1693,23 +1690,16 @@ Navigator::HasFeature(const nsAString& a
       return p.forget();
     }
 
     if (featureName.EqualsLiteral("Navigator.mozCameras")) {
       p->MaybeResolve(true);
       return p.forget();
     }
 
-#ifdef MOZ_B2G
-    if (featureName.EqualsLiteral("Navigator.getMobileIdAssertion")) {
-      p->MaybeResolve(true);
-      return p.forget();
-    }
-#endif
-
     if (featureName.EqualsLiteral("XMLHttpRequest.mozSystem")) {
       p->MaybeResolve(true);
       return p.forget();
     }
 
     if (IsFeatureDetectible(featureName)) {
       p->MaybeResolve(true);
     } else {
@@ -1823,55 +1813,16 @@ Navigator::GetInputPortManager(ErrorResu
 
 already_AddRefed<LegacyMozTCPSocket>
 Navigator::MozTCPSocket()
 {
   RefPtr<LegacyMozTCPSocket> socket = new LegacyMozTCPSocket(GetWindow());
   return socket.forget();
 }
 
-#ifdef MOZ_B2G
-already_AddRefed<Promise>
-Navigator::GetMobileIdAssertion(const MobileIdOptions& aOptions,
-                                ErrorResult& aRv)
-{
-  if (!mWindow || !mWindow->GetDocShell()) {
-    aRv.Throw(NS_ERROR_UNEXPECTED);
-    return nullptr;
-  }
-
-  nsCOMPtr<nsIMobileIdentityService> service =
-    do_GetService("@mozilla.org/mobileidentity-service;1");
-  if (!service) {
-    aRv.Throw(NS_ERROR_FAILURE);
-    return nullptr;
-  }
-
-  JSContext *cx = nsContentUtils::GetCurrentJSContext();
-  if (!cx) {
-    aRv.Throw(NS_ERROR_FAILURE);
-    return nullptr;
-  }
-
-  JS::Rooted<JS::Value> optionsValue(cx);
-  if (!ToJSValue(cx, aOptions, &optionsValue)) {
-    aRv.Throw(NS_ERROR_FAILURE);
-    return nullptr;
-  }
-
-  nsCOMPtr<nsISupports> promise;
-  aRv = service->GetMobileIdAssertion(mWindow,
-                                      optionsValue,
-                                      getter_AddRefs(promise));
-
-  RefPtr<Promise> p = static_cast<Promise*>(promise.get());
-  return p.forget();
-}
-#endif // MOZ_B2G
-
 #ifdef MOZ_B2G_RIL
 
 MobileConnectionArray*
 Navigator::GetMozMobileConnections(ErrorResult& aRv)
 {
   if (!mMobileConnections) {
     if (!mWindow) {
       aRv.Throw(NS_ERROR_UNEXPECTED);
@@ -2589,43 +2540,16 @@ Navigator::HasDataStoreSupport(JSContext
   nsIDocument* doc = win->GetExtantDoc();
   if (!doc || !doc->NodePrincipal()) {
     return false;
   }
 
   return HasDataStoreSupport(doc->NodePrincipal());
 }
 
-#ifdef MOZ_B2G
-/* static */
-bool
-Navigator::HasMobileIdSupport(JSContext* aCx, JSObject* aGlobal)
-{
-  nsCOMPtr<nsPIDOMWindowInner> win = GetWindowFromGlobal(aGlobal);
-  if (!win) {
-    return false;
-  }
-
-  nsIDocument* doc = win->GetExtantDoc();
-  if (!doc) {
-    return false;
-  }
-
-  nsIPrincipal* principal = doc->NodePrincipal();
-
-  nsCOMPtr<nsIPermissionManager> permMgr = services::GetPermissionManager();
-  NS_ENSURE_TRUE(permMgr, false);
-
-  uint32_t permission = nsIPermissionManager::UNKNOWN_ACTION;
-  permMgr->TestPermissionFromPrincipal(principal, "mobileid", &permission);
-  return permission == nsIPermissionManager::PROMPT_ACTION ||
-         permission == nsIPermissionManager::ALLOW_ACTION;
-}
-#endif
-
 /* static */
 bool
 Navigator::HasPresentationSupport(JSContext* aCx, JSObject* aGlobal)
 {
   JS::Rooted<JSObject*> global(aCx, aGlobal);
 
   nsCOMPtr<nsPIDOMWindowInner> inner = GetWindowFromGlobal(global);
   if (NS_WARN_IF(!inner)) {
diff --git a/dom/base/Navigator.h b/dom/base/Navigator.h
--- a/dom/base/Navigator.h
+++ b/dom/base/Navigator.h
@@ -35,17 +35,16 @@ class nsIURI;
 namespace mozilla {
 namespace dom {
 class Geolocation;
 class systemMessageCallback;
 class MediaDevices;
 struct MediaStreamConstraints;
 class WakeLock;
 class ArrayBufferViewOrBlobOrStringOrFormData;
-struct MobileIdOptions;
 class ServiceWorkerContainer;
 class DOMRequest;
 } // namespace dom
 } // namespace mozilla
 
 //*****************************************************************************
 // Navigator: Script "navigator" object
 //*****************************************************************************
@@ -258,20 +257,16 @@ public:
   nsDOMCameraManager* GetMozCameras(ErrorResult& aRv);
   MediaDevices* GetMediaDevices(ErrorResult& aRv);
   void MozSetMessageHandler(const nsAString& aType,
                             systemMessageCallback* aCallback,
                             ErrorResult& aRv);
   bool MozHasPendingMessage(const nsAString& aType, ErrorResult& aRv);
   void MozSetMessageHandlerPromise(Promise& aPromise, ErrorResult& aRv);
 
-#ifdef MOZ_B2G
-  already_AddRefed<Promise> GetMobileIdAssertion(const MobileIdOptions& options,
-                                                 ErrorResult& aRv);
-#endif
 #ifdef MOZ_B2G_RIL
   MobileConnectionArray* GetMozMobileConnections(ErrorResult& aRv);
 #endif // MOZ_B2G_RIL
 #ifdef MOZ_GAMEPAD
   void GetGamepads(nsTArray<RefPtr<Gamepad> >& aGamepads, ErrorResult& aRv);
 #endif // MOZ_GAMEPAD
   already_AddRefed<Promise> GetVRDevices(ErrorResult& aRv);
   void NotifyVRDevicesUpdated();
@@ -342,20 +337,16 @@ public:
   static bool HasUserMediaSupport(JSContext* /* unused */,
                                   JSObject* /* unused */);
 #endif // MOZ_MEDIA_NAVIGATOR
 
   static bool HasDataStoreSupport(nsIPrincipal* aPrincipal);
 
   static bool HasDataStoreSupport(JSContext* cx, JSObject* aGlobal);
 
-#ifdef MOZ_B2G
-  static bool HasMobileIdSupport(JSContext* aCx, JSObject* aGlobal);
-#endif
-
   static bool HasPresentationSupport(JSContext* aCx, JSObject* aGlobal);
 
   static bool IsE10sEnabled(JSContext* aCx, JSObject* aGlobal);
 
   nsPIDOMWindowInner* GetParentObject() const
   {
     return GetWindow();
   }
diff --git a/dom/base/test/test_hasFeature.html b/dom/base/test/test_hasFeature.html
--- a/dom/base/test/test_hasFeature.html
+++ b/dom/base/test/test_hasFeature.html
@@ -34,17 +34,16 @@ function testAPIs() {
     { name: "Navigator.push", enabled: pref("services.push.enabled") },
     // { name: "Navigator.mozTime", enabled: b2gOnly }, // conditional on MOZ_TIME_MANAGER, tricky to test
     // { name: "Navigator.mozFMRadio", enabled: b2gOnly }, // conditional on MOZ_B2G_FM, tricky to test
     { name: "Navigator.mozCameras", enabled: true },
     { name: "Navigator.mozAlarms", enabled: pref("dom.mozAlarms.enabled") },
     { name: "Navigator.mozTCPSocket", enabled: pref("dom.mozTCPSocket.enabled") },
     { name: "Navigator.mozInputMethod", enabled: pref("dom.mozInputMethod.enabled") },
     { name: "Navigator.mozMobileConnections", enabled: pref("dom.mobileconnection.enabled") },
-    { name: "Navigator.getMobileIdAssertion", enabled: b2gOnly },
     { name: "XMLHttpRequest.mozSystem", enabled: true }
   ];
 
   var promises = [];
   APIEndPoints.forEach(function(v) {
     promises.push(navigator.hasFeature("api.window." + v.name));
   });
 
diff --git a/dom/mobileid/MobileIdentity.js b/dom/mobileid/MobileIdentity.js
deleted file mode 100644
--- a/dom/mobileid/MobileIdentity.js
+++ /dev/null
@@ -1,109 +0,0 @@
-/* -*- js-indent-level: 2; indent-tabs-mode: nil -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict"
-
-const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
-
-Cu.import("resource://gre/modules/DOMRequestHelper.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-const MOBILEIDSERVICE_CID =
-  Components.ID("{6ec1806c-d61f-4724-9495-68c26d46dc53}");
-
-const IPC_MSG_NAMES = ["MobileId:GetAssertion:Return:OK",
-                       "MobileId:GetAssertion:Return:KO"];
-
-XPCOMUtils.defineLazyServiceGetter(this, "cpmm",
-                                   "@mozilla.org/childprocessmessagemanager;1",
-                                   "nsIMessageSender");
-
-function MobileIdentityService() {
-}
-
-MobileIdentityService.prototype = {
-  __proto__: DOMRequestIpcHelper.prototype,
-
-  // TODO: this should be handled by DOMRequestIpcHelper. Bug 1020582
-  _windows: {},
-
-  getMobileIdAssertion: function(aWindow, aOptions) {
-    log.debug("getMobileIdAssertion");
-
-    if (!this.init) {
-      this.initDOMRequestHelper(aWindow, IPC_MSG_NAMES);
-      this.init = true;
-    }
-
-    return new aWindow.Promise(
-      (resolve, reject) => {
-        let promiseId = this.getPromiseResolverId({
-          resolve: resolve,
-          reject: reject
-        });
-
-        this._windows[promiseId] = aWindow;
-
-        cpmm.sendAsyncMessage("MobileId:GetAssertion", {
-          promiseId: promiseId,
-          options: aOptions
-        }, null, aWindow.document.nodePrincipal);
-      }
-    );
-  },
-
-  receiveMessage: function(aMessage) {
-    let name = aMessage.name;
-    let msg = aMessage.json;
-
-    log.debug("Received message " + name + ": " + JSON.stringify(msg));
-
-    let promiseId = msg.promiseId || msg.requestID;
-    let promise = this.takePromiseResolver(promiseId);
-    if (!promise) {
-      log.error("Promise not found");
-      return;
-    }
-
-    let _window = this._windows[promiseId];
-    delete this._windows[promiseId];
-    if (!_window) {
-      log.error("No window object found");
-      return;
-    }
-
-    switch (name) {
-      case "MobileId:GetAssertion:Return:OK":
-        if (!msg.result) {
-          promise.reject(new _window.DOMError(ERROR_INTERNAL_UNEXPECTED));
-        }
-
-        // Return the assertion
-        promise.resolve(msg.result);
-        break;
-      case "MobileId:GetAssertion:Return:KO":
-        promise.reject(new _window.DOMError(msg.error || ERROR_UNKNOWN));
-        break;
-    }
-  },
-
-  classID: MOBILEIDSERVICE_CID,
-
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMobileIdentityService,
-                                         Ci.nsISupportsWeakReference,
-                                         Ci.nsIObserver]),
-
-  classInfo: XPCOMUtils.generateCI({
-    classID: MOBILEIDSERVICE_CID,
-    contractID: "@mozilla.org/mobileidentity-service;1",
-    interfaces: [Ci.nsIMobileIdentityService],
-    flags: Ci.nsIClassInfo.SINGLETON
-  })
-
-};
-
-this.NSGetFactory = XPCOMUtils.generateNSGetFactory([MobileIdentityService]);
diff --git a/dom/mobileid/MobileIdentity.manifest b/dom/mobileid/MobileIdentity.manifest
deleted file mode 100644
--- a/dom/mobileid/MobileIdentity.manifest
+++ /dev/null
@@ -1,2 +0,0 @@
-component {6ec1806c-d61f-4724-9495-68c26d46dc53} MobileIdentity.js
-contract @mozilla.org/mobileidentity-service;1 {6ec1806c-d61f-4724-9495-68c26d46dc53}
diff --git a/dom/mobileid/interfaces/moz.build b/dom/mobileid/interfaces/moz.build
deleted file mode 100644
--- a/dom/mobileid/interfaces/moz.build
+++ /dev/null
@@ -1,11 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-XPIDL_SOURCES += [
-    'nsIMobileIdentityService.idl',
-]
-
-XPIDL_MODULE = 'dom_mobileidentity'
diff --git a/dom/mobileid/interfaces/nsIMobileIdentityService.idl b/dom/mobileid/interfaces/nsIMobileIdentityService.idl
deleted file mode 100644
--- a/dom/mobileid/interfaces/nsIMobileIdentityService.idl
+++ /dev/null
@@ -1,14 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-
-interface mozIDOMWindow;
-
-[scriptable, uuid(c03d38e3-bae6-4b62-ae96-cf8acc1501ec)]
-interface nsIMobileIdentityService : nsISupports
-{
-  nsISupports getMobileIdAssertion(in mozIDOMWindow window,
-                                   in jsval options);
-};
diff --git a/dom/mobileid/moz.build b/dom/mobileid/moz.build
deleted file mode 100644
--- a/dom/mobileid/moz.build
+++ /dev/null
@@ -1,14 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-DIRS += ['interfaces']
-
-MOCHITEST_MANIFESTS += ['test/mochitest.ini']
-
-EXTRA_COMPONENTS += [
-    'MobileIdentity.js',
-    'MobileIdentity.manifest',
-]
diff --git a/dom/mobileid/test/mochitest.ini b/dom/mobileid/test/mochitest.ini
deleted file mode 100644
--- a/dom/mobileid/test/mochitest.ini
+++ /dev/null
@@ -1,5 +0,0 @@
-[DEFAULT]
-skip-if = (buildapp != 'b2g')
-
-[test_mobileid_basics.html]
-[test_mobileid_no_permission.html]
diff --git a/dom/mobileid/test/test_mobileid_basics.html b/dom/mobileid/test/test_mobileid_basics.html
deleted file mode 100644
--- a/dom/mobileid/test/test_mobileid_basics.html
+++ /dev/null
@@ -1,78 +0,0 @@
-<!DOCTYPE HTML>
-<html>
-<head>
-  <title>Test for navigator.getMobileIdAssertion</title>
-  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
-  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
-</head>
-<body>
-<p id="display"></p>
-<div id="content" style="display: none">
-</div>
-<pre id="test">
-<script type="application/javascript">
-
-const MOCK_CID = SpecialPowers.wrap(SpecialPowers.Components)
-                              .ID("{4cb9b8b3-bc8c-46c0-a2b6-2eb0b1ffce94}");
-const MOBILE_ID_SERVICE_CONTRACT_ID = "@mozilla.org/mobileidentity-service;1";
-
-function finish() {
-  SpecialPowers.wrap(SpecialPowers.Components).manager
-               .QueryInterface(SpecialPowers.Ci.nsIComponentRegistrar)
-               .unregisterFactory(MOCK_CID, mockMobileIdService);
-  SimpleTest.finish();
-}
-
-SimpleTest.waitForExplicitFinish();
-
-var mockMobileIdService = {
-  QueryInterface: function(aIID) {
-    if (SpecialPowers.wrap(aIID).equals(SpecialPowers.Ci.nsISupports) ||
-        SpecialPowers.wrap(aIID).equals(SpecialPowers.Ci.nsIMobileIdentityService)) {
-      return this;
-    }
-    throw SpecialPowers.Components.results.NS_ERROR_NO_INTERFACE;
-  },
-
-  createInstance: function(aOuter, aIID) {
-    if (aOuter != null) {
-      throw SpecialPowers.Components.results.NS_ERROR_NO_AGGREGATION;
-    }
-    return this.QueryInterface(aIID);
-  },
-
-  getMobileIdAssertion: function(aWindow, aOptions) {
-    return new Promise(function(resolve, reject) {
-      resolve(aOptions);
-    });
-  }
-};
-mockMobileIdService = SpecialPowers.wrapCallbackObject(mockMobileIdService);
-
-SpecialPowers.wrap(SpecialPowers.Components).manager
-             .QueryInterface(SpecialPowers.Ci.nsIComponentRegistrar)
-             .registerFactory(MOCK_CID, "mobileid service",
-                              MOBILE_ID_SERVICE_CONTRACT_ID,
-                              mockMobileIdService);
-
-// Tests
-
-SpecialPowers.pushPermissions([{"type": "mobileid",
-                               "allow": 1,
-                               "context": document}], function() {
-  ok("getMobileIdAssertion" in navigator,
-     "navigator.getMobileIdAssertion should exist");
-
-  var options = { forceSelection: true };
-  var promise = navigator.getMobileIdAssertion(options)
-  .then(function(result) {
-    ok(promise instanceof Promise, "Should return a Promise");
-    is(result.forceSelection, options.forceSelection,
-       "MobileIdentityService should receive correct options");
-    finish();
-  });
-});
-</script>
-</pre>
-</body>
-</html>
diff --git a/dom/mobileid/test/test_mobileid_no_permission.html b/dom/mobileid/test/test_mobileid_no_permission.html
deleted file mode 100644
--- a/dom/mobileid/test/test_mobileid_no_permission.html
+++ /dev/null
@@ -1,24 +0,0 @@
-<!DOCTYPE HTML>
-<html>
-<head>
-  <title>Test for navigator.getMobileIdAssertion - No permission</title>
-  <script type="application/javascript" src="/tests/SimpleTest/SimpleTest.js"></script>
-  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css"/>
-</head>
-<body>
-<p id="display"></p>
-<div id="content" style="display: none">
-</div>
-<pre id="test">
-<script type="application/javascript">
-
-SimpleTest.waitForExplicitFinish();
-
-ok(!("getMobileIdAssertion" in navigator),
-   "navigator.getMobileIdAssertion should NOT exist");
-
-SimpleTest.finish();
-</script>
-</pre>
-</body>
-</html>
diff --git a/dom/moz.build b/dom/moz.build
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -148,17 +148,16 @@ else:
 
 if CONFIG['MOZ_SECUREELEMENT']:
     DIRS += ['secureelement']
 
 if CONFIG['MOZ_B2G']:
     DIRS += [
         'downloads',
         'identity',
-        'mobileid',
         'engineeringmode'
     ]
 
 DIRS += ['presentation']
 
 TEST_DIRS += [
     'tests',
     'imptests',
diff --git a/dom/webidl/Navigator.webidl b/dom/webidl/Navigator.webidl
--- a/dom/webidl/Navigator.webidl
+++ b/dom/webidl/Navigator.webidl
@@ -168,33 +168,16 @@ partial interface Navigator {
 callback interface MozIdleObserver {
   // Time is in seconds and is read only when idle observers are added
   // and removed.
   readonly attribute unsigned long time;
   void onidle();
   void onactive();
 };
 
-#ifdef MOZ_B2G
-dictionary MobileIdOptions {
-  boolean forceSelection = false;
-};
-
-[NoInterfaceObject]
-interface NavigatorMobileId {
-    // Ideally we would use [CheckAnyPermissions] here, but the "mobileid"
-    // permission is set to PROMPT_ACTION and [CheckAnyPermissions] only checks
-    // for ALLOW_ACTION.
-    // XXXbz what is this promise resolved with?
-    [NewObject, Func="Navigator::HasMobileIdSupport"]
-    Promise<any> getMobileIdAssertion(optional MobileIdOptions options);
-};
-Navigator implements NavigatorMobileId;
-#endif // MOZ_B2G
-
 // nsIDOMNavigator
 partial interface Navigator {
   [Throws, Constant, Cached]
   readonly attribute DOMString oscpu;
   // WebKit/Blink support this; Trident/Presto do not.
   readonly attribute DOMString vendor;
   // WebKit/Blink supports this (hardcoded ""); Trident/Presto do not.
   readonly attribute DOMString vendorSub;
diff --git a/services/mobileid/MobileIdentityClient.jsm b/services/mobileid/MobileIdentityClient.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityClient.jsm
+++ /dev/null
@@ -1,158 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// REST client for
-// https://github.com/mozilla-services/msisdn-gateway/blob/master/API.md
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentityClient"];
-
-const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
-
-Cu.import("resource://services-common/hawkclient.js");
-Cu.import("resource://services-common/hawkrequest.js");
-Cu.import("resource://services-common/utils.js");
-Cu.import("resource://services-crypto/utils.js");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-this.MobileIdentityClient = function(aServerUrl) {
-  let serverUrl = aServerUrl || SERVER_URL;
-  let forceHttps = true;
-  try {
-    forceHttps = Services.prefs.getBoolPref(PREF_FORCE_HTTPS);
-  } catch(e) {
-    log.warn("Getting force HTTPS pref failed. If this was not intentional " +
-             "check that " + PREF_FORCE_HTTPS + " is defined");
-  }
-
-  log.debug("Force HTTPS " + forceHttps);
-
-  if (forceHttps && !/^https/.exec(serverUrl.toLowerCase())) {
-    throw new Error(ERROR_INTERNAL_HTTP_NOT_ALLOWED);
-  }
-
-  this.hawk = new HawkClient(serverUrl);
-  this.hawk.observerPrefix = "MobileId:hawk";
-};
-
-this.MobileIdentityClient.prototype = {
-
-  discover: function(aMsisdn, aMcc, aMnc, aRoaming) {
-    return this._request(DISCOVER, "POST", null, {
-      msisdn: aMsisdn || undefined,
-      mcc: aMcc,
-      mnc: aMnc,
-      roaming: aRoaming
-    });
-  },
-
-  register: function() {
-    return this._request(REGISTER, "POST", null, {});
-  },
-
-  smsMtVerify: function(aSessionToken, aMsisdn, aMcc, aMnc,
-                        aWantShortCode = false) {
-    let credentials = this._deriveHawkCredentials(aSessionToken);
-    return this._request(SMS_MT_VERIFY, "POST", credentials, {
-      msisdn: aMsisdn,
-      mcc: aMcc,
-      mnc: aMnc,
-      shortVerificationCode: aWantShortCode
-    });
-  },
-
-  verifyCode: function(aSessionToken, aVerificationCode) {
-    log.debug("verificationCode " + aVerificationCode);
-    let credentials = this._deriveHawkCredentials(aSessionToken);
-    return this._request(SMS_VERIFY_CODE, "POST", credentials, {
-      code: aVerificationCode
-    });
-  },
-
-  sign: function(aSessionToken, aDuration, aPublicKey) {
-    let credentials = this._deriveHawkCredentials(aSessionToken);
-    return this._request(SIGN, "POST", credentials, {
-      duration: aDuration,
-      publicKey: aPublicKey
-    });
-  },
-
-  unregister: function(aSessionToken) {
-    let credentials = this._deriveHawkCredentials(aSessionToken);
-    return this._request(UNREGISTER, "POST", credentials, {});
-  },
-
-  /**
-   * The MobileID server expects requests to certain endpoints to be
-   * authorized using Hawk.
-   *
-   * Hawk credentials are derived using shared secrets.
-   *
-   * @param tokenHex
-   *        The current session token encoded in hex
-   * @param context
-   *        A context for the credentials
-   * @param size
-   *        The size in bytes of the expected derived buffer
-   * @return credentials
-   *        Returns an object:
-   *        {
-   *          algorithm: sha256
-   *          id: the Hawk id (from the first 32 bytes derived)
-   *          key: the Hawk key (from bytes 32 to 64)
-   *        }
-   */
-  _deriveHawkCredentials: function(aSessionToken) {
-    return deriveHawkCredentials(aSessionToken, CREDENTIALS_DERIVATION_INFO,
-                                 CREDENTIALS_DERIVATION_SIZE, true /*hexKey*/);
-  },
-
-  /**
-   * A general method for sending raw API calls to the mobile id verification
-   * server.
-   * All request bodies and responses are JSON.
-   *
-   * @param path
-   *        API endpoint path
-   * @param method
-   *        The HTTP request method
-   * @param credentials
-   *        Hawk credentials
-   * @param jsonPayload
-   *        A JSON payload
-   * @return Promise
-   *        Returns a promise that resolves to the JSON response of the API
-   *        call, or is rejected with an error.
-   */
-  _request: function(path, method, credentials, jsonPayload) {
-    let deferred = Promise.defer();
-
-    this.hawk.request(path, method, credentials, jsonPayload).then(
-      (response) => {
-        log.debug("MobileIdentityClient -> response.body " + response.body);
-        try {
-          let responseObj;
-          // We parse the response body unless we are handling a 204 response,
-          // which MUST NOT include a message body.
-          if (response.status != 204) {
-            responseObj = JSON.parse(response.body);
-          }
-          deferred.resolve(responseObj);
-        } catch (err) {
-          deferred.reject({error: err});
-        }
-      },
-      (error) => {
-        log.error("MobileIdentityClient -> Error ${}", error);
-        deferred.reject(SERVER_ERRNO_TO_ERROR[error.errno] || ERROR_UNKNOWN);
-      }
-    );
-
-    return deferred.promise;
-  },
-
-};
diff --git a/services/mobileid/MobileIdentityCommon.jsm b/services/mobileid/MobileIdentityCommon.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityCommon.jsm
+++ /dev/null
@@ -1,144 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const { interfaces: Ci, utils: Cu } = Components;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/Log.jsm");
-
-// loglevel should be one of "Fatal", "Error", "Warn", "Info", "Config",
-// "Debug", "Trace" or "All". If none is specified, "Error" will be used by
-// default.
-const PREF_LOG_LEVEL = "services.mobileid.loglevel";
-
-XPCOMUtils.defineLazyGetter(this, "log", function() {
-  let log = Log.repository.getLogger("MobileId");
-  log.addAppender(new Log.DumpAppender());
-  log.level = Log.Level.Error;
-  try {
-    let level =
-      Services.prefs.getPrefType(PREF_LOG_LEVEL) == Ci.nsIPrefBranch.PREF_STRING
-      && Services.prefs.getCharPref(PREF_LOG_LEVEL);
-    log.level = Log.Level[level] || Log.Level.Error;
-  } catch (e) {
-    log.error(e);
-  }
-
-  return log;
-});
-
-this.PREF_FORCE_HTTPS = "services.mobileid.forcehttps";
-
-// Permission.
-this.MOBILEID_PERM = "mobileid";
-
-// IPC messages.
-this.GET_ASSERTION_IPC_MSG = "MobileId:GetAssertion";
-
-// Verification methods.
-this.SMS_MT    = "sms/mt";
-this.SMS_MO_MT = "sms/momt";
-
-// Server endpoints.
-this.DISCOVER         = "/discover";
-this.REGISTER         = "/register";
-this.SMS_MT_VERIFY    = "/" + this.SMS_MT + "/verify";
-this.SMS_MO_MT_VERIFY = "/" + this.SMS_MO_MT + "/verify";
-this.SMS_VERIFY_CODE  = "/sms/verify_code";
-this.SIGN             = "/certificate/sign";
-this.UNREGISTER       = "/unregister";
-
-// Server consts.
-this.SERVER_URL = Services.prefs.getCharPref("services.mobileid.server.uri");
-this.CREDENTIALS_DERIVATION_INFO = "sessionToken";
-this.CREDENTIALS_DERIVATION_SIZE = 2 * 32;
-
-this.SILENT_SMS_RECEIVED_TOPIC = "silent-sms-received";
-
-this.ASSERTION_LIFETIME   = 1000 * 60 * 5;   // 5 minutes.
-this.CERTIFICATE_LIFETIME = 1000 * 3600 * 6; // 6 hours.
-this.KEY_LIFETIME         = 1000 * 3600 * 12; // 12 hours.
-
-this.VERIFICATIONCODE_TIMEOUT = 60000;
-this.VERIFICATIONCODE_RETRIES = 3;
-
-// Internal Errors.
-this.ERROR_INTERNAL_CANNOT_CREATE_VERIFICATION_FLOW = "INTERNAL_CANNOT_CREATE_VERIFICATION_FLOW";
-this.ERROR_INTERNAL_CANNOT_GENERATE_ASSERTION       = "INTERNAL_CANNOT_GENERATE_ASSERTION";
-this.ERROR_INTERNAL_CANNOT_VERIFY_SELECTION         = "INTERNAL_CANNOT_VERIFY_SELECTION";
-this.ERROR_INTERNAL_DB_ERROR                        = "INTERNAL_DB_ERROR";
-this.ERROR_INTERNAL_HTTP_NOT_ALLOWED                = "INTERNAL_HTTP_NOT_ALLOWED";
-this.ERROR_INTERNAL_INVALID_CERTIFICATE             = "INTERNAL_INVALID_CERTIFICATE";
-this.ERROR_INTERNAL_INVALID_PROMPT_RESULT           = "INTERNAL_INVALID_PROMPT_RESULT";
-this.ERROR_INTERNAL_INVALID_USER_SELECTION          = "INTERNAL_INVALID_USER_SELECTION";
-this.ERROR_INTERNAL_INVALID_VERIFICATION_FLOW       = "INTERNAL_INVALID_VERIFICATION_FLOW";
-this.ERROR_INTERNAL_INVALID_VERIFICATION_RESULT     = "INTERNAL_INVALID_VERIFICATION_RESULT";
-this.ERROR_INTERNAL_UNEXPECTED                      = "INTERNAL_UNEXPECTED";
-
-// Errors.
-this.ERROR_ENDPOINT_NOT_SUPPORTED                 = "ENDPOINT_NOT_SUPPORTED";
-this.ERROR_INVALID_ASSERTION                      = "INVALID_ASSERTION";
-this.ERROR_INVALID_AUTH_TOKEN                     = "INVALID_AUTH_TOKEN";
-this.ERROR_INVALID_BODY_JSON                      = "INVALID_BODY_JSON";
-this.ERROR_INVALID_BODY_MISSING_PARAMS            = "INVALID_BODY_MISSING_PARAMS";
-this.ERROR_INVALID_BODY_PARAMS                    = "INVALID_BODY_PARAMS";
-this.ERROR_INVALID_PHONE_NUMBER                   = "INVALID_PHONE_NUMBER";
-this.ERROR_INVALID_PROMPT_RESULT                  = "INVALID_PROMPT_RESULT";
-this.ERROR_INVALID_REQUEST_SIGNATURE              = "INVALID_REQUEST_SIGNATURE";
-this.ERROR_INVALID_VERIFICATION_CODE              = "INVALID_VERIFICATION_CODE";
-this.ERROR_MISSING_CONTENT_LENGTH_HEADER          = "MISSING_CONTENT_LENGTH_HEADER";
-this.ERROR_NO_RETRIES_LEFT                        = "NO_RETRIES_LEFT";
-this.ERROR_OFFLINE                                = "OFFLINE";
-this.ERROR_PERMISSION_DENIED                      = "PERMISSION_DENIED";
-this.ERROR_REQUEST_BODY_TOO_LARGE                 = "REQUEST_BODY_TOO_LARGE";
-this.ERROR_SERVICE_TEMPORARILY_UNAVAILABLE        = "SERVICE_TEMPORARILY_UNAVAILABLE";
-this.ERROR_TOO_MANY_REQUESTS_MSISDN               = "TOO_MANY_REQUESTS_MSISDN";
-this.ERROR_TOO_MANY_REQUESTS_UNSPECIFIED          = "TOO_MANY_REQUESTS_UNSPECIFIED";
-this.ERROR_TOO_MANY_REQUESTS_VERIFICAITON_CODE    = "TOO_MANY_REQUESTS_VERIFICATION_CODE";
-this.ERROR_TOO_MANY_REQUESTS_VERIFICATION_METHOD  = "TOO_MANY_REQUESTS_VERIFICATION_METHOD";
-this.ERROR_UNKNOWN                                = "UNKNOWN";
-this.ERROR_UNVERIFIED_ACCOUNT                     = "UNVERIFIED_ACCOUNT";
-this.ERROR_VERIFICATION_CODE_TIMEOUT              = "VERIFICATION_CODE_TIMEOUT";
-
-// Server errno.
-// From https://github.com/mozilla-services/msisdn-gateway/blob/master/API.md#response-format
-this.ERRNO_UNVERIFIED_ACCOUNT                     = 104;
-this.ERRNO_INVALID_VERIFICATION_CODE              = 105;
-this.ERRNO_INVALID_BODY_JSON                      = 106;
-this.ERRNO_INVALID_BODY_INVALID_PARAMS            = 107;
-this.ERRNO_INVALID_BODY_MISSING_PARAMS            = 108;
-this.ERRNO_INVALID_REQUEST_SIGNATURE              = 109;
-this.ERRNO_INVALID_AUTH_TOKEN                     = 110;
-this.ERRNO_ENDPOINT_NOT_SUPPORTED                 = 111;
-this.ERRNO_MISSING_CONTENT_LENGTH_HEADER          = 112;
-this.ERRNO_REQUEST_BODY_TOO_LARGE                 = 113;
-this.ERRNO_TOO_MANY_REQUESTS_VERIFICATION_CODE    = 114;
-this.ERRNO_TOO_MANY_REQUESTS_MSISDN               = 115;
-this.ERRNO_TOO_MANY_REQUESTS_VERIFICATION_METHOD  = 116;
-this.ERRNO_TOO_MANY_REQUESTS_UNSPECIFIED          = 117;
-this.ERRNO_SERVICE_TEMPORARILY_UNAVAILABLE        = 201;
-this.ERRNO_UNKNOWN_ERROR                          = 999;
-
-// Error matching.
-this.SERVER_ERRNO_TO_ERROR = {};
-SERVER_ERRNO_TO_ERROR[ERRNO_UNVERIFIED_ACCOUNT] = ERROR_UNVERIFIED_ACCOUNT;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_VERIFICATION_CODE] = ERROR_INVALID_VERIFICATION_CODE;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_BODY_JSON] = ERROR_INVALID_BODY_JSON;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_BODY_INVALID_PARAMS] = ERROR_INVALID_BODY_PARAMS;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_BODY_MISSING_PARAMS] = ERROR_INVALID_BODY_MISSING_PARAMS;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_REQUEST_SIGNATURE] = ERROR_INVALID_REQUEST_SIGNATURE;
-SERVER_ERRNO_TO_ERROR[ERRNO_INVALID_AUTH_TOKEN] = ERROR_INVALID_AUTH_TOKEN;
-SERVER_ERRNO_TO_ERROR[ERRNO_ENDPOINT_NOT_SUPPORTED] = ERROR_ENDPOINT_NOT_SUPPORTED;
-SERVER_ERRNO_TO_ERROR[ERRNO_MISSING_CONTENT_LENGTH_HEADER] = ERROR_MISSING_CONTENT_LENGTH_HEADER;
-SERVER_ERRNO_TO_ERROR[ERRNO_REQUEST_BODY_TOO_LARGE] = ERROR_REQUEST_BODY_TOO_LARGE;
-SERVER_ERRNO_TO_ERROR[ERRNO_TOO_MANY_REQUESTS_VERIFICATION_CODE] = ERROR_TOO_MANY_REQUESTS_VERIFICAITON_CODE;
-SERVER_ERRNO_TO_ERROR[ERRNO_TOO_MANY_REQUESTS_MSISDN] = ERROR_TOO_MANY_REQUESTS_MSISDN;;
-SERVER_ERRNO_TO_ERROR[ERRNO_TOO_MANY_REQUESTS_VERIFICATION_METHOD] = ERROR_TOO_MANY_REQUESTS_VERIFICATION_METHOD;;
-SERVER_ERRNO_TO_ERROR[ERRNO_TOO_MANY_REQUESTS_UNSPECIFIED] = ERROR_TOO_MANY_REQUESTS_UNSPECIFIED;;
-SERVER_ERRNO_TO_ERROR[ERRNO_SERVICE_TEMPORARILY_UNAVAILABLE] = ERROR_SERVICE_TEMPORARILY_UNAVAILABLE;
-SERVER_ERRNO_TO_ERROR[ERRNO_UNKNOWN_ERROR] = ERROR_UNKNOWN;
-
-// Allow this file to be imported via Components.utils.import().
-this.EXPORTED_SYMBOLS = Object.keys(this);
diff --git a/services/mobileid/MobileIdentityCredentialsStore.jsm b/services/mobileid/MobileIdentityCredentialsStore.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityCredentialsStore.jsm
+++ /dev/null
@@ -1,257 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentityCredentialsStore"];
-
-const {classes: Cc, interfaces: Ci, utils: Cu} = Components;
-
-Cu.import("resource://gre/modules/IndexedDBHelper.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-
-const CREDENTIALS_DB_NAME     = "mobile-id-credentials";
-const CREDENTIALS_DB_VERSION  = 1;
-const CREDENTIALS_STORE_NAME  = "credentials-store";
-
-this.MobileIdentityCredentialsStore = function() {
-};
-
-this.MobileIdentityCredentialsStore.prototype = {
-
-  __proto__: IndexedDBHelper.prototype,
-
-  init: function() {
-    log.debug("MobileIdentityCredentialsStore init");
-    this.initDBHelper(CREDENTIALS_DB_NAME,
-                      CREDENTIALS_DB_VERSION,
-                      [CREDENTIALS_STORE_NAME]);
-  },
-
-  upgradeSchema: function(aTransaction, aDb, aOldVersion, aNewVersion) {
-    log.debug("upgradeSchema");
-    /**
-     * We will be storing objects like:
-     *  {
-     *    msisdn: <string> (key),
-     *    iccId: <string> (index, optional),
-     *    deviceIccIds: <array>,
-     *    origin: <array> (index),
-     *    msisdnSessionToken: <string>,
-     *  }
-     */
-    let objectStore = aDb.createObjectStore(CREDENTIALS_STORE_NAME, {
-      keyPath: "msisdn"
-    });
-
-    objectStore.createIndex("iccId", "iccId", { unique: true });
-    objectStore.createIndex("origin", "origin", { unique: true, multiEntry: true });
-  },
-
-  add: function(aIccId, aMsisdn, aOrigin, aSessionToken, aDeviceIccIds) {
-    log.debug("put " + aIccId + ", " + aMsisdn + ", " + aOrigin + ", " +
-              aSessionToken + ", " + aDeviceIccIds);
-    if (!aOrigin || !aSessionToken) {
-      return Promise.reject(ERROR_INTERNAL_DB_ERROR);
-    }
-
-    let deferred = Promise.defer();
-
-    // We first try get an existing record for the given MSISDN.
-    this.newTxn(
-      "readwrite",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        let range = IDBKeyRange.only(aMsisdn);
-        let cursorReq = aStore.openCursor(range);
-        cursorReq.onsuccess = function(aEvent) {
-          let cursor = aEvent.target.result;
-          let record;
-          // If we already have a record of this MSISDN, we add the origin to
-          // the list of allowed origins.
-          if (cursor && cursor.value) {
-            record = cursor.value;
-            if (record.origin.indexOf(aOrigin) == -1) {
-              record.origin.push(aOrigin);
-            }
-            cursor.update(record);
-          } else {
-            // Otherwise, we store a new record.
-            record = {
-              iccId: aIccId,
-              msisdn: aMsisdn,
-              origin: [aOrigin],
-              sessionToken: aSessionToken,
-              deviceIccIds: aDeviceIccIds
-            };
-            aStore.add(record);
-          }
-          deferred.resolve();
-        };
-        cursorReq.onerror = function(aEvent) {
-          log.error(aEvent.target.error);
-          deferred.reject(ERROR_INTERNAL_DB_ERROR);
-        };
-      }, null, deferred.reject);
-
-    return deferred.promise;
-  },
-
-  getByMsisdn: function(aMsisdn) {
-    log.debug("getByMsisdn " + aMsisdn);
-    if (!aMsisdn) {
-      return Promise.resolve(null);
-    }
-
-    let deferred = Promise.defer();
-    this.newTxn(
-      "readonly",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        aStore.get(aMsisdn).onsuccess = function(aEvent) {
-          aTxn.result = aEvent.target.result;
-        };
-      },
-      function(result) {
-        deferred.resolve(result);
-      },
-      deferred.reject
-    );
-    return deferred.promise;
-  },
-
-  getByIndex: function(aIndex, aValue) {
-    log.debug("getByIndex " + aIndex + ", " + aValue);
-    if (!aValue || !aIndex) {
-      return Promise.resolve(null);
-    }
-
-    let deferred = Promise.defer();
-    this.newTxn(
-      "readonly",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        let index = aStore.index(aIndex);
-        index.get(aValue).onsuccess = function(aEvent) {
-          aTxn.result = aEvent.target.result;
-        };
-      },
-      function(result) {
-        deferred.resolve(result);
-      },
-      deferred.reject
-    );
-    return deferred.promise;
-  },
-
-  getByOrigin: function(aOrigin) {
-    return this.getByIndex("origin", aOrigin);
-  },
-
-  getByIccId: function(aIccId) {
-    return this.getByIndex("iccId", aIccId);
-  },
-
-  delete: function(aMsisdn) {
-    log.debug("delete " + aMsisdn);
-    if (!aMsisdn) {
-      return Promise.resolve();
-    }
-
-    let deferred = Promise.defer();
-    this.newTxn(
-      "readwrite",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        aStore.delete(aMsisdn);
-      },
-      deferred.resolve,
-      deferred.reject
-    );
-    return deferred.promise;
-  },
-
-  removeValue: function(aMsisdn, aKey, aValue) {
-    log.debug("Removing " + aKey + " with value " + aValue);
-    if (!aMsisdn || !aKey) {
-      return Promise.reject();
-    }
-
-    let deferred = Promise.defer();
-    this.newTxn(
-      "readwrite",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        let range = IDBKeyRange.only(aMsisdn);
-        let cursorReq = aStore.openCursor(range);
-        cursorReq.onsuccess = function(aEvent) {
-          let cursor = aEvent.target.result;
-          let record;
-          if (!cursor || !cursor.value) {
-            return Promise.resolve();
-          }
-          record = cursor.value;
-          if (!record[aKey]) {
-            return Promise.reject();
-          }
-          if (aValue) {
-            let index = record[aKey].indexOf(aValue);
-            if (index != -1) {
-              record[aKey].splice(index, 1);
-            }
-          } else {
-            record[aKey] = undefined;
-          }
-          log.debug("Removal done ${}", record);
-          cursor.update(record);
-          deferred.resolve();
-        };
-        cursorReq.onerror = function(aEvent) {
-          log.error(aEvent.target.error);
-          deferred.reject(ERROR_INTERNAL_DB_ERROR);
-        };
-      }, null, deferred.reject);
-
-    return deferred.promise;
-  },
-
-  removeOrigin: function(aMsisdn, aOrigin) {
-    log.debug("removeOrigin " + aMsisdn + " " + aOrigin);
-    return this.removeValue(aMsisdn, "origin", aOrigin);
-  },
-
-  setDeviceIccIds: function(aMsisdn, aDeviceIccIds) {
-    log.debug("Setting icc ids " + aDeviceIccIds + " for " + aMsisdn);
-    if (!aMsisdn) {
-      return Promise.reject();
-    }
-
-    let deferred = Promise.defer();
-    this.newTxn(
-      "readwrite",
-      CREDENTIALS_STORE_NAME,
-      (aTxn, aStore) => {
-        let range = IDBKeyRange.only(aMsisdn);
-        let cursorReq = aStore.openCursor(range);
-        cursorReq.onsuccess = function(aEvent) {
-          let cursor = aEvent.target.result;
-          let record;
-          if (!cursor || !cursor.value) {
-            return Promise.resolve();
-          }
-          record = cursor.value;
-          record.deviceIccIds = aDeviceIccIds;
-          cursor.update(record);
-          deferred.resolve();
-        };
-        cursorReq.onerror = function(aEvent) {
-          log.error(aEvent.target.error);
-          deferred.reject(ERROR_INTERNAL_DB_ERROR);
-        };
-      }, null, deferred.reject);
-
-    return deferred.promise;
-  }
-};
diff --git a/services/mobileid/MobileIdentityManager.jsm b/services/mobileid/MobileIdentityManager.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityManager.jsm
+++ /dev/null
@@ -1,1083 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentityManager"];
-
-const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
-
-Cu.import("resource://gre/modules/AppConstants.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/MobileIdentityUIGlueCommon.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "MobileIdentityCredentialsStore",
-  "resource://gre/modules/MobileIdentityCredentialsStore.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "MobileIdentityClient",
-  "resource://gre/modules/MobileIdentityClient.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "MobileIdentitySmsMtVerificationFlow",
-  "resource://gre/modules/MobileIdentitySmsMtVerificationFlow.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "MobileIdentitySmsMoMtVerificationFlow",
-  "resource://gre/modules/MobileIdentitySmsMoMtVerificationFlow.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "PhoneNumberUtils",
-  "resource://gre/modules/PhoneNumberUtils.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "jwcrypto",
-  "resource://gre/modules/identity/jwcrypto.jsm");
-
-XPCOMUtils.defineLazyServiceGetter(this, "uuidgen",
-                                   "@mozilla.org/uuid-generator;1",
-                                   "nsIUUIDGenerator");
-
-XPCOMUtils.defineLazyServiceGetter(this, "ppmm",
-                                   "@mozilla.org/parentprocessmessagemanager;1",
-                                   "nsIMessageListenerManager");
-
-XPCOMUtils.defineLazyServiceGetter(this, "permissionManager",
-                                   "@mozilla.org/permissionmanager;1",
-                                   "nsIPermissionManager");
-
-XPCOMUtils.defineLazyServiceGetter(this, "securityManager",
-                                   "@mozilla.org/scriptsecuritymanager;1",
-                                   "nsIScriptSecurityManager");
-
-XPCOMUtils.defineLazyServiceGetter(this, "appsService",
-                                   "@mozilla.org/AppsService;1",
-                                   "nsIAppsService");
-
-if (AppConstants.MOZ_B2G_RIL) {
-  XPCOMUtils.defineLazyServiceGetter(this, "Ril",
-                                     "@mozilla.org/ril;1",
-                                     "nsIRadioInterfaceLayer");
-
-  XPCOMUtils.defineLazyServiceGetter(this, "IccService",
-                                     "@mozilla.org/icc/iccservice;1",
-                                     "nsIIccService");
-
-  XPCOMUtils.defineLazyServiceGetter(this, "MobileConnectionService",
-                                     "@mozilla.org/mobileconnection/mobileconnectionservice;1",
-                                     "nsIMobileConnectionService");
-}
-
-
-this.MobileIdentityManager = {
-
-  init: function() {
-    log.debug("MobileIdentityManager init");
-    Services.obs.addObserver(this, "xpcom-shutdown", false);
-    ppmm.addMessageListener(GET_ASSERTION_IPC_MSG, this);
-    this.messageManagers = {};
-    this.keyPairs = {};
-    this.certificates = {};
-  },
-
-  receiveMessage: function(aMessage) {
-    log.debug("Received " + aMessage.name);
-
-    if (aMessage.name !== GET_ASSERTION_IPC_MSG) {
-      return;
-    }
-
-    let msg = aMessage.json;
-
-    // We save the message target message manager so we can later dispatch
-    // back messages without broadcasting to all child processes.
-    let promiseId = msg.promiseId;
-    this.messageManagers[promiseId] = aMessage.target;
-
-    this.getMobileIdAssertion(aMessage.principal, promiseId, msg.options);
-  },
-
-  observe: function(subject, topic, data) {
-    if (topic != "xpcom-shutdown") {
-      return;
-    }
-
-    ppmm.removeMessageListener(GET_ASSERTION_IPC_MSG, this);
-    Services.obs.removeObserver(this, "xpcom-shutdown");
-    this.messageManagers = null;
-  },
-
-  /*********************************************************
-   * Getters
-   ********************************************************/
-  get iccInfo() {
-    if (this._iccInfo) {
-      return this._iccInfo;
-    }
-    if (AppConstants.MOZ_B2G_RIL) {
-      let self = this;
-      let iccListener = {
-        notifyStkCommand: function() {},
-
-        notifyStkSessionEnd: function() {},
-
-        notifyCardStateChanged: function() {},
-
-        notifyIccInfoChanged: function() {
-          // If we receive a notification about an ICC info change, we clear
-          // the ICC related caches so they can be rebuilt with the new changes.
-
-          log.debug("ICC info changed observed. Clearing caches");
-
-          // We don't need to keep listening for changes until we rebuild the
-          // cache again.
-          for (let i = 0; i < self._iccInfo.length; i++) {
-            let icc = self.iccService.getIccByServiceId(i);
-            if (icc) {
-              icc.unregisterListener(iccListener);
-            }
-          }
-
-          self._iccInfo = null;
-          self._iccIds = null;
-        }
-      };
-
-      // _iccInfo is a local cache containing the information about the SIM cards
-      // that is interesting for the Mobile ID flow.
-      // The index of this array does not necesarily need to match the real
-      // identifier of the SIM card ("clientId" or "serviceId" in RIL language).
-      this._iccInfo = [];
-
-      for (let i = 0; i < this.ril.numRadioInterfaces; i++) {
-        let icc = this.iccService.getIccByServiceId(i);
-        if (!icc) {
-          log.warn("Tried to get the Icc instance for an invalid service ID " + i);
-          continue;
-        }
-
-        let info = icc.iccInfo;
-        if (!info || !info.iccid ||
-            !info.mcc || !info.mcc.length ||
-            !info.mnc || !info.mnc.length) {
-          log.warn("Absent or invalid ICC info");
-          continue;
-        }
-
-        // GSM SIMs may have MSISDN while CDMA SIMs may have MDN
-        let phoneNumber = null;
-        try {
-          if (info.iccType === "sim" || info.iccType === "usim") {
-            let gsmInfo = info.QueryInterface(Ci.nsIGsmIccInfo);
-            phoneNumber = gsmInfo.msisdn;
-          } else if (info.iccType === "ruim" || info.iccType === "csim") {
-            let cdmaInfo = info.QueryInterface(Ci.nsICdmaIccInfo);
-            phoneNumber = cdmaInfo.mdn;
-          }
-        } catch (e) {
-          log.error("Failed to retrieve phoneNumber: " + e);
-        }
-
-        let connection = this.mobileConnectionService.getItemByServiceId(i);
-        let voice = connection && connection.voice;
-        let data = connection && connection.data;
-        let operator = null;
-        if (voice &&
-            voice.network &&
-            voice.network.shortName &&
-            voice.network.shortName.length) {
-          operator = voice.network.shortName;
-        } else if (data &&
-                   data.network &&
-                   data.network.shortName &&
-                   data.network.shortName.length) {
-          operator = data.network.shortName;
-        }
-
-        this._iccInfo.push({
-          // Because it is possible that the _iccInfo array index doesn't match
-          // the real client ID, we need to store this value for later usage.
-          clientId: i,
-          iccId: info.iccid,
-          mcc: info.mcc,
-          mnc: info.mnc,
-          msisdn: phoneNumber,
-          operator: operator,
-          roaming: voice && voice.roaming
-        });
-
-        // We need to subscribe to ICC change notifications so we can refresh
-        // the cache if any change is observed.
-        icc.registerListener(iccListener);
-      }
-
-      return this._iccInfo;
-    } else {
-      return null;
-    }
-  },
-
-  get iccIds() {
-    if (AppConstants.MOZ_B2G_RIL) {
-      if (this._iccIds) {
-        return this._iccIds;
-      }
-
-      this._iccIds = [];
-      if (!this.iccInfo) {
-        return this._iccIds;
-      }
-
-      for (let i = 0; i < this.iccInfo.length; i++) {
-        this._iccIds.push(this.iccInfo[i].iccId);
-      }
-
-      return this._iccIds;
-    } else {
-      return null;
-    }
-  },
-
-  get credStore() {
-    if (!this._credStore) {
-      this._credStore = new MobileIdentityCredentialsStore();
-      this._credStore.init();
-    }
-    return this._credStore;
-  },
-
-  get ui() {
-    if (!this._ui) {
-      this._ui = Cc["@mozilla.org/services/mobileid-ui-glue;1"]
-                   .createInstance(Ci.nsIMobileIdentityUIGlue);
-      this._ui.oncancel = this.onUICancel.bind(this);
-      this._ui.onresendcode = this.onUIResendCode.bind(this);
-    }
-    return this._ui;
-  },
-
-  get client() {
-    if (!this._client) {
-      this._client = new MobileIdentityClient();
-    }
-    return this._client;
-  },
-
-  get isMultiSim() {
-    return this.iccInfo && this.iccInfo.length > 1;
-  },
-
-  getVerificationOptionsForIcc: function(aServiceId) {
-    log.debug("getVerificationOptionsForIcc " + aServiceId);
-    log.debug("iccInfo ${}", this.iccInfo[aServiceId]);
-    // First of all we need to check if we already have existing credentials
-    // for the given SIM information (ICC ID or MSISDN). If we have no valid
-    // credentials, we have to check with the server which options do we have
-    // to verify the associated phone number.
-    return this.credStore.getByIccId(this.iccInfo[aServiceId].iccId)
-    .then(
-      (creds) => {
-        if (creds) {
-          return creds;
-        }
-        return this.credStore.getByMsisdn(this.iccInfo[aServiceId].msisdn);
-      }
-    )
-    .then(
-      (creds) => {
-        if (creds) {
-          this.iccInfo[aServiceId].credentials = creds;
-          return;
-        }
-        // We have no credentials for this SIM, so we need to ask the server
-        // which options do we have to verify the phone number.
-        // But we need to be online...
-        if (Services.io.offline) {
-          return Promise.reject(ERROR_OFFLINE);
-        }
-        return this.client.discover(this.iccInfo[aServiceId].msisdn,
-                                    this.iccInfo[aServiceId].mcc,
-                                    this.iccInfo[aServiceId].mnc,
-                                    this.iccInfo[aServiceId].roaming);
-      }
-    )
-    .then(
-      (result) => {
-        // If we already have credentials for this ICC and no discover request
-        // is done, we just bail out.
-        if (!result || !result.verificationMethods) {
-          return;
-        }
-        log.debug("Discover result ${}", result);
-        this.iccInfo[aServiceId].verificationMethods = result.verificationMethods;
-        this.iccInfo[aServiceId].verificationDetails = result.verificationDetails;
-        this.iccInfo[aServiceId].canDoSilentVerification =
-          (result.verificationMethods.indexOf(SMS_MO_MT) != -1);
-        return;
-      }
-    );
-  },
-
-  getVerificationOptions: function() {
-    log.debug("getVerificationOptions");
-    // We try to get if we already have credentials for any of the inserted
-    // SIM cards if any is available and we try to get the possible
-    // verification mechanisms for these SIM cards.
-    // All this information will be stored in iccInfo.
-    if (!this.iccInfo || !this.iccInfo.length) {
-      let deferred = Promise.defer();
-      deferred.resolve(null);
-      return deferred.promise;
-    }
-
-    let promises = [];
-    for (let i = 0; i < this.iccInfo.length; i++) {
-      promises.push(this.getVerificationOptionsForIcc(i));
-    }
-    return Promise.all(promises);
-  },
-
-  getKeyPair: function(aSessionToken) {
-    if (this.keyPairs[aSessionToken] &&
-        this.keyPairs[aSessionToken].validUntil > this.client.hawk.now()) {
-      return Promise.resolve(this.keyPairs[aSessionToken].keyPair);
-    }
-
-    let validUntil = this.client.hawk.now() + KEY_LIFETIME;
-    let deferred = Promise.defer();
-    jwcrypto.generateKeyPair("DS160", (error, kp) => {
-      if (error) {
-        return deferred.reject(error);
-      }
-      this.keyPairs[aSessionToken] = {
-        keyPair: kp,
-        validUntil: validUntil
-      };
-      delete this.certificates[aSessionToken];
-      deferred.resolve(kp);
-    });
-
-    return deferred.promise;
-  },
-
-  getCertificate: function(aSessionToken, aPublicKey) {
-    log.debug("getCertificate");
-    if (this.certificates[aSessionToken] &&
-        this.certificates[aSessionToken].validUntil > this.client.hawk.now()) {
-      return Promise.resolve(this.certificates[aSessionToken].cert);
-    }
-
-    if (Services.io.offline) {
-      return Promise.reject(ERROR_OFFLINE);
-    }
-
-    let validUntil = this.client.hawk.now() + KEY_LIFETIME;
-    let deferred = Promise.defer();
-    this.client.sign(aSessionToken, CERTIFICATE_LIFETIME,
-                     aPublicKey)
-    .then(
-      (signedCert) => {
-        log.debug("Got signed certificate");
-        this.certificates[aSessionToken] = {
-          cert: signedCert.cert,
-          validUntil: validUntil
-        };
-        deferred.resolve(signedCert.cert);
-      },
-      deferred.reject
-    );
-    return deferred.promise;
-  },
-
-  /*********************************************************
-   * Setters (for test only purposes)
-   ********************************************************/
-  set ui(aUi) {
-    this._ui = aUi;
-  },
-
-  set credStore(aCredStore) {
-    this._credStore = aCredStore;
-  },
-
-  set client(aClient) {
-    this._client = aClient;
-  },
-
-  set iccInfo(aIccInfo) {
-    this._iccInfo = aIccInfo;
-  },
-
-  /*********************************************************
-   * UI callbacks
-   ********************************************************/
-
-  onUICancel: function() {
-    log.debug("UI cancel");
-    if (this.activeVerificationFlow) {
-      this.rejectVerification();
-    }
-  },
-
-  onUIResendCode: function() {
-    log.debug("UI resend code");
-    if (!this.activeVerificationFlow) {
-      return;
-    }
-    this.doVerification();
-  },
-
-  /*********************************************************
-   * Result helpers
-   *********************************************************/
-  success: function(aPromiseId, aResult) {
-    let mm = this.messageManagers[aPromiseId];
-    mm.sendAsyncMessage("MobileId:GetAssertion:Return:OK", {
-      promiseId: aPromiseId,
-      result: aResult
-    });
-  },
-
-  error: function(aPromiseId, aError) {
-    let mm = this.messageManagers[aPromiseId];
-    mm.sendAsyncMessage("MobileId:GetAssertion:Return:KO", {
-      promiseId: aPromiseId,
-      error: aError
-    });
-  },
-
-  /*********************************************************
-   * Permissions helper
-   ********************************************************/
-
-  addPermission: function(aPrincipal) {
-    permissionManager.addFromPrincipal(aPrincipal, MOBILEID_PERM,
-                                       Ci.nsIPermissionManager.ALLOW_ACTION);
-  },
-
-  /*********************************************************
-   * Phone number verification
-   ********************************************************/
-
-  rejectVerification: function(aReason) {
-    if (!this.activeVerificationDeferred) {
-      return;
-    }
-    this.activeVerificationDeferred.reject(aReason);
-    this.activeVerificationDeferred = null;
-    this.cleanupVerification(true /* unregister */);
-  },
-
-  resolveVerification: function(aResult) {
-    if (!this.activeVerificationDeferred) {
-      return;
-    }
-    this.activeVerificationDeferred.resolve(aResult);
-    this.activeVerificationDeferred = null;
-    this.cleanupVerification();
-  },
-
-  cleanupVerification: function(aUnregister = false) {
-    if (!this.activeVerificationFlow) {
-      return;
-    }
-    this.activeVerificationFlow.cleanup(aUnregister);
-    this.activeVerificationFlow = null;
-  },
-
-  doVerification: function() {
-    this.activeVerificationFlow.doVerification()
-    .then(
-      (verificationResult) => {
-        log.debug("onVerificationResult ");
-        if (!verificationResult || !verificationResult.sessionToken ||
-            !verificationResult.msisdn) {
-          return this.rejectVerification(
-            ERROR_INTERNAL_INVALID_VERIFICATION_RESULT
-          );
-        }
-        this.resolveVerification(verificationResult);
-      }
-    )
-    .then(
-      null,
-      reason => {
-        // Verification timeout.
-        log.warn("doVerification " + reason);
-      }
-    );
-  },
-
-  _verificationFlow: function(aToVerify, aOrigin) {
-    log.debug("toVerify ${}", aToVerify);
-
-    // We create the corresponding verification flow and save its instance
-    // in case that we need to cancel it or retrigger it because the user
-    // requested its cancelation or a resend of the verification code.
-    if (aToVerify.verificationMethod.indexOf(SMS_MT) != -1 &&
-        aToVerify.msisdn &&
-        aToVerify.verificationDetails &&
-        aToVerify.verificationDetails.mtSender) {
-      this.activeVerificationFlow = new MobileIdentitySmsMtVerificationFlow({
-          origin: aOrigin,
-          msisdn: aToVerify.msisdn,
-          mcc: aToVerify.mcc,
-          mnc: aToVerify.mnc,
-          iccId: aToVerify.iccId,
-          external: aToVerify.serviceId === undefined,
-          mtSender: aToVerify.verificationDetails.mtSender
-        },
-        this.ui,
-        this.client
-      );
-    } else if (AppConstants.MOZ_B2G_RIL &&
-               aToVerify.verificationMethod.indexOf(SMS_MO_MT) != -1 &&
-               aToVerify.serviceId &&
-               aToVerify.verificationDetails &&
-               aToVerify.verificationDetails.moVerifier &&
-               aToVerify.verificationDetails.mtSender) {
-      this.activeVerificationFlow = new MobileIdentitySmsMoMtVerificationFlow({
-          origin: aOrigin,
-          serviceId: aToVerify.serviceId,
-          iccId: aToVerify.iccId,
-          mtSender: aToVerify.verificationDetails.mtSender,
-          moVerifier: aToVerify.verificationDetails.moVerifier
-        },
-        this.ui,
-        this.client
-      );
-    } else {
-      return Promise.reject(ERROR_INTERNAL_CANNOT_VERIFY_SELECTION);
-    }
-
-    if (!this.activeVerificationFlow) {
-      return Promise.reject(ERROR_INTERNAL_CANNOT_CREATE_VERIFICATION_FLOW);
-    }
-
-    this.activeVerificationDeferred = Promise.defer();
-    this.doVerification();
-    return this.activeVerificationDeferred.promise;
-  },
-
-  verificationFlow: function(aUserSelection, aOrigin) {
-    log.debug("verificationFlow ${}", aUserSelection);
-
-    if (!aUserSelection) {
-      return Promise.reject(ERROR_INTERNAL_INVALID_USER_SELECTION);
-    }
-
-    let serviceId = aUserSelection.serviceId || undefined;
-    // We check if the user entered phone number corresponds with any of the
-    // inserted SIMs known phone numbers.
-    if (aUserSelection.msisdn && this.iccInfo) {
-      for (let i = 0; i < this.iccInfo.length; i++) {
-        if (aUserSelection.msisdn == this.iccInfo[i].msisdn) {
-          serviceId = i;
-          break;
-        }
-      }
-    }
-
-    let toVerify = {};
-
-    if (serviceId !== undefined) {
-      log.debug("iccInfo ${}", this.iccInfo[serviceId]);
-      toVerify.serviceId = serviceId;
-      toVerify.iccId = this.iccInfo[serviceId].iccId;
-      toVerify.msisdn = this.iccInfo[serviceId].msisdn;
-      toVerify.mcc = this.iccInfo[serviceId].mcc;
-      toVerify.mnc = this.iccInfo[serviceId].mnc;
-      toVerify.verificationMethod =
-        this.iccInfo[serviceId].verificationMethods[0];
-      toVerify.verificationDetails =
-        this.iccInfo[serviceId].verificationDetails[toVerify.verificationMethod];
-      return this._verificationFlow(toVerify, aOrigin);
-    } else {
-      toVerify.msisdn = aUserSelection.msisdn;
-      toVerify.mcc = aUserSelection.mcc;
-      return this.client.discover(aUserSelection.msisdn,
-                                  aUserSelection.mcc)
-      .then(
-        (discoverResult) => {
-          if (!discoverResult || !discoverResult.verificationMethods) {
-            return Promise.reject(ERROR_INTERNAL_UNEXPECTED);
-          }
-          log.debug("discoverResult ${}", discoverResult);
-          toVerify.verificationMethod = discoverResult.verificationMethods[0];
-          toVerify.verificationDetails =
-            discoverResult.verificationDetails[toVerify.verificationMethod];
-          return this._verificationFlow(toVerify, aOrigin);
-        }
-      );
-    }
-  },
-
-
-  /*********************************************************
-   * UI prompt functions.
-   ********************************************************/
-
-  // The phone number prompt will be used to confirm that the user wants to
-  // verify and share a known phone number and to allow her to introduce an
-  // external phone or to select between phone numbers or SIM cards (if the
-  // phones are not known) in a multi-SIM scenario.
-  // This prompt will be considered as the permission prompt and its choice
-  // will be remembered per origin by default.
-  prompt: function prompt(aPrincipal, aManifestURL, aPhoneInfo) {
-    log.debug("prompt ${principal} ${manifest} ${phoneInfo}", {
-      principal: aPrincipal,
-      manifest: aManifestURL,
-      phoneInfo: aPhoneInfo
-    });
-
-    let phoneInfoArray = [];
-
-    if (aPhoneInfo) {
-      phoneInfoArray.push(aPhoneInfo);
-    }
-
-    if (this.iccInfo) {
-      for (let i = 0; i < this.iccInfo.length; i++) {
-        // If we don't know the msisdn, there is no previous credentials and
-        // a silent verification is not possible or if the msisdn is the one
-        // that is already chosen, we don't list this SIM as an option.
-        if ((!this.iccInfo[i].msisdn && !this.iccInfo[i].credentials &&
-            !this.iccInfo[i].canDoSilentVerification) ||
-            ((aPhoneInfo) &&
-             (this.iccInfo[i].msisdn == aPhoneInfo.msisdn ||
-              this.iccInfo[i].iccId == aPhoneInfo.iccId))) {
-          continue;
-        }
-
-        let phoneInfo = new MobileIdentityUIGluePhoneInfo(
-          this.iccInfo[i].msisdn,
-          this.iccInfo[i].operator,
-          i,                      // service ID
-          this.iccInfo[i].iccId,  // iccId
-          false                   // primary
-        );
-        phoneInfoArray.push(phoneInfo);
-      }
-    }
-
-    return this.ui.startFlow(aManifestURL, phoneInfoArray)
-    .then(
-      (result) => {
-        log.debug("startFlow result ${} ", result);
-        if (!result ||
-            (!result.phoneNumber && (result.serviceId === undefined))) {
-          return Promise.reject(ERROR_INTERNAL_INVALID_PROMPT_RESULT);
-        }
-
-        let msisdn;
-        let mcc;
-
-        // If the user selected one of the existing SIM cards we have to check
-        // that we either have the MSISDN for that SIM, we have already existing
-        // credentials or we can do a silent verification that does not require
-        // us to have the MSISDN in advance.
-        // result.serviceId can be "0".
-        if (result.serviceId !== undefined &&
-            result.serviceId !== null) {
-          let icc = this.iccInfo[result.serviceId];
-          log.debug("icc ${}", icc);
-          if (!icc || !icc.msisdn && !icc.canDoSilentVerification &&
-              !icc.credentials) {
-            return Promise.reject(ERROR_INTERNAL_CANNOT_VERIFY_SELECTION);
-          }
-          msisdn = icc.msisdn;
-          mcc = icc.mcc;
-        } else {
-          msisdn = result.prefix ? result.prefix + result.phoneNumber
-                                 : result.phoneNumber;
-          mcc = result.mcc;
-        }
-
-        // We need to check that the selected phone number is valid and
-        // if it is not notify the UI about the error and allow the user to
-        // retry.
-        if (msisdn && mcc &&
-            !PhoneNumberUtils.parseWithMCC(msisdn, mcc)) {
-          this.ui.error(ERROR_INVALID_PHONE_NUMBER);
-          return this.prompt(aPrincipal, aManifestURL, aPhoneInfo);
-        }
-
-        log.debug("Selected msisdn (if any): " + msisdn + " - " + mcc);
-
-        // The user gave permission for the requester origin, so we store it.
-        this.addPermission(aPrincipal);
-
-        return {
-          msisdn: msisdn,
-          mcc: mcc,
-          serviceId: result.serviceId
-        };
-      }
-    );
-  },
-
-  promptAndVerify: function(aPrincipal, aManifestURL, aCreds) {
-    log.debug("promptAndVerify " + aPrincipal + ", " + aManifestURL +
-              ", ${}", aCreds);
-    let userSelection;
-
-    if (Services.io.offline) {
-      return Promise.reject(ERROR_OFFLINE);
-    }
-
-    // Before prompting the user we need to check with the server the
-    // phone number verification methods that are possible with the
-    // SIMs inserted in the device.
-    return this.getVerificationOptions()
-    .then(
-      () => {
-        // If we have an exisiting credentials, we add its associated
-        // phone number information to the list of choices to present
-        // to the user within the selection prompt.
-        let phoneInfo;
-        if (aCreds) {
-          phoneInfo = new MobileIdentityUIGluePhoneInfo(
-            aCreds.msisdn,
-            null,           // operator
-            undefined,      // service ID
-            aCreds.iccId,   // iccId
-            true            // primary
-          );
-        }
-        return this.prompt(aPrincipal, aManifestURL, phoneInfo);
-      }
-    )
-    .then(
-      (promptResult) => {
-        log.debug("promptResult ${}", promptResult);
-        // If we had credentials and the user didn't change her
-        // selection we return them. Otherwise, we need to verify
-        // the new number.
-        if (promptResult.msisdn && aCreds &&
-            promptResult.msisdn == aCreds.msisdn) {
-          return aCreds;
-        }
-
-        // We might already have credentials for the user selected icc. In
-        // that case, we update the credentials store with the new origin and
-        // return the credentials.
-        if (promptResult.serviceId) {
-          let creds = this.iccInfo[promptResult.serviceId].credentials;
-          if (creds) {
-            this.credStore.add(creds.iccId, creds.msisdn, aPrincipal.originNoSuffix,
-                               creds.sessionToken, this.iccIds);
-            return creds;
-          }
-        }
-
-        // Or we might already have credentials for the selected phone
-        // number and so we do the same: update the credentials store with the
-        // new origin and return the credentials.
-        return this.credStore.getByMsisdn(promptResult.msisdn)
-        .then(
-          (creds) => {
-            if (creds) {
-              this.credStore.add(creds.iccId, creds.msisdn, aPrincipal.originNoSuffix,
-                                 creds.sessionToken, this.iccIds);
-              return creds;
-            }
-            // Otherwise, we need to verify the new number selected by the
-            // user.
-            return this.verificationFlow(promptResult, aPrincipal.originNoSuffix);
-          }
-        );
-      }
-    );
-  },
-
-  /*********************************************************
-   * Credentials check
-   *********************************************************/
-
-  checkNewCredentials: function(aOldCreds, aNewCreds, aOrigin) {
-    // If there were previous credentials and the user changed her
-    // choice, we need to remove the origin from the old credentials.
-    if (aNewCreds.msisdn != aOldCreds.msisdn) {
-      return this.credStore.removeOrigin(aOldCreds.msisdn,
-                                         aOrigin)
-      .then(
-        () => {
-          return aNewCreds;
-        }
-      );
-    } else {
-      // Otherwise, we update the status of the SIM cards in the device
-      // so we know that the user decided not to take the chance to change
-      // her selection. We won't bother her again until a new SIM card
-      // change is detected.
-      return this.credStore.setDeviceIccIds(aOldCreds.msisdn, this.iccIds)
-      .then(
-        () => {
-          return aOldCreds;
-        }
-      );
-    }
-  },
-
-  /*********************************************************
-   * Assertion generation
-   ********************************************************/
-
-  generateAssertion: function(aCredentials, aOrigin) {
-    if (!aCredentials.sessionToken) {
-      return Promise.reject(ERROR_INTERNAL_INVALID_TOKEN);
-    }
-
-    let deferred = Promise.defer();
-
-    this.getKeyPair(aCredentials.sessionToken)
-    .then(
-      (keyPair) => {
-        log.debug("keyPair " + keyPair.serializedPublicKey);
-        let options = {
-          duration: ASSERTION_LIFETIME,
-          now: this.client.hawk.now(),
-          localtimeOffsetMsec: this.client.hawk.localtimeOffsetMsec
-        };
-
-        this.getCertificate(aCredentials.sessionToken,
-                            keyPair.serializedPublicKey)
-        .then(
-          (signedCert) => {
-            log.debug("generateAssertion " + signedCert);
-            jwcrypto.generateAssertion(signedCert, keyPair,
-                                       aOrigin, options,
-                                       (error, assertion) => {
-              if (error) {
-                log.error("Error generating assertion " + err);
-                deferred.reject(error);
-                return;
-              }
-              this.credStore.add(aCredentials.iccId,
-                                 aCredentials.msisdn,
-                                 aOrigin,
-                                 aCredentials.sessionToken,
-                                 this.iccIds)
-              .then(
-                () => {
-                  deferred.resolve(assertion);
-                }
-              );
-            });
-          }, deferred.reject
-        );
-      }
-    );
-
-    return deferred.promise;
-  },
-
-  getMobileIdAssertion: function(aPrincipal, aPromiseId, aOptions) {
-    log.debug("getMobileIdAssertion ${}", aPrincipal);
-
-    let principal = aPrincipal;
-    let manifestURL = appsService.getManifestURLByLocalId(aPrincipal.appId);
-
-    let permission = permissionManager.testPermissionFromPrincipal(
-      principal,
-      MOBILEID_PERM
-    );
-
-    if (permission == Ci.nsIPermissionManager.DENY_ACTION ||
-        permission == Ci.nsIPermissionManager.UNKNOWN_ACTION) {
-      this.error(aPromiseId, ERROR_PERMISSION_DENIED);
-      return;
-    }
-
-    let _creds;
-
-    // First of all we look if we already have credentials for this origin.
-    // If we don't have credentials it means that it is the first time that
-    // the caller requested an assertion.
-    this.credStore.getByOrigin(aPrincipal.originNoSuffix)
-    .then(
-      (creds) => {
-        log.debug("creds ${creds} - ${origin}", { creds: creds,
-                                                  origin: aPrincipal.originNoSuffix });
-        if (!creds || !creds.sessionToken) {
-          log.debug("No credentials");
-          return;
-        }
-
-        _creds = creds;
-
-        // Even if we already have credentials for this origin, the consumer
-        // of the API might want to force the identity selection dialog.
-        if (aOptions.forceSelection || aOptions.refreshCredentials) {
-          return this.promptAndVerify(principal, manifestURL, creds)
-          .then(
-            (newCreds) => {
-              return this.checkNewCredentials(creds, newCreds,
-                                              principal.originNoSuffix);
-            }
-          );
-        }
-
-        // SIM change scenario.
-
-        // It is possible that the SIM cards inserted in the device at the
-        // moment of the previous verification where we obtained the credentials
-        // has changed. In that case, we need to let the user knowabout this
-        // situation. Otherwise, we just return the credentials.
-        log.debug("Looking for SIM changes. Credentials ICCS ${creds} " +
-                  "Device ICCS ${device}", { creds: creds.deviceIccIds,
-                                             device: this.iccIds });
-        let simChanged = (creds.deviceIccIds == null && this.iccIds != null) ||
-                         (creds.deviceIccIds != null && this.iccIds == null);
-
-        if (!simChanged &&
-            creds.deviceIccIds != null &&
-            this.iccIds != null) {
-          simChanged = creds.deviceIccIds.length != this.iccIds.length;
-        }
-
-        if (!simChanged &&
-            creds.deviceIccIds != null &&
-            this.iccIds != null) {
-          let intersection = creds.deviceIccIds.filter((n) => {
-            return this.iccIds.indexOf(n) != -1;
-          });
-          simChanged = intersection.length != creds.deviceIccIds.length ||
-                       intersection.length != this.iccIds.length;
-        }
-
-        if (!simChanged) {
-          return creds;
-        }
-
-        // At this point we know that the SIM associated with the credentials
-        // is not present in the device any more or a new SIM has been detected,
-        // so we need to ask the user what to do.
-        return this.promptAndVerify(principal, manifestURL, creds)
-        .then(
-          (newCreds) => {
-            return this.checkNewCredentials(creds, newCreds,
-                                            principal.originNoSuffix);
-          }
-        );
-      }
-    )
-    .then(
-      (creds) => {
-        // Even if we have credentails it is possible that the user has
-        // removed the permission to share its mobile id with this origin, so
-        // we check the permission and if it is not granted, we ask the user
-        // before generating and sharing the assertion.
-        // If we've just prompted the user in the previous step, the permission
-        // is already granted and stored so we just progress the credentials.
-        // But we have to refresh the cached permission before checking.
-        if (creds) {
-          permission = permissionManager.testPermissionFromPrincipal(
-            principal,
-            MOBILEID_PERM
-          );
-          if (permission == Ci.nsIPermissionManager.ALLOW_ACTION) {
-            return creds;
-          }
-          return this.promptAndVerify(principal, manifestURL, creds);
-        }
-        return this.promptAndVerify(principal, manifestURL);
-      }
-    )
-    .then(
-      (creds) => {
-        if (creds) {
-          return this.generateAssertion(creds, principal.originNoSuffix);
-        }
-        return Promise.reject(ERROR_INTERNAL_CANNOT_GENERATE_ASSERTION);
-      }
-    )
-    .then(
-      (assertion) => {
-        if (!assertion) {
-          return Promise.reject(ERROR_INTERNAL_CANNOT_GENERATE_ASSERTION);
-        }
-
-        // Get the verified phone number from the assertion.
-        let segments = assertion.split(".");
-        if (!segments) {
-          return Promise.reject(ERROR_INVALID_ASSERTION);
-        }
-
-        // We need to translate the base64 alphabet used in JWT to our base64
-        // alphabet before calling atob.
-        let decodedPayload = JSON.parse(atob(segments[1].replace(/-/g, '+')
-                                                        .replace(/_/g, '/')));
-
-        if (!decodedPayload || !decodedPayload.verifiedMSISDN) {
-          return Promise.reject(ERROR_INVALID_ASSERTION);
-        }
-
-        this.ui.verified(decodedPayload.verifiedMSISDN);
-
-        this.success(aPromiseId, assertion);
-      }
-    )
-    .then(
-      null,
-      (error) => {
-        log.error("getMobileIdAssertion rejected with ${}", error);
-
-        // If we got an invalid token error means that the credentials that
-        // we have are not valid anymore and so we need to refresh them. We
-        // do that removing the stored credentials and starting over. We also
-        // make sure that we do this only once.
-        if (error === ERROR_INVALID_AUTH_TOKEN &&
-            !aOptions.refreshCredentials) {
-          log.debug("Need to get new credentials");
-          aOptions.refreshCredentials = true;
-          _creds && this.credStore.delete(_creds.msisdn);
-          this.getMobileIdAssertion(aPrincipal, aPromiseId, aOptions);
-          return;
-        }
-
-        // Notify the error to the UI.
-        this.ui.error(error);
-
-        this.error(aPromiseId, error);
-      }
-    );
-  },
-
-};
-
-if (AppConstants.MOZ_B2G_RIL) {
-  // We have these getters to allow mocking RIL stuff from the tests.
-  Object.defineProperties(MobileIdentityManager, {
-    "ril": {
-      configurable: true,
-      enumerable: true,
-      get() {
-        if (this._ril) {
-          return this._ril;
-        }
-        return Ril;
-      }
-    },
-    "iccService": {
-      configurable: true,
-      enumerable: true,
-      get() {
-        if (this._iccService) {
-          return this._iccService;
-        }
-        return IccService;
-      }
-    },
-    "mobileConnectionService": {
-      configurable: true,
-      enumerable: true,
-      get() {
-        if (this._mobileConnectionService) {
-          return this._mobileConnectionService;
-        }
-        return MobileConnectionService;
-      }
-    }
-  });
-}
-
-MobileIdentityManager.init();
diff --git a/services/mobileid/MobileIdentitySmsMoMtVerificationFlow.jsm b/services/mobileid/MobileIdentitySmsMoMtVerificationFlow.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentitySmsMoMtVerificationFlow.jsm
+++ /dev/null
@@ -1,79 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentitySmsMoMtVerificationFlow"];
-
-const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
-
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/MobileIdentitySmsVerificationFlow.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-XPCOMUtils.defineLazyServiceGetter(this, "smsService",
-                                   "@mozilla.org/sms/smsservice;1",
-                                   "nsISmsService");
-
-// In order to send messages through nsISmsService, we need to implement
-// nsIMobileMessageCallback, as the WebSMS API implementation is not usable
-// from JS.
-function SilentSmsRequest(aDeferred) {
-  this.deferred = aDeferred;
-}
-SilentSmsRequest.prototype = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMobileMessageCallback]),
-
-  classID: Components.ID("{ff46f1a8-e040-4ff4-98a7-d5a5b86a2c3e}"),
-
-  notifyMessageSent: function notifyMessageSent(aMessage) {
-    log.debug("Silent message successfully sent");
-    this.deferred.resolve(aMessage);
-  },
-
-  notifySendMessageFailed: function notifySendMessageFailed(aError) {
-    log.error("Error sending silent message " + aError);
-    this.deferred.reject(aError);
-  }
-};
-
-this.MobileIdentitySmsMoMtVerificationFlow = function(aVerificationOptions,
-                                                      aUI,
-                                                      aClient) {
-
-  log.debug("MobileIdentitySmsMoMtVerificationFlow ${}", aVerificationOptions);
-
-  MobileIdentitySmsVerificationFlow.call(this,
-                                         aVerificationOptions,
-                                         aUI,
-                                         aClient,
-                                         this.smsVerifyStrategy);
-};
-
-this.MobileIdentitySmsMoMtVerificationFlow.prototype = {
-
-  __proto__: MobileIdentitySmsVerificationFlow.prototype,
-
-  smsVerifyStrategy: function() {
-    // In the MO+MT flow we need to send an SMS to the given moVerifier number
-    // so the server can find out our phone number to send an SMS back with a
-    // verification code.
-    let deferred = Promise.defer();
-    let silentSmsRequest = new SilentSmsRequest(deferred);
-
-    // The MO SMS body that the server expects contains the API endpoint for
-    // the MO verify request and the HAWK ID parameter derived via HKDF from
-    // the session token. These parameters should go unnamed and space limited.
-    let body = SMS_MO_MT_VERIFY + " " +
-               this.client._deriveHawkCredentials(this.sessionToken).id;
-    smsService.send(this.verificationOptions.serviceId,
-                    this.verificationOptions.moVerifier,
-                    body,
-                    true, // silent
-                    silentSmsRequest);
-    log.debug("Sending " + body + " to " + this.verificationOptions.moVerifier);
-    return deferred.promise;
-  }
-};
diff --git a/services/mobileid/MobileIdentitySmsMtVerificationFlow.jsm b/services/mobileid/MobileIdentitySmsMtVerificationFlow.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentitySmsMtVerificationFlow.jsm
+++ /dev/null
@@ -1,40 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentitySmsMtVerificationFlow"];
-
-const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
-
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/MobileIdentitySmsVerificationFlow.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-this.MobileIdentitySmsMtVerificationFlow = function(aVerificationOptions,
-                                                    aUI,
-                                                    aClient) {
-
-  log.debug("MobileIdentitySmsVerificationFlow ${}", aVerificationOptions);
-
-  MobileIdentitySmsVerificationFlow.call(this,
-                                         aVerificationOptions,
-                                         aUI,
-                                         aClient,
-                                         this.smsVerifyStrategy);
-};
-
-this.MobileIdentitySmsMtVerificationFlow.prototype = {
-
-  __proto__: MobileIdentitySmsVerificationFlow.prototype,
-
-  smsVerifyStrategy: function() {
-    return this.client.smsMtVerify(this.sessionToken,
-                                   this.verificationOptions.msisdn,
-                                   this.verificationOptions.mcc,
-                                   this.verificationOptions.mnc,
-                                   this.verificationOptions.external);
-  }
-};
diff --git a/services/mobileid/MobileIdentitySmsVerificationFlow.jsm b/services/mobileid/MobileIdentitySmsVerificationFlow.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentitySmsVerificationFlow.jsm
+++ /dev/null
@@ -1,109 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentitySmsVerificationFlow"];
-
-const { classes: Cc, interfaces: Ci, utils: Cu } = Components;
-
-Cu.import("resource://gre/modules/AppConstants.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/MobileIdentityVerificationFlow.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-if (AppConstants.MOZ_B2G_RIL) {
-  XPCOMUtils.defineLazyServiceGetter(this, "smsService",
-                                     "@mozilla.org/sms/smsservice;1",
-                                     "nsISmsService");
-}
-
-this.MobileIdentitySmsVerificationFlow = function(aVerificationOptions,
-                                                  aUI,
-                                                  aClient,
-                                                  aVerifyStrategy) {
-
-  // SMS MT or SMS MO+MT specific verify strategy.
-  this.smsVerifyStrategy = aVerifyStrategy;
-
-  log.debug("aVerificationOptions ${}", aVerificationOptions);
-  MobileIdentityVerificationFlow.call(this, aVerificationOptions, aUI, aClient,
-                                      this._verifyStrategy, this._cleanupStrategy);
-};
-
-this.MobileIdentitySmsVerificationFlow.prototype = {
-
-  __proto__: MobileIdentityVerificationFlow.prototype,
-
-  observedSilentNumber: null,
-
-  onSilentSms: null,
-
-  _verifyStrategy: function() {
-    if (!this.smsVerifyStrategy) {
-      return Promise.reject(ERROR_INTERNAL_UNEXPECTED);
-    }
-
-    // Even if the user selection is given to us as a possible external phone
-    // number, it is also possible that the phone number introduced by the
-    // user belongs to one of the SIMs inserted in the device which MSISDN
-    // is unknown for us, so we always observe for incoming messages coming
-    // from the given mtSender.
-
-    if (AppConstants.MOZ_B2G_RIL) {
-      this.observedSilentNumber = this.verificationOptions.mtSender;
-      try {
-        smsService.addSilentNumber(this.observedSilentNumber);
-      } catch (e) {
-        log.warn("We are already listening for that number");
-      }
-
-      this.onSilentSms = (function(aSubject, aTopic, aData) {
-        log.debug("Got silent message " + aSubject.sender + " - " + aSubject.body);
-        // We might have observed a notification of an incoming silent message
-        // for other number. In that case, we just bail out.
-        if (aSubject.sender != this.observedSilentNumber) {
-          return;
-        }
-
-        // We got the SMS containing the verification code.
-
-        // If the phone number we are trying to verify is or can be an external
-        // phone number (meaning that it doesn't belong to any of the inserted
-        // SIMs) we will be receiving an human readable SMS containing a short
-        // verification code. In this case we need to parse the SMS body to
-        // extract the verification code.
-        // Otherwise, we just use the whole SMS body as it should contain a long
-        // verification code.
-        let verificationCode = aSubject.body;
-        if (this.verificationOptions.external) {
-          // We just take the numerical characters from the body.
-          verificationCode = aSubject.body.replace(/[^0-9]/g,'');
-        }
-
-        log.debug("Verification code: " + verificationCode);
-
-        this.verificationCodeDeferred.resolve(verificationCode);
-      }).bind(this);
-
-      Services.obs.addObserver(this.onSilentSms,
-                               SILENT_SMS_RECEIVED_TOPIC,
-                               false);
-      log.debug("Observing messages from " + this.observedSilentNumber);
-    }
-
-    return this.smsVerifyStrategy();
-  },
-
-  _cleanupStrategy: function() {
-    if (AppConstants.MOZ_B2G_RIL) {
-      smsService.removeSilentNumber(this.observedSilentNumber);
-      Services.obs.removeObserver(this.onSilentSms,
-                                  SILENT_SMS_RECEIVED_TOPIC);
-      this.observedSilentNumber = null;
-      this.onSilentSms = null;
-    }
-  }
-};
diff --git a/services/mobileid/MobileIdentityUIGlueCommon.jsm b/services/mobileid/MobileIdentityUIGlueCommon.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityUIGlueCommon.jsm
+++ /dev/null
@@ -1,32 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentityUIGluePhoneInfo",
-                         "MobileIdentityUIGluePromptResult"];
-
-this.MobileIdentityUIGluePhoneInfo = function (aMsisdn, aOperator, aServiceId,
-                                               aIccId, aPrimary) {
-  this.msisdn = aMsisdn;
-  this.operator = aOperator;
-  this.serviceId = aServiceId;
-  this.iccId = aIccId;
-  // A phone number is considered "external" when it doesn't or we don't know
-  // if it does belong to any of the device SIM cards.
-  this.external = !!aIccId;
-  this.primary = aPrimary;
-}
-
-this.MobileIdentityUIGluePhoneInfo.prototype = {};
-
-this.MobileIdentityUIGluePromptResult = function (aPhoneNumber, aPrefix, aMcc,
-                                                  aServiceId) {
-  this.phoneNumber = aPhoneNumber;
-  this.prefix = aPrefix;
-  this.mcc = aMcc;
-  this.serviceId = aServiceId;
-}
-
-this.MobileIdentityUIGluePromptResult.prototype = {};
diff --git a/services/mobileid/MobileIdentityVerificationFlow.jsm b/services/mobileid/MobileIdentityVerificationFlow.jsm
deleted file mode 100644
--- a/services/mobileid/MobileIdentityVerificationFlow.jsm
+++ /dev/null
@@ -1,215 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-this.EXPORTED_SYMBOLS = ["MobileIdentityVerificationFlow"];
-
-const { utils: Cu, classes: Cc, interfaces: Ci } = Components;
-
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-this.MobileIdentityVerificationFlow = function(aVerificationOptions,
-                                               aUI,
-                                               aClient,
-                                               aVerifyStrategy,
-                                               aCleanupStrategy) {
-  this.verificationOptions = aVerificationOptions;
-  this.ui = aUI;
-  this.client = aClient;
-  this.retries = VERIFICATIONCODE_RETRIES;
-  this.verifyStrategy = aVerifyStrategy;
-  this.cleanupStrategy = aCleanupStrategy;
-};
-
-MobileIdentityVerificationFlow.prototype = {
-
-  doVerification: function() {
-    log.debug("Start verification flow");
-    return this.register()
-    .then(
-      (registerResult) => {
-        log.debug("Register result ${}", registerResult);
-        if (!registerResult || !registerResult.msisdnSessionToken) {
-          return Promise.reject(ERROR_INTERNAL_UNEXPECTED);
-        }
-        this.sessionToken = registerResult.msisdnSessionToken;
-        // We save the timestamp of the start of the verification timeout to be
-        // able to provide to the UI the remaining time on each retry.
-        if (!this.timer) {
-          log.debug("Creating verification code timer");
-          this.timerCreation = Date.now();
-          this.timer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-          this.timer.initWithCallback(this.onVerificationCodeTimeout.bind(this),
-                                      VERIFICATIONCODE_TIMEOUT,
-                                      this.timer.TYPE_ONE_SHOT);
-        }
-
-        if (!this.verifyStrategy) {
-          return Promise.reject(ERROR_INTERNAL_INVALID_VERIFICATION_FLOW);
-        }
-
-        return this.verifyStrategy()
-        .then(() => {
-          return this._doVerification();
-        }, (reason) => {
-          this.verificationCodeDeferred.reject(reason);
-        });
-      }
-    )
-  },
-
-  _doVerification: function() {
-    log.debug("_doVerification");
-
-    this.verificationCodeDeferred = Promise.defer();
-
-    // If the verification flow can be for an external phone number,
-    // we need to ask the user for the verification code.
-    // In that case we don't do a notification about the verification
-    // process being done until the user enters the verification code
-    // in the UI.
-    if (this.verificationOptions.external) {
-      let timeLeft = 0;
-      if (this.timer) {
-        timeLeft = this.timerCreation + VERIFICATIONCODE_TIMEOUT -
-                   Date.now();
-      }
-      this.ui.verificationCodePrompt(this.retries,
-                                     VERIFICATIONCODE_TIMEOUT / 1000,
-                                     timeLeft / 1000)
-      .then(
-        (verificationCode) => {
-          if (!verificationCode) {
-            return this.verificationCodeDeferred.reject(
-              ERROR_INTERNAL_INVALID_PROMPT_RESULT);
-          }
-          // If the user got the verification code that means that the
-          // introduced phone number didn't belong to any of the inserted
-          // SIMs.
-          this.ui.verify();
-          this.verificationCodeDeferred.resolve(verificationCode);
-        }
-      );
-    } else {
-      this.ui.verify();
-    }
-
-    return this.verificationCodeDeferred.promise.then(
-      this.onVerificationCode.bind(this)
-    );
-  },
-
-  // When we receive a verification code from the UI, we check it against
-  // the server. If the verification code is incorrect, we decrease the
-  // number of retries left and allow the user to try again. If there is no
-  // possible retry left, we notify about this error so the UI can allow the
-  // user to request the resend of a new verification code.
-  onVerificationCode: function(aVerificationCode) {
-    log.debug("onVerificationCode " + aVerificationCode);
-    if (!aVerificationCode) {
-      this.ui.error(ERROR_INVALID_VERIFICATION_CODE);
-      return this._doVerification();
-    }
-
-    // Before checking the verification code against the server we set the
-    // "verifying" flag to queue timeout expiration events received before
-    // the server request is completed. If the server request is positive
-    // we will discard the timeout event, otherwise we will progress the
-    // event to the UI to allow the user to retry.
-    this.verifying = true;
-
-    return this.verifyCode(aVerificationCode)
-    .then(
-      (result) => {
-        if (!result) {
-          return Promise.reject(INTERNAL_UNEXPECTED);
-        }
-        // The code was correct!
-        // At this point the phone number is verified.
-        // We return the given verification options with the session token
-        // to be stored in the credentials store. With this data we will be
-        // asking the server to give us a certificate to generate assertions.
-        this.verificationOptions.sessionToken = this.sessionToken;
-        this.verificationOptions.msisdn = result.msisdn ||
-                                          this.verificationOptions.msisdn;
-        return this.verificationOptions;
-      },
-      (error) => {
-        log.error("Verification code error " + error);
-        this.retries--;
-        log.error("Retries left " + this.retries);
-        if (!this.retries) {
-          this.ui.error(ERROR_NO_RETRIES_LEFT);
-          this.timer.cancel();
-          this.timer = null;
-          return Promise.reject(ERROR_NO_RETRIES_LEFT);
-        }
-        this.ui.error(ERROR_INVALID_VERIFICATION_CODE);
-        this.verifying = false;
-        if (this.queuedTimeout) {
-          this.onVerificationCodeTimeout();
-        }
-        return this._doVerification();
-      }
-    );
-  },
-
-  onVerificationCodeTimeout: function() {
-    // It is possible that we get the timeout when we are checking a
-    // verification code with the server. In that case, we queue the
-    // timeout to be triggered after we receive the reply from the server
-    // if needed.
-    if (this.verifying) {
-      this.queuedTimeout = true;
-      return;
-    }
-
-    // When the verification process times out we do a clean up, reject
-    // the corresponding promise and notify the UI about the timeout.
-    if (this.verificationCodeDeferred) {
-      this.verificationCodeDeferred.reject(ERROR_VERIFICATION_CODE_TIMEOUT);
-    }
-    this.ui.error(ERROR_VERIFICATION_CODE_TIMEOUT);
-  },
-
-  register: function() {
-    return this.client.register();
-  },
-
-  verifyCode: function(aVerificationCode) {
-    return this.client.verifyCode(this.sessionToken, aVerificationCode);
-  },
-
-  unregister: function() {
-    return this.client.unregister(this.sessionToken);
-  },
-
-  cleanup: function(aUnregister = false) {
-    log.debug("Verification flow cleanup");
-
-    this.queuedTimeout = false;
-    this.retries = VERIFICATIONCODE_RETRIES;
-
-    if (this.timer) {
-      this.timer.cancel();
-      this.timer = null;
-    }
-
-    if (aUnregister) {
-      this.unregister().
-      then(
-        () => {
-          this.sessionToken = null;
-        }
-      );
-    }
-
-    if (this.cleanupStrategy) {
-      this.cleanupStrategy();
-    }
-  }
-};
diff --git a/services/mobileid/interfaces/moz.build b/services/mobileid/interfaces/moz.build
deleted file mode 100644
--- a/services/mobileid/interfaces/moz.build
+++ /dev/null
@@ -1,11 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-XPIDL_SOURCES += [
-    'nsIMobileIdentityUIGlue.idl'
-]
-
-XPIDL_MODULE = 'services_mobileidentity'
diff --git a/services/mobileid/interfaces/nsIMobileIdentityUIGlue.idl b/services/mobileid/interfaces/nsIMobileIdentityUIGlue.idl
deleted file mode 100644
--- a/services/mobileid/interfaces/nsIMobileIdentityUIGlue.idl
+++ /dev/null
@@ -1,77 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this file,
- * You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-
-[scriptable, uuid(6c4c5758-e041-4e0d-98da-67bb552f8018)]
-interface nsIMobileIdentityUIGlue : nsISupports
-{
-  /**
-  * Request the creation of a Mobile ID UI flow.
-  *
-  * The permission prompt starts the verification flow asking the user
-  * for permission to share her phone number and allowing her to choose
-  * an already known phone number, a SIM which phone number is unknown
-  * (even in a multi-SIM scenario) or an external phone number.
-  * Selecting a phone number implies giving permission to share it with the
-  * API caller, so the UI should be clear about this.
-  *
-  * @manifestURL manifest URL of the mobile ID requester.
-  * @iccInfo array of objects containing the information about the
-  *          SIM cards available in the device and that can be used for the
-  *          phone number verification and share process.
-  *
-  * Returns a Promise. An instance of nsIMobileIdentityUIGluePromptResult will
-  * be returned as result of the Promise or a single string containing an error
-  * in case of rejection.
-  */
-  jsval startFlow(in DOMString manifestURL, in jsval iccInfo);
-
-  /**
-   * Will prompt the user to enter a code used to verify a phone number.
-   * This will only be called if an external phone number is selected in
-   * startFlow().
-   *
-   * @retries number of retries left to validate a verification code.
-   * @timeout the verification code expires after the timeout fires. This is
-   *          the total life time of the verification code.
-   * @timeLeft we might call verificationCodePrompt more than once for the
-   *           same verification flow (i.e. when the verification code entered
-   *           by the user is incorrect) so we give to the UI the amount of
-   *           time left before the verification code expires.
-   *
-   * Returns a Promise. The value of the resolved promise will be the
-   * verification code introduced through the UI or an error in case of
-   * rejection of the promise.
-   */
-  jsval verificationCodePrompt(in short retries,
-                               in long timeout,
-                               in long timeLeft);
-
-  /**
-   * Notify the UI about the start of the verification process.
-   */
-  void verify();
-
-  /**
-   * Notify the UI about an error in the verification process.
-   */
-  void error(in DOMString error);
-
-  /**
-   * Notify the UI about the succesful phone number verification.
-   */
-  void verified(in DOMString verifiedPhoneNumber);
-
-  /**
-   * Callback to be called when the user cancels the verification flow via UI.
-   */
-  attribute jsval oncancel;
-
-  /**
-   * Callback to be called when the user requests a resend of a verification
-   * code.
-   */
-  attribute jsval onresendcode;
-};
diff --git a/services/mobileid/moz.build b/services/mobileid/moz.build
deleted file mode 100644
--- a/services/mobileid/moz.build
+++ /dev/null
@@ -1,21 +0,0 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-DIRS += ['interfaces']
-
-XPCSHELL_TESTS_MANIFESTS += ['tests/xpcshell/xpcshell.ini']
-
-EXTRA_JS_MODULES += [
-    'MobileIdentityClient.jsm',
-    'MobileIdentityCommon.jsm',
-    'MobileIdentityCredentialsStore.jsm',
-    'MobileIdentityManager.jsm',
-    'MobileIdentitySmsMoMtVerificationFlow.jsm',
-    'MobileIdentitySmsMtVerificationFlow.jsm',
-    'MobileIdentitySmsVerificationFlow.jsm',
-    'MobileIdentityUIGlueCommon.jsm',
-    'MobileIdentityVerificationFlow.jsm'
-]
diff --git a/services/mobileid/tests/xpcshell/head.js b/services/mobileid/tests/xpcshell/head.js
deleted file mode 100644
--- a/services/mobileid/tests/xpcshell/head.js
+++ /dev/null
@@ -1,439 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-var {classes: Cc, interfaces: Ci, results: Cr, utils: Cu} = Components;
-
-var Cm = Components.manager;
-
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-Cu.import("resource://gre/modules/Services.jsm");
-
-(function initMobileIdTestingInfrastructure() {
-  do_get_profile();
-
-  const PREF_FORCE_HTTPS = "services.mobileid.forcehttps";
-  Services.prefs.setBoolPref(PREF_FORCE_HTTPS, false);
-  Services.prefs.setCharPref("services.mobileid.loglevel", "Debug");
-  Services.prefs.setCharPref("services.mobileid.server.uri",
-                             "https://dummyurl.com");
-}).call(this);
-
-const DEBUG = false;
-
-const GET_ASSERTION_IPC_MSG = "MobileId:GetAssertion";
-const GET_ASSERTION_RETURN_OK = "MobileId:GetAssertion:Return:OK";
-const GET_ASSERTION_RETURN_KO = "MobileId:GetAssertion:Return:KO";
-
-// === Globals ===
-
-const ORIGIN = "app://afakeorigin";
-const APP_ID = 1;
-const PRINCIPAL = {
-  origin: ORIGIN,
-  appId: APP_ID
-};
-const PHONE_NUMBER = "+34666555444";
-const ANOTHER_PHONE_NUMBER = "+44123123123";
-const VERIFICATION_CODE = "123456";
-const SESSION_TOKEN = "aSessionToken";
-const ICC_ID = "aIccId";
-const ANOTHER_ICC_ID = "anotherIccId";
-const MNC = "aMnc";
-const ANOTHER_MNC = "anotherMnc";
-const MCC = "aMcc";
-const ANOTHER_MCC = "anotherMcc";
-const OPERATOR = "aOperator";
-const ANOTHER_OPERATOR = "anotherOperator";
-const ICC_INFO = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIGsmIccInfo,
-                                         Ci.nsIIccInfo]),
-  iccType: "usim",
-  iccid: ICC_ID,
-  mcc: MCC,
-  mnc: MNC,
-  msisdn: PHONE_NUMBER,
-  operator: OPERATOR
-};
-const ANOTHER_ICC_INFO = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIGsmIccInfo,
-                                         Ci.nsIIccInfo]),
-  iccType: "usim",
-  iccid: ANOTHER_ICC_ID,
-  mcc: ANOTHER_MCC,
-  mnc: ANOTHER_MNC,
-  msisdn: ANOTHER_PHONE_NUMBER,
-  operator: ANOTHER_OPERATOR
-};
-const INVALID_ICC_INFO = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIGsmIccInfo,
-                                         Ci.nsIIccInfo]),
-  iccType: "usim",
-  iccid: null,
-  mcc: "",
-  mnc: "",
-  msisdn: "",
-  operator: ""
-};
-const RADIO_INTERFACE = {
-  voice: {
-    network: {
-      shortName: OPERATOR
-    },
-    roaming: false
-  },
-  data: {
-    network: {
-      shortName: OPERATOR
-    }
-  }
-};
-const ANOTHER_RADIO_INTERFACE = {
-  voice: {
-    network: {
-      shortName: ANOTHER_OPERATOR
-    },
-    roaming: false
-  },
-  data: {
-    network: {
-      shortName: ANOTHER_OPERATOR
-    }
-  }
-};
-
-const INVALID_RADIO_INTERFACE = {
-  voice: {
-    network: {
-      shortName: ""
-    },
-    roaming: undefined
-  },
-  data: {
-    network: {
-      shortName: ""
-    }
-  }
-};
-
-const CERTIFICATE = "eyJhbGciOiJEUzI1NiJ9.eyJsYXN0QXV0aEF0IjoxNDA0NDY5NzkyODc3LCJ2ZXJpZmllZE1TSVNETiI6IiszMTYxNzgxNTc1OCIsInB1YmxpYy1rZXkiOnsiYWxnb3JpdGhtIjoiRFMiLCJ5IjoiNGE5YzkzNDY3MWZhNzQ3YmM2ZjMyNjE0YTg1MzUyZjY5NDcwMDdhNTRkMDAxMDY4OWU5ZjJjZjc0ZGUwYTEwZTRlYjlmNDk1ZGFmZTA0NGVjZmVlNDlkN2YwOGU4ODQyMDJiOTE5OGRhNWZhZWE5MGUzZjRmNzE1YzZjNGY4Yjc3MGYxZTU4YWZhNDM0NzVhYmFiN2VlZGE1MmUyNjk2YzFmNTljNzMzYjFlYzBhNGNkOTM1YWIxYzkyNzAxYjNiYTA5ZDRhM2E2MzNjNTJmZjE2NGYxMWY3OTg1YzlmZjY3ZThmZDFlYzA2NDU3MTdkMjBiNDE4YmM5M2YzYzVkNCIsInAiOiJmZjYwMDQ4M2RiNmFiZmM1YjQ1ZWFiNzg1OTRiMzUzM2Q1NTBkOWYxYmYyYTk5MmE3YThkYWE2ZGMzNGY4MDQ1YWQ0ZTZlMGM0MjlkMzM0ZWVlYWFlZmQ3ZTIzZDQ4MTBiZTAwZTRjYzE0OTJjYmEzMjViYTgxZmYyZDVhNWIzMDVhOGQxN2ViM2JmNGEwNmEzNDlkMzkyZTAwZDMyOTc0NGE1MTc5MzgwMzQ0ZTgyYTE4YzQ3OTMzNDM4Zjg5MWUyMmFlZWY4MTJkNjljOGY3NWUzMjZjYjcwZWEwMDBjM2Y3NzZkZmRiZDYwNDYzOGMyZWY3MTdmYzI2ZDAyZTE3IiwicSI6ImUyMWUwNGY5MTFkMWVkNzk5MTAwOGVjYWFiM2JmNzc1OTg0MzA5YzMiLCJnIjoiYzUyYTRhMGZmM2I3ZTYxZmRmMTg2N2NlODQxMzgzNjlhNjE1NGY0YWZhOTI5NjZlM2M4MjdlMjVjZmE2Y2Y1MDhiOTBlNWRlNDE5ZTEzMzdlMDdhMmU5ZTJhM2NkNWRlYTcwNGQxNzVmOGViZjZhZjM5N2Q2OWUxMTBiOTZhZmIxN2M3YTAzMjU5MzI5ZTQ4MjliMGQwM2JiYzc4OTZiMTViNGFkZTUzZTEzMDg1OGNjMzRkOTYyNjlhYTg5MDQxZjQwOTEzNmM3MjQyYTM4ODk1YzlkNWJjY2FkNGYzODlhZjFkN2E0YmQxMzk4YmQwNzJkZmZhODk2MjMzMzk3YSJ9LCJwcmluY2lwYWwiOiIwMzgxOTgyYS0xZTgzLTI1NjYtNjgzZS05MDRmNDA0NGM1MGRAbXNpc2RuLWRldi5zdGFnZS5tb3phd3MubmV0IiwiaWF0IjoxNDA0NDY5NzgyODc3LCJleHAiOjE0MDQ0OTEzOTI4NzcsImlzcyI6Im1zaXNkbi1kZXYuc3RhZ2UubW96YXdzLm5ldCJ9."
-
-// === Helpers ===
-
-function addPermission(aAction) {
-  let uri = Cc["@mozilla.org/network/io-service;1"]
-              .getService(Ci.nsIIOService)
-              .newURI(ORIGIN, null, null);
-  let attrs = {appId: APP_ID};
-  let _principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
-                     .getService(Ci.nsIScriptSecurityManager)
-                     .createCodebasePrincipal(uri, attrs);
-  let pm = Cc["@mozilla.org/permissionmanager;1"]
-             .getService(Ci.nsIPermissionManager);
-  pm.addFromPrincipal(_principal, MOBILEID_PERM, aAction);
-}
-
-function removePermission() {
-  let uri = Cc["@mozilla.org/network/io-service;1"]
-              .getService(Ci.nsIIOService)
-              .newURI(ORIGIN, null, null);
-  let attrs = {appId: APP_ID};
-  let _principal = Cc["@mozilla.org/scriptsecuritymanager;1"]
-                     .getService(Ci.nsIScriptSecurityManager)
-                     .createCodebasePrincipal(uri, attrs);
-  let pm = Cc["@mozilla.org/permissionmanager;1"]
-             .getService(Ci.nsIPermissionManager);
-  pm.removeFromPrincipal(_principal, MOBILEID_PERM);
-}
-
-// === Mocks ===
-
-var Mock = function(aOptions) {
-  if (!aOptions) {
-    aOptions = {};
-  }
-  this._options = aOptions;
-  this._spied = {};
-};
-
-Mock.prototype = {
-  _: function(aMethod) {
-    DEBUG && do_print("_ " + aMethod + JSON.stringify(this._spied));
-    let self = this;
-    return {
-      callsLength: function(aNumberOfCalls) {
-        if (aNumberOfCalls == 0) {
-          do_check_eq(self._spied[aMethod], undefined);
-          return;
-        }
-        do_check_eq(self._spied[aMethod].length, aNumberOfCalls);
-      },
-      call: function(aCallNumber) {
-        return {
-          arg: function(aArgNumber, aValue) {
-            let _arg = self._spied[aMethod][aCallNumber - 1][aArgNumber - 1];
-            if (Array.isArray(aValue)) {
-              do_check_eq(_arg.length, aValue.length)
-              for (let i = 0; i < _arg.length; i++) {
-                do_check_eq(_arg[i], aValue[i]);
-              }
-              return;
-            }
-
-            if (typeof aValue === 'object') {
-              do_check_eq(JSON.stringify(_arg), JSON.stringify(aValue));
-              return;
-            }
-
-            do_check_eq(_arg, aValue);
-          }
-        }
-      }
-    }
-  },
-
-  _spy: function(aMethod, aArgs) {
-    DEBUG && do_print(aMethod + " - " + JSON.stringify(aArgs));
-    if (!this._spied[aMethod]) {
-      this._spied[aMethod] = [];
-    }
-    this._spied[aMethod].push(aArgs);
-  },
-
-  getSpiedCalls: function(aMethod) {
-    return this._spied[aMethod];
-  }
-};
-
-// UI Glue mock up.
-var MockUi = function(aOptions) {
-  Mock.call(this, aOptions);
-};
-
-MockUi.prototype = {
-  __proto__: Mock.prototype,
-
-  _startFlowResult: {
-    phoneNumber: PHONE_NUMBER,
-    mcc: MNC
-  },
-
-  _verifyCodePromptResult: {
-    verificationCode: VERIFICATION_CODE
-  },
-
-  startFlow: function() {
-    this._spy("startFlow", arguments);
-    return Promise.resolve(this._options.startFlowResult ||
-                           this._startFlowResult);
-  },
-
-  verificationCodePrompt: function() {
-    this._spy("verifyCodePrompt", arguments);
-    return Promise.resolve(this._options.verificationCodePromptResult ||
-                           this._verifyCodePromptResult);
-  },
-
-  verify: function() {
-    this._spy("verify", arguments);
-  },
-
-  error: function() {
-    this._spy("error", arguments);
-  },
-
-  verified: function() {
-    this._spy("verified", arguments);
-  },
-
-  set oncancel(aCallback) {
-  },
-
-  set onresendcode(aCallback) {
-  }
-};
-
-// Credentials store mock up.
-var MockCredStore = function(aOptions) {
-  Mock.call(this, aOptions);
-};
-
-MockCredStore.prototype = {
-  __proto__: Mock.prototype,
-
-  _getByOriginResult: null,
-
-  _getByMsisdnResult: null,
-
-  _getByIccIdResult: null,
-
-  getByOrigin: function() {
-    this._spy("getByOrigin", arguments);
-    let result = this._getByOriginResult;
-    if (this._options.getByOriginResult) {
-      if (Array.isArray(this._options.getByOriginResult)) {
-        result = this._options.getByOriginResult.length ?
-                 this._options.getByOriginResult.shift() : null;
-      } else {
-        result = this._options.getByOriginResult;
-      }
-    }
-    return Promise.resolve(result);
-  },
-
-  getByMsisdn: function() {
-    this._spy("getByMsisdn", arguments);
-    return Promise.resolve(this._options.getByMsisdnResult ||
-                           this._getByMsisdnResult);
-  },
-
-  getByIccId: function(){
-    this._spy("getByIccId", arguments);
-    return Promise.resolve(this._options.getByIccIdResult ||
-                           this._getByIccIdResult);
-  },
-
-  add: function() {
-    this._spy("add", arguments);
-    return Promise.resolve();
-  },
-
-  setDeviceIccIds: function() {
-    this._spy("setDeviceIccIds", arguments);
-    return Promise.resolve();
-  },
-
-  removeOrigin: function() {
-    this._spy("removeOrigin", arguments);
-    return Promise.resolve();
-  },
-
-  delete: function() {
-    this._spy("delete", arguments);
-    return Promise.resolve();
-  }
-};
-
-// Client mock up.
-var MockClient = function(aOptions) {
-  Mock.call(this, aOptions);
-};
-
-MockClient.prototype = {
-
-  __proto__: Mock.prototype,
-
-  _discoverResult: {
-    verificationMethods: ["sms/mt"],
-    verificationDetails: {
-      "sms/mt": {
-        mtSender: "123",
-        url: "https://msisdn.accounts.firefox.com/v1/msisdn/sms/mt/verify"
-      }
-    }
-  },
-
-  _registerResult: {
-    msisdnSessionToken: SESSION_TOKEN
-  },
-
-  _smsMtVerifyResult: {},
-
-  _verifyCodeResult: {
-    msisdn: PHONE_NUMBER
-  },
-
-  _signResult: {
-    cert: CERTIFICATE
-  },
-
-  hawk: {
-    now: function() {
-      return Date.now();
-    }
-  },
-
-  discover: function() {
-    this._spy("discover", arguments);
-    return Promise.resolve(this._options.discoverResult ||
-                           this._discoverResult);
-  },
-
-  register: function() {
-    this._spy("register", arguments);
-    return Promise.resolve(this._options.registerResult ||
-                           this._registerResult);
-  },
-
-  smsMtVerify: function() {
-    this._spy("smsMtVerify", arguments);
-    return Promise.resolve(this._options.smsMtVerifyResult ||
-                           this._smsMtVerifyResult);
-  },
-
-  verifyCode: function() {
-    this._spy("verifyCode", arguments);
-    if (this._options.verifyCodeError) {
-      let error = Array.isArray(this._options.verifyCodeError) ?
-                  this._options.verifyCodeError.shift() :
-                  this._options.verifyCodeError;
-      if (!this._options.verifyCodeError.length) {
-        this._options.verifyCodeError = null;
-      }
-      return Promise.reject(error);
-    }
-    return Promise.resolve(this._options.verifyCodeResult ||
-                           this._verifyCodeResult);
-  },
-
-  sign: function() {
-    this._spy("sign", arguments);
-    if (this._options.signError) {
-      let error = Array.isArray(this._options.signError) ?
-                  this._options.signError.shift() :
-                  this._options.signError;
-      return Promise.reject(error);
-    }
-    return Promise.resolve(this._options.signResult || this._signResult);
-  }
-};
-
-// Override MobileIdentityUIGlue.
-const kMobileIdentityUIGlueUUID = "{05df0566-ca8a-4ec7-bc76-78626ebfbe9a}";
-const kMobileIdentityUIGlueContractID =
-  "@mozilla.org/services/mobileid-ui-glue;1";
-
-// Save original factory.
-/*const kMobileIdentityUIGlueFactory =
-  Cm.getClassObject(Cc[kMobileIdentityUIGlueContractID], Ci.nsIFactory);*/
-
-var fakeMobileIdentityUIGlueFactory = {
-  createInstance: function(aOuter, aIid) {
-    return MobileIdentityUIGlue.QueryInterface(aIid);
-  }
-};
-
-// MobileIdentityUIGlue fake component.
-var MobileIdentityUIGlue = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIMobileIdentityUIGlue]),
-
-};
-
-(function registerFakeMobileIdentityUIGlue() {
-  Cm.QueryInterface(Ci.nsIComponentRegistrar)
-    .registerFactory(Components.ID(kMobileIdentityUIGlueUUID),
-                     "MobileIdentityUIGlue",
-                     kMobileIdentityUIGlueContractID,
-                     fakeMobileIdentityUIGlueFactory);
-})();
-
-// The tests rely on having an app registered. Otherwise, it will throw.
-// Override XULAppInfo.
-Cu.import("resource://testing-common/AppInfo.jsm", this);
-updateAppInfo({
-  name: "MobileIdTest",
-  ID: "{230de50e-4cd1-11dc-8314-0800200b9a66}",
-  version: "1",
-  platformVersion: "",
-});
diff --git a/services/mobileid/tests/xpcshell/test_mobileid_client.js b/services/mobileid/tests/xpcshell/test_mobileid_client.js
deleted file mode 100644
--- a/services/mobileid/tests/xpcshell/test_mobileid_client.js
+++ /dev/null
@@ -1,247 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-Cu.import("resource://services-common/utils.js");
-Cu.import("resource://testing-common/httpd.js");
-Cu.import("resource://gre/modules/MobileIdentityClient.jsm");
-
-/* Setup */
-
-var client;
-var server = new HttpServer();
-
-function httpd_setup(handlers, port = -1) {
-  for (let path in handlers) {
-    server.registerPathHandler(path, handlers[path]);
-  }
-
-  try {
-    server.start(port);
-  } catch (ex) {
-    dump("ERROR starting server on port " + port + ".  Already a process listening?");
-    do_throw(ex);
-  }
-
-  // Set the base URI for convenience.
-  let i = server.identity;
-  server.baseURI = i.primaryScheme + "://" + i.primaryHost + ":" + i.primaryPort;
-
-  return server;
-}
-
-function writeResp(response, msg) {
-  if (typeof msg === "object") {
-    msg = JSON.stringify(msg);
-  }
-  response.bodyOutputStream.write(msg, msg.length);
-}
-
-function getBody(request) {
-  let body = CommonUtils.readBytesFromInputStream(request.bodyInputStream);
-  return JSON.parse(body);
-}
-
-function run_test() {
-  httpd_setup({
-    "/discover": function(request, response) {
-      let body = getBody(request);
-      response.setStatusLine(null, 200, "Ok");
-      writeResp(response, {
-        msisdn: body.msisdn,
-        mcc: body.mcc,
-        mnc: body.mnc,
-        roaming: body.roaming
-      });
-    },
-    "/register": function(request, response) {
-      response.setStatusLine(null, 204);
-    },
-    "/sms/mt/verify": function(request, response) {
-      let body = getBody(request);
-      response.setStatusLine(null, 200, "Ok");
-      writeResp(response, {
-        msisdn: body.msisdn,
-        mcc: body.mcc,
-        mnc: body.mnc,
-        shortVerificationCode: body.shortVerificationCode
-      });
-    },
-    "/sms/verify_code": function(request, response) {
-      let body = getBody(request);
-      response.setStatusLine(null, 200, "Ok");
-      writeResp(response, {
-        code: body.code
-      });
-    },
-    "/certificate/sign": function(request, response) {
-      let body = getBody(request);
-      response.setStatusLine(null, 200, "Ok");
-      writeResp(response, {
-        duration: body.duration,
-        publicKey: body.publicKey
-      });
-    },
-    "/unregister": function(request, response) {
-      response.setStatusLine(null, 500);
-    }
-  });
-
-
-  client = new MobileIdentityClient(server.baseURI);
-
-  run_next_test();
-}
-
-/* Tests */
-
-add_test(function test_discover() {
-  do_print("= Test /discover =");
-
-  do_test_pending();
-
-  let msisdn = "msisdn";
-  let mcc = "mcc";
-  let mnc = "mnc";
-  let roaming = true;
-
-  client.discover(msisdn, mcc, mnc, roaming).then(
-    (response) => {
-      // The request should succeed and a response should be given.
-      // We simply check that the parameters given with the request are
-      // successfully progressed to the server.
-      do_check_eq(response.msisdn, msisdn);
-      do_check_eq(response.mcc, mcc);
-      do_check_eq(response.mnc, mnc);
-      do_check_eq(response.roaming, roaming);
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_throw("Should not throw error when handling a 200 response");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
-
-add_test(function test_sms_mt_verify() {
-  do_print("= Test /sms/mt/verify =");
-
-  do_test_pending();
-
-  let msisdn = "msisdn";
-  let mcc = "mcc";
-  let mnc = "mnc";
-  let shortCode = true;
-
-  client.smsMtVerify("aToken", msisdn, mcc, mnc, shortCode).then(
-    (response) => {
-      // The request should succeed and a response should be given.
-      // We simply check that the parameters given with the request are
-      // successfully progressed to the server.
-      do_check_eq(response.msisdn, msisdn);
-      do_check_eq(response.mcc, mcc);
-      do_check_eq(response.mnc, mnc);
-      do_check_eq(response.shortVerificationCode, shortCode);
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_throw("Should not throw error when handling a 200 response");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
-
-add_test(function test_verify_code() {
-  do_print("= Test /sms/verify_code =");
-
-  do_test_pending();
-
-  let code = "code";
-
-  client.verifyCode("aToken", code).then(
-    (response) => {
-      // The request should succeed and a response should be given.
-      // We simply check that the parameters given with the request are
-      // successfully progressed to the server.
-      do_check_eq(response.code, code);
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_throw("Should not throw error when handling a 200 response");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
-
-add_test(function test_certificate_sign() {
-  do_print("= Test /certificate/sign =");
-
-  do_test_pending();
-
-  let duration = "duration";
-  let publicKey = "publicKey";
-
-  client.sign("aToken", duration, publicKey).then(
-    (response) => {
-      // The request should succeed and a response should be given.
-      // We simply check that the parameters given with the request are
-      // successfully progressed to the server.
-      do_check_eq(response.duration, duration);
-      do_check_eq(response.publicKey, publicKey);
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_throw("Should not throw error when handling a 200 response");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
-
-add_test(function test_204_response() {
-  do_print("= Test /register and 204 No Content response =");
-
-  do_test_pending();
-
-  client.register().then(
-    (response) => {
-      // The request should succeed but no response body should be returned.
-      do_check_eq(response, undefined);
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_throw("Should not throw error when handling a 204 response");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
-
-add_test(function test_500_response() {
-  do_print("= Test /unregister and 500 response =");
-
-  do_test_pending();
-
-  client.unregister("aToken").then(
-    (response) => {
-      // The request shouldn't succeed.
-      do_throw("We are supposed to get an error");
-      do_test_finished();
-      run_next_test();
-    },
-    (error) => {
-      do_check_eq(error, "UNKNOWN");
-      do_test_finished();
-      run_next_test();
-    }
-  );
-});
diff --git a/services/mobileid/tests/xpcshell/test_mobileid_manager.js b/services/mobileid/tests/xpcshell/test_mobileid_manager.js
deleted file mode 100644
--- a/services/mobileid/tests/xpcshell/test_mobileid_manager.js
+++ /dev/null
@@ -1,1227 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-Cu.import("resource://gre/modules/Promise.jsm");
-Cu.import("resource://gre/modules/MobileIdentityManager.jsm");
-Cu.import("resource://gre/modules/MobileIdentityCommon.jsm");
-
-// Save original credential store instance.
-const kMobileIdentityCredStore = MobileIdentityManager.credStore;
-// Save original client instance.
-const kMobileIdentityClient = MobileIdentityManager.client;
-
-// === Global cleanup ===
-function cleanup() {
-  MobileIdentityManager.credStore = kMobileIdentityCredStore;
-  MobileIdentityManager.client = kMobileIdentityClient;
-  MobileIdentityManager.ui = null;
-  MobileIdentityManager._iccInfo = [];
-  removePermission(ORIGIN);
-}
-
-// Unregister mocks and restore original code.
-do_register_cleanup(cleanup);
-// === Tests ===
-function run_test() {
-  run_next_test();
-}
-
-add_test(function() {
-  do_print("= Initial state =");
-  do_check_neq(MobileIdentityManager, undefined);
-  run_next_test();
-});
-
-add_test(function() {
-  do_print("= No credentials - No ICC - User MSISDN - External - OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore();
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-  MobileIdentityManager._iccInfo = [];
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, PHONE_NUMBER);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, SESSION_TOKEN);
-      credStore._("add").call(1).arg(5, []);
-
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("startFlow").call(1).arg(1, "");
-      ui._("startFlow").call(1).arg(2, []);
-      ui._("verifyCodePrompt").callsLength(1);
-      ui._("verifyCodePrompt").call(1).arg(1, 3);
-      ui._("verify").callsLength(1);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("discover").call(1).arg(1, PHONE_NUMBER);
-      client._("register").callsLength(1);
-      client._("smsMtVerify").callsLength(1);
-      client._("smsMtVerify").call(1).arg(1, SESSION_TOKEN);
-      client._("smsMtVerify").call(1).arg(2, PHONE_NUMBER);
-      client._("smsMtVerify").call(1).arg(3, MNC);
-      client._("smsMtVerify").call(1).arg(4, undefined);
-      client._("smsMtVerify").call(1).arg(5, true);
-      client._("verifyCode").callsLength(1);
-      client._("verifyCode").call(1).arg(1, SESSION_TOKEN);
-      client._("verifyCode").call(1).arg(2, {
-        verificationCode: VERIFICATION_CODE
-      });
-      client._("sign").callsLength(1);
-      client._("sign").call(1).arg(1, SESSION_TOKEN);
-      client._("sign").call(1).arg(2, CERTIFICATE_LIFETIME);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= No credentials - No icc - User MSISDN - External - KO -" +
-           " ERROR_INTERNAL_CANNOT_VERIFY_SELECTION =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore();
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient({
-    discoverResult: {
-      verificationMethods: ["other"],
-      verificationDetails: {
-        "other": {}
-      }
-    },
-    registerResult: {
-      msisdnSessionToken: _sessionToken
-    }
-  });
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_KO);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-      do_check_eq(aData.error, ERROR_INTERNAL_CANNOT_VERIFY_SELECTION);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, PHONE_NUMBER);
-      credStore._("add").callsLength(0);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("startFlow").call(1).arg(1, "");
-      ui._("startFlow").call(1).arg(2, []);
-      ui._("verifyCodePrompt").callsLength(0);
-      ui._("verify").callsLength(0);
-      ui._("error").callsLength(1);
-      ui._("error").call(1).arg(1, ERROR_INTERNAL_CANNOT_VERIFY_SELECTION);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("discover").call(1).arg(1, PHONE_NUMBER);
-      client._("register").callsLength(0);
-      client._("smsMtVerify").callsLength(0);
-      client._("verifyCode").callsLength(0);
-      client._("sign").callsLength(0);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= No credentials - No icc - User MSISDN - External - KO -" +
-           " INTERNAL_INVALID_PROMPT_RESULT =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let ui = new MockUi({
-    startFlowResult: {}
-  });
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore();
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_KO);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-      do_check_eq(aData.error, ERROR_INTERNAL_INVALID_PROMPT_RESULT);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(0);
-      credStore._("add").callsLength(0);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("startFlow").call(1).arg(1, "");
-      ui._("startFlow").call(1).arg(2, []);
-      ui._("verifyCodePrompt").callsLength(0);
-      ui._("verify").callsLength(0);
-      ui._("error").callsLength(1);
-      ui._("error").call(1).arg(1, ERROR_INTERNAL_INVALID_PROMPT_RESULT);
-
-      // MockClient.
-      client._("discover").callsLength(0);
-      client._("register").callsLength(0);
-      client._("smsMtVerify").callsLength(0);
-      client._("verifyCode").callsLength(0);
-      client._("sign").callsLength(0);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= No credentials - No icc - User MSISDN - External - KO -" +
-           " ERROR_INVALID_ASSERTION =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore();
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient({
-    signResult: {
-      cert: "aInvalidCert"
-    },
-    registerResult: {
-      msisdnSessionToken: _sessionToken
-    }
-  });
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_KO);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-      do_check_eq(aData.error, ERROR_INVALID_ASSERTION);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, PHONE_NUMBER);
-      credStore._("add").callsLength(1);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("startFlow").call(1).arg(1, "");
-      ui._("startFlow").call(1).arg(2, []);
-      ui._("verifyCodePrompt").callsLength(1);
-      ui._("verifyCodePrompt").call(1).arg(1, 3);
-      ui._("verify").callsLength(1);
-      ui._("error").callsLength(1);
-      ui._("error").call(1).arg(1, ERROR_INVALID_ASSERTION);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("discover").call(1).arg(1, PHONE_NUMBER);
-      client._("register").callsLength(1);
-      client._("smsMtVerify").callsLength(1);
-      client._("smsMtVerify").call(1).arg(1, _sessionToken);
-      client._("smsMtVerify").call(1).arg(2, PHONE_NUMBER);
-      client._("smsMtVerify").call(1).arg(3, MNC);
-      client._("smsMtVerify").call(1).arg(4, undefined);
-      client._("smsMtVerify").call(1).arg(5, true);
-      client._("verifyCode").callsLength(1);
-      client._("verifyCode").call(1).arg(1, _sessionToken);
-      client._("verifyCode").call(1).arg(2, {
-        verificationCode: VERIFICATION_CODE
-      });
-      client._("sign").callsLength(1);
-      client._("sign").call(1).arg(1, _sessionToken);
-      client._("sign").call(1).arg(2, CERTIFICATE_LIFETIME);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - Permission - OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: {
-      sessionToken: SESSION_TOKEN,
-      msisdn: PHONE_NUMBER,
-      origin: ORIGIN,
-      deviceIccIds: null
-    }
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-
-      removePermission(ORIGIN);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - Prompt permission - OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: {
-      sessionToken: SESSION_TOKEN,
-      msisdn: PHONE_NUMBER,
-      origin: ORIGIN,
-      deviceIccIds: null
-    }
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-
-      removePermission(ORIGIN);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.PROMPT_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - Permission denied - KO result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: {
-      sessionToken: SESSION_TOKEN,
-      msisdn: PHONE_NUMBER,
-      origin: ORIGIN,
-      deviceIccIds: null
-    }
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_KO);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-      do_check_eq(aData.error, ERROR_PERMISSION_DENIED);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(0);
-
-      // MockUI.
-      ui._("startFlow").callsLength(0);
-      ui._("error").callsLength(0);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  removePermission(ORIGIN);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - SIM change/Same choice - " +
-           "OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let ui = new MockUi();
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: {
-      sessionToken: SESSION_TOKEN,
-      msisdn: PHONE_NUMBER,
-      origin: ORIGIN,
-      deviceIccIds: [ICC_ID]
-    }
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  MobileIdentityManager._iccInfo = [];
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, SESSION_TOKEN);
-      credStore._("add").call(1).arg(5, []);
-      credStore._("setDeviceIccIds").callsLength(1);
-      credStore._("setDeviceIccIds").call(1).arg(1, PHONE_NUMBER);
-      credStore._("setDeviceIccIds").call(1).arg(2, []);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("verifyCodePrompt").callsLength(0);
-      ui._("verify").callsLength(0);
-
-      // MockClient.
-      client._("discover").callsLength(0);
-      client._("register").callsLength(0);
-      client._("smsMtVerify").callsLength(0);
-      client._("verifyCode").callsLength(0);
-      client._("sign").callsLength(0);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - SIM change/Different choice - " +
-           "OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let existingCredentials = {
-    sessionToken: SESSION_TOKEN,
-    msisdn: PHONE_NUMBER,
-    origin: ORIGIN,
-    deviceIccIds: [ICC_ID]
-  };
-
-  let ui = new MockUi({
-    startFlowResult: {
-      phoneNumber: ANOTHER_PHONE_NUMBER
-    }
-  });
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: existingCredentials
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient({
-    verifyCodeResult: ANOTHER_PHONE_NUMBER,
-    registerResult: {
-      msisdnSessionToken: _sessionToken
-    }
-  });
-  MobileIdentityManager.client = client;
-
-  MobileIdentityManager._iccInfo = [];
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, ANOTHER_PHONE_NUMBER);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, ANOTHER_PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, _sessionToken);
-      credStore._("add").call(1).arg(5, []);
-      credStore._("setDeviceIccIds").callsLength(0);
-      credStore._("removeOrigin").callsLength(1);
-      credStore._("removeOrigin").call(1).arg(1, PHONE_NUMBER);
-      credStore._("removeOrigin").call(1).arg(2, ORIGIN);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("verifyCodePrompt").callsLength(1);
-      ui._("verify").callsLength(1);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("register").callsLength(1);
-      client._("smsMtVerify").callsLength(1);
-      client._("verifyCode").callsLength(1);
-      client._("sign").callsLength(1);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - forceSelection/same - " +
-           "OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let existingCredentials = {
-    sessionToken: _sessionToken,
-    msisdn: PHONE_NUMBER,
-    origin: ORIGIN,
-    deviceIccIds: []
-  };
-
-  let ui = new MockUi({
-    startFlowResult: {
-      phoneNumber: PHONE_NUMBER
-    }
-  });
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: existingCredentials
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(0);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, _sessionToken);
-      credStore._("add").call(1).arg(5, []);
-      credStore._("setDeviceIccIds").callsLength(1);
-      credStore._("removeOrigin").callsLength(0);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("verifyCodePrompt").callsLength(0);
-      ui._("verify").callsLength(0);
-
-      // MockClient.
-      client._("discover").callsLength(0);
-      client._("register").callsLength(0);
-      client._("smsMtVerify").callsLength(0);
-      client._("verifyCode").callsLength(0);
-      client._("sign").callsLength(1);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {
-        forceSelection: true
-      }
-    }
-  });
-});
-add_test(function() {
-  do_print("= Existing credentials - No Icc - forceSelection/different - " +
-           "OK result =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let existingCredentials = {
-    sessionToken: SESSION_TOKEN,
-    msisdn: PHONE_NUMBER,
-    origin: ORIGIN,
-    deviceIccIds: []
-  };
-
-  let ui = new MockUi({
-    startFlowResult: {
-      phoneNumber: ANOTHER_PHONE_NUMBER
-    }
-  });
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: existingCredentials
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient({
-    verifyCodeResult: ANOTHER_PHONE_NUMBER,
-    registerResult: {
-      msisdnSessionToken: _sessionToken
-    }
-  });
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(1);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, ANOTHER_PHONE_NUMBER);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, ANOTHER_PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, _sessionToken);
-      credStore._("add").call(1).arg(5, []);
-      credStore._("setDeviceIccIds").callsLength(0);
-      credStore._("removeOrigin").callsLength(1);
-      credStore._("removeOrigin").call(1).arg(1, PHONE_NUMBER);
-      credStore._("removeOrigin").call(1).arg(2, ORIGIN);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("verifyCodePrompt").callsLength(1);
-      ui._("verify").callsLength(1);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("register").callsLength(1);
-      client._("smsMtVerify").callsLength(1);
-      client._("verifyCode").callsLength(1);
-      client._("sign").callsLength(1);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {
-        forceSelection: true
-      }
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Existing credentials - No Icc - INVALID_AUTH_TOKEN - OK =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let existingCredentials = {
-    sessionToken: _sessionToken,
-    msisdn: PHONE_NUMBER,
-    origin: ORIGIN,
-    deviceIccIds: []
-  };
-
-  let ui = new MockUi({
-    startFlowResult: {
-      phoneNumber: PHONE_NUMBER
-    }
-  });
-  MobileIdentityManager.ui = ui;
-  let credStore = new MockCredStore({
-    getByOriginResult: [existingCredentials, null]
-  });
-  MobileIdentityManager.credStore = credStore;
-  let client = new MockClient({
-    signError: [ERROR_INVALID_AUTH_TOKEN],
-    verifyCodeResult: PHONE_NUMBER,
-    registerResult: {
-      msisdnSessionToken: SESSION_TOKEN
-    }
-  });
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_OK);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-
-      // Check spied calls.
-
-      // MockCredStore.
-      credStore._("getByOrigin").callsLength(2);
-      credStore._("getByOrigin").call(1).arg(1, ORIGIN);
-      credStore._("getByOrigin").call(2).arg(1, ORIGIN);
-      credStore._("getByMsisdn").callsLength(1);
-      credStore._("getByMsisdn").call(1).arg(1, PHONE_NUMBER);
-      credStore._("add").callsLength(1);
-      credStore._("add").call(1).arg(1, undefined);
-      credStore._("add").call(1).arg(2, PHONE_NUMBER);
-      credStore._("add").call(1).arg(3, ORIGIN);
-      credStore._("add").call(1).arg(4, SESSION_TOKEN);
-      credStore._("add").call(1).arg(5, []);
-      credStore._("setDeviceIccIds").callsLength(0);
-      credStore._("delete").callsLength(1);
-      credStore._("delete").call(1).arg(1, PHONE_NUMBER);
-
-      // MockUI.
-      ui._("startFlow").callsLength(1);
-      ui._("verifyCodePrompt").callsLength(1);
-      ui._("verify").callsLength(1);
-
-      // MockClient.
-      client._("discover").callsLength(1);
-      client._("register").callsLength(1);
-      client._("smsMtVerify").callsLength(1);
-      client._("verifyCode").callsLength(1);
-      client._("sign").callsLength(1);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= ICC info change =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  MobileIdentityManager._iccInfo = null;
-  MobileIdentityManager._iccIds = null;
-
-  MobileIdentityManager._ril = {
-    _interfaces: [RADIO_INTERFACE, ANOTHER_RADIO_INTERFACE],
-    get numRadioInterfaces() {
-      return this._interfaces.length;
-    },
-
-    getRadioInterface: function(aIndex) {
-      return this._interfaces[aIndex];
-    }
-  };
-
-  MobileIdentityManager._mobileConnectionService = {
-    _interfaces: [RADIO_INTERFACE, ANOTHER_RADIO_INTERFACE],
-    getItemByServiceId: function(aIndex) {
-      return this._interfaces[aIndex];
-    }
-  };
-
-  MobileIdentityManager._iccService = {
-    _listeners: [],
-    _iccInfos: [ICC_INFO, ANOTHER_ICC_INFO],
-    getIccByServiceId: function(aClientId) {
-      let self = this;
-      return {
-        get iccInfo() {
-          return self._iccInfos[aClientId];
-        },
-        registerListener: function(aIccListener) {
-          self._listeners.push(aIccListener);
-        },
-        unregisterListener: function() {
-          self._listeners.pop();
-        }
-      };
-    }
-  };
-
-  let ui = new MockUi();
-  ui.startFlow = function() {
-    // At this point we've already built the ICC cache.
-    let mockIccInfo = [ICC_INFO, ANOTHER_ICC_INFO];
-    for (let i = 0; i < mockIccInfo.length; i++) {
-      let mIdIccInfo = MobileIdentityManager._iccInfo[i];
-      do_check_eq(mockIccInfo[i].iccid, mIdIccInfo.iccId);
-      do_check_eq(mockIccInfo[i].mcc, mIdIccInfo.mcc);
-      do_check_eq(mockIccInfo[i].mnc, mIdIccInfo.mnc);
-      do_check_eq(mockIccInfo[i].msisdn, mIdIccInfo.msisdn);
-      do_check_eq(mockIccInfo[i].operator, mIdIccInfo.operator);
-    }
-
-    // We should have listeners for each valid icc.
-    do_check_eq(MobileIdentityManager._iccService._listeners.length, 2);
-
-    // We can mock an ICC change event at this point.
-    MobileIdentityManager._iccService._listeners[0].notifyIccInfoChanged();
-
-    // After the ICC change event the caches should be null.
-    do_check_null(MobileIdentityManager._iccInfo);
-    do_check_null(MobileIdentityManager._iccIds);
-
-    // And we should have unregistered all listeners for ICC change events.
-    do_check_eq(MobileIdentityManager._iccService._listeners.length, 0);
-
-    do_test_finished();
-    run_next_test();
-  };
-  MobileIdentityManager.ui = ui;
-
-  let credStore = new MockCredStore();
-  credStore.getByOrigin = function() {
-    // Initially the ICC caches should be null.
-    do_check_null(MobileIdentityManager._iccInfo);
-    do_check_null(MobileIdentityManager._iccIds);
-    return Promise.resolve(null);
-  };
-  MobileIdentityManager.credStore = credStore;
-
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function() {}
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Invalid ICC Info =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  MobileIdentityManager._iccInfo = null;
-  MobileIdentityManager._iccIds = null;
-
-  MobileIdentityManager._ril = {
-    _interfaces: [INVALID_RADIO_INTERFACE],
-    get numRadioInterfaces() {
-      return this._interfaces.length;
-    },
-
-    getRadioInterface: function(aIndex) {
-      return this._interfaces[aIndex];
-    }
-  };
-
-  MobileIdentityManager._mobileConnectionService = {
-    _interfaces: [INVALID_RADIO_INTERFACE],
-    getItemByServiceId: function(aIndex) {
-      return this._interfaces[aIndex];
-    }
-  };
-
-  MobileIdentityManager._iccService = {
-    _listeners: [],
-    _iccInfos: [INVALID_ICC_INFO],
-    getIccByServiceId: function(aClientId) {
-      let self = this;
-      return {
-        get iccInfo() {
-          return self._iccInfos[aClientId];
-        },
-        registerListener: function(aIccListener) {
-          self._listeners.push(aIccListener);
-        },
-        unregisterListener: function() {
-          self._listeners.pop();
-        }
-      };
-    }
-  };
-
-  let ui = new MockUi();
-  ui.startFlow = function() {
-    // At this point we've already built the ICC cache.
-    do_check_eq(MobileIdentityManager._iccInfo.length, 0);
-    do_check_eq(MobileIdentityManager._iccIds.length, 0);
-
-    // We should have listeners for each valid icc.
-    do_check_eq(MobileIdentityManager._iccService._listeners.length, 0);
-
-    do_test_finished();
-    run_next_test();
-  };
-  MobileIdentityManager.ui = ui;
-
-  let credStore = new MockCredStore();
-  credStore.getByOrigin = function() {
-    // Initially the ICC caches should be null.
-    do_check_null(MobileIdentityManager._iccInfo);
-    do_check_null(MobileIdentityManager._iccIds);
-    return Promise.resolve(null);
-  };
-  MobileIdentityManager.credStore = credStore;
-
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function() {}
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
-add_test(function() {
-  do_print("= Cancel verification flow =");
-
-  do_register_cleanup(cleanup);
-
-  do_test_pending();
-
-  let _sessionToken = Date.now();
-
-  let ui = new MockUi();
-  ui.verificationCodePrompt = function() {
-    MobileIdentityManager.onUICancel();
-  };
-  MobileIdentityManager.ui = ui;
-
-  let credStore = new MockCredStore();
-  MobileIdentityManager.credStore = credStore;
-
-  let client = new MockClient();
-  MobileIdentityManager.client = client;
-
-  let promiseId = Date.now();
-  let mm = {
-    sendAsyncMessage: function(aMsg, aData) {
-      do_print("sendAsyncMessage " + aMsg + " - " + JSON.stringify(aData));
-
-      // Check result.
-      do_check_eq(aMsg, GET_ASSERTION_RETURN_KO);
-      do_check_eq(typeof aData, "object");
-      do_check_eq(aData.promiseId, promiseId);
-      do_check_eq(aData.error, DIALOG_CLOSED_BY_USER);
-
-      do_test_finished();
-      run_next_test();
-    }
-  };
-
-  addPermission(Ci.nsIPermissionManager.ALLOW_ACTION);
-
-  MobileIdentityManager.receiveMessage({
-    name: GET_ASSERTION_IPC_MSG,
-    principal: PRINCIPAL,
-    target: mm,
-    json: {
-      promiseId: promiseId,
-      options: {}
-    }
-  });
-});
-
diff --git a/services/mobileid/tests/xpcshell/test_mobileid_verification_flow.js b/services/mobileid/tests/xpcshell/test_mobileid_verification_flow.js
deleted file mode 100644
--- a/services/mobileid/tests/xpcshell/test_mobileid_verification_flow.js
+++ /dev/null
@@ -1,42 +0,0 @@
-/* Any copyright is dedicated to the Public Domain.
- * http://creativecommons.org/publicdomain/zero/1.0/ */
-
-"use strict";
-
-Cu.import("resource://gre/modules/MobileIdentityVerificationFlow.jsm");
-
-function verifyStrategy() {
-  return Promise.resolve();
-}
-
-function cleanupStrategy() {
-}
-
-function run_test() {
-  do_print("= Bug 1101444: Invalid verification code shouldn't restart " +
-           "verification flow =");
-
-  let client = new MockClient({
-    // This will emulate two invalid attempts. The third time it will work.
-    verifyCodeError: ["INVALID", "INVALID"]
-  });
-  let ui = new MockUi();
-
-  let verificationFlow = new MobileIdentityVerificationFlow({
-    external: true,
-    sessionToken: SESSION_TOKEN,
-    msisdn: PHONE_NUMBER
-  }, ui, client, verifyStrategy, cleanupStrategy);
-
-  verificationFlow.doVerification().then(() => {
-    // We should only do the registration process once. We only try registering
-    // again when the timeout fires, but not when we enter an invalid
-    // verification code.
-    client._("register").callsLength(1);
-    client._("verifyCode").callsLength(3);
-    // Because we do two invalid attempts, we should show the invalid code error twice.
-    ui._("error").callsLength(2);
-  });
-
-  do_test_finished();
-};
diff --git a/services/mobileid/tests/xpcshell/xpcshell.ini b/services/mobileid/tests/xpcshell/xpcshell.ini
deleted file mode 100644
--- a/services/mobileid/tests/xpcshell/xpcshell.ini
+++ /dev/null
@@ -1,8 +0,0 @@
-[DEFAULT]
-head = head.js
-tail =
-
-[test_mobileid_manager.js]
-skip-if = 1
-[test_mobileid_client.js]
-[test_mobileid_verification_flow.js]
diff --git a/services/moz.build b/services/moz.build
--- a/services/moz.build
+++ b/services/moz.build
@@ -10,13 +10,10 @@ DIRS += [
 ]
 
 if CONFIG['MOZ_WIDGET_TOOLKIT'] != 'android':
     DIRS += ['fxaccounts']
 
 if CONFIG['MOZ_SERVICES_SYNC']:
     DIRS += ['sync']
 
-if CONFIG['MOZ_B2G']:
-    DIRS += ['mobileid']
-
 if CONFIG['MOZ_SERVICES_CLOUDSYNC']:
     DIRS += ['cloudsync']
