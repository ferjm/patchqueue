# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  1bf9a2692d3ffe6cb486265f53d69a277e6faec6
try: -b do -p linux -u all -t none

diff --git a/dom/backgroundsync/BackgroundSyncService.cpp b/dom/backgroundsync/BackgroundSyncService.cpp
--- a/dom/backgroundsync/BackgroundSyncService.cpp
+++ b/dom/backgroundsync/BackgroundSyncService.cpp
@@ -180,30 +180,37 @@ BackgroundSyncService::ReleaseStorageMan
     }
   }
 }
 
 // ----------------------------------------------------------------------------
 // ChromeStorageManager
 
 void
-BackgroundSyncService::AddChromeStorageManagerRef(
-    const nsID& aRequestId, ChromeStorageManager* aChromeStorageManager)
+BackgroundSyncService::AddChromeStorageRequest(const nsID& aRequestId)
 {
+  printf_stderr("BackgroundSyncService::AddChromeStorageRequest\n");
   AssertIsOnBackgroundThread();
 
-  mChromeStorageManagers.Put(aRequestId, aChromeStorageManager);
+  mPendingChromeStorageRequest.AppendElement(aRequestId);
 }
 
 void
-BackgroundSyncService::ReleaseChromeStorageManagerRef(const nsID& aRequestId)
+BackgroundSyncService::RemoveChromeStorageRequest(const nsID& aRequestId)
 {
+  printf_stderr("BackgroundSyncService::RemoveChromeStorageRequest count %zu\n", mPendingChromeStorageRequest.Length());
   AssertIsOnBackgroundThread();
 
-  mChromeStorageManagers.Remove(aRequestId);
+  mPendingChromeStorageRequest.RemoveElement(aRequestId);
+
+  printf_stderr("BackgroundSyncService::RemoveChromeStorageRequest Removed count %zu\n", mPendingChromeStorageRequest.Length());
+
+  if (mPendingChromeStorageRequest.IsEmpty()) {
+    MaybeShutdown();
+  }
 }
 
 // ----------------------------------------------------------------------------
 
 BackgroundSyncService::BackgroundSyncService()
   : mOnlineState(OnlineStateObserver::eUnknown)
 {
   AssertIsOnBackgroundThread();
@@ -211,21 +218,22 @@ BackgroundSyncService::BackgroundSyncSer
   // sInstance is a raw BackgroundSyncService*. It is kept alive by
   // ServiceWorkerManagerParent and BackgroundSyncParent instances.
   MOZ_ASSERT(!sInstance);
   sInstance = this;
 }
 
 BackgroundSyncService::~BackgroundSyncService()
 {
-  AssertIsOnBackgroundThread();
+  printf_stderr("BackgroundSyncService::~BackgroundSyncService\n");
+//  AssertIsOnBackgroundThread();
   MOZ_ASSERT(sInstance == this);
   MOZ_ASSERT(mBackgroundSyncActors.Length() == 0);
   MOZ_ASSERT(mStorageManagers.Count() == 0);
-  MOZ_ASSERT(mChromeStorageManagers.Count() == 0);
+  MOZ_ASSERT(!mChromeStorageManager);
   MOZ_ASSERT(!mOnlineStateObserver);
 
   sInstance = nullptr;
 }
 
 // static
 already_AddRefed<BackgroundSyncService>
 BackgroundSyncService::GetOrCreate()
@@ -238,30 +246,36 @@ BackgroundSyncService::GetOrCreate()
     instance->Init();
   }
   return instance.forget();
 }
 
 void
 BackgroundSyncService::Init()
 {
+  printf_stderr("BackgroundSyncService::Init\n");
   mOnlineStateObserver = OnlineStateObserver::Init(this);
+  mChromeStorageManager = ChromeStorageManager::GetOrCreate();
 }
 
 void
 BackgroundSyncService::MaybeShutdown()
 {
+  printf_stderr("BackgroundSyncService::MaybeShutdown PendingRequest %zu mBackgroundSyncActors %zu mServiceWorkerManagerActors %zu mStorageManagers %d\n", mPendingChromeStorageRequest.Length(), mBackgroundSyncActors.Length(), mServiceWorkerManagerActors.Length(), mStorageManagers.Count());
   AssertIsOnBackgroundThread();
 
   if (mBackgroundSyncActors.Length() == 0 &&
       mServiceWorkerManagerActors.Length() == 0 &&
       mStorageManagers.Count() == 0 &&
-      mChromeStorageManagers.Count() == 0) {
+      mPendingChromeStorageRequest.IsEmpty()) {
+    printf_stderr("YES, Shuttingdown\n");
     mOnlineStateObserver->Shutdown(this);
     mOnlineStateObserver = nullptr;
+    mChromeStorageManager->Shutdown();
+    mChromeStorageManager = nullptr;
   }
 }
 
 // --------------------------------------------------------------------------
 
 void
 BackgroundSyncService::RegisterActor(BackgroundSyncParent* aParent)
 {
@@ -332,17 +346,18 @@ BackgroundSyncService::Request(const uin
 
   return manager->ExecuteRequest(aRequestId, aOp);
 }
 
 bool
 BackgroundSyncService::Response(const uint64_t aActorId,
                                 const nsID& aRequestId,
                                 const SyncOpResponse& aResponse)
-{
+{ 
+  printf_stderr("BackgroundSyncService::Response\n");
   AssertIsOnBackgroundThread();
 
   for (uint32_t i = 0, len = mBackgroundSyncActors.Length(); i < len; ++i) {
     RefPtr<BackgroundSyncParent> parent = mBackgroundSyncActors[i];
     MOZ_ASSERT(parent);
 
     if (parent->Id() != aActorId) {
       continue;
@@ -408,63 +423,64 @@ BackgroundSyncService::Response(const ui
  * After handling any of these internal responses, we end up releasing the
  * ChromeStorageManager in charge of the request if there are no more pending
  * storage operations.
  */
 void
 BackgroundSyncService::OnRequestComplete(const nsID& aRequestId,
                                          const SyncOpResponse& aResponse)
 {
+  printf_stderr("BackgroundSyncService::OnRequestComplete\n");
   AssertIsOnBackgroundThread();
 
   switch (aResponse.type()) {
     case SyncOpResponse::TSyncRegisterResponse:
+      printf_stderr("TSyncRegisterResponse\n");
       // If this is the first registration for this origin, we need to store
       // it in the 'origins' db before we can release the StorageManager and
       // progress the response to the DOM side.
       if (aResponse.get_SyncRegisterResponse().mFirstRegistration()) {
-        RefPtr<ChromeStorageManager> manager =
-          ChromeStorageManager::GetOrCreate();
-        AddChromeStorageManagerRef(aRequestId, manager);
-        manager->Register(aRequestId,
+        AddChromeStorageRequest(aRequestId);
+        mChromeStorageManager->Register(aRequestId,
             aResponse.get_SyncRegisterResponse().mRegistration());
-        return;
+        break;
       }
       // If this is not the first registration for this origin, we can
       // directly try to trigger the sync event.
       MaybeTriggerSyncEvent(
           aResponse.get_SyncRegisterResponse().mRegistration());
       break;
     case SyncOpResponse::TSyncRegisterOriginResponse:
+      printf_stderr("TSyncRegisterOriginResponse\n");
       // Once we have registered the origin for the sync request, we can try
       // to send the sync event.
       MaybeTriggerSyncEvent(
           aResponse.get_SyncRegisterOriginResponse().mRegistration());
       break;
     case SyncOpResponse::TSyncRemoveResponse:
       {
+        printf_stderr("TSyncRemoveResponse\n");
         const nsString& origin = aResponse.get_SyncRemoveResponse().mOrigin();
         // We only get the origin value when there are no more registrations for
         // this origin. If that's the case, we need to remove that origin from
         // the 'origins' DB before we can progress the response to the DOM side.
         if (!origin.IsEmpty()) {
-          RefPtr<ChromeStorageManager> manager =
-            ChromeStorageManager::GetOrCreate();
-          AddChromeStorageManagerRef(aRequestId, manager);
-          manager->Unregister(aRequestId, origin);
-          return;
+          AddChromeStorageRequest(aRequestId);
+          mChromeStorageManager->Unregister(aRequestId, origin);
+          break;
         }
       }
       break;
     case SyncOpResponse::TSyncGetAllOriginsResponse:
       {
+        printf_stderr("TSyncGetAllOriginsResponse\n");
         // If we went offline while getting the origins, we don't care about
         // getting the sync registrations anymore, so we bail out here.
         if (mOnlineState !=  OnlineStateObserver::eOnline) {
-          return;
+          break;
         }
 
         // If we are still online, we need to get the list of sync registrations
         // per origin. To do that we first need to get the corresponding
         // StorageManager for each origin by jumping to the main thread.
         // Once we have each appropriate StorageManager, the GetAll operation
         // will be executed at OnStorageManagerIdCreated. That's why we pass here
         // the SyncInteralOp with SyncGetAllArgs.
@@ -474,72 +490,74 @@ BackgroundSyncService::OnRequestComplete
           new GetStorageManagerRunnable(this, origins,
               SyncInternalOp(SyncGetAllArgs()));
         NS_WARNING_ASSERTION(NS_SUCCEEDED(NS_DispatchToMainThread(runnable)),
                              "NS_DispatchToMainThread failed");
       }
       break;
     case SyncOpResponse::TSyncGetAllResponse:
       {
+        printf_stderr("TSyncGetAllResponse\n");
         // If we went offline while getting the sync registrations, it is
         // useless to continue, as no sync event will be triggered for these
         // registrations. So we just bail out here.
         if (mOnlineState !=  OnlineStateObserver::eOnline) {
-          return;
+          break;
         }
 
         // If we are still online, we try to trigger a sync event per each
         // registration.
         const nsTArray<Registration>& registrations =
             aResponse.get_SyncGetAllResponse().mRegistrations();
         for (uint32_t i = 0; i < registrations.Length(); i++) {
           MaybeTriggerSyncEvent(registrations[i]);
         }
       }
       break;
     case SyncOpResponse::TSyncChangeStateResponse:
       {
+        printf_stderr("TSyncChangeStateResponse\n");
         // For now we only care about a change of state to eFiring.
         Registration registration =
           aResponse.get_SyncChangeStateResponse().mRegistration();
         if (registration.mState() != RegistrationState::eFiring) {
-          return;
+          break;
         }
 
         // If we changed the state to eFiring, that means that we are trying to
         // trigger a sync event for a specific registration.
         // In that case, we need to check if we still are online and so we can
         // continue with the process of firing the sync event. Otherwise, we
         // need to get back to the ePending state and bail out here.
         if (mOnlineState != OnlineStateObserver::eOnline) {
           RefPtr<GetStorageManagerRunnable> runnable =
             new GetStorageManagerRunnable(this, registration.mOrigin(),
                 SyncInternalOp(SyncChangeStateArgs(registration.mId(),
                                RegistrationState::ePending)));
           NS_WARNING_ASSERTION(NS_SUCCEEDED(NS_DispatchToMainThread(runnable)),
                                "NS_DispatchToMainThread failed");
-          return;
+          break;
         }
 
         ContinueTriggeringSyncEvent(registration);
       }
       break;
     default:
       break;
   }
 
   uint64_t actorId = ReleaseStorageManagerRef(aRequestId);
   if (actorId) {
     // If we have an actor ID, this is a DOM request which response needs to be
     // reported back to the content process through the IPC actor.
     Response(actorId, aRequestId, aResponse);
   } else {
     // Otherwise, this is a response to an internal request and we just need to
-    // release the associated ChromeStorageManager reference.
-    ReleaseChromeStorageManagerRef(aRequestId);
+    // remove the request from the pending request list.
+    RemoveChromeStorageRequest(aRequestId);
   }
 }
 
 // --------------------------------------------------------------------------
 
 void
 BackgroundSyncService::MaybeTriggerSyncEvent(const Registration& aRegistration)
 {
@@ -626,20 +644,18 @@ BackgroundSyncService::OnOnlineStateChan
   // trigger the corresponding sync events.
 
   nsID id;
   nsresult rv = nsContentUtils::GenerateUUIDInPlace(id);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return;
   }
 
-  RefPtr<ChromeStorageManager> manager = ChromeStorageManager::GetOrCreate();
-  AddChromeStorageManagerRef(id, manager);
-
-  manager->GetAll(id);
+  AddChromeStorageRequest(id);
+  mChromeStorageManager->GetAll(id);
 }
 
 // --------------------------------------------------------------------------
 
 /**
  * StorageManagerIdFactory::Listener implementation.
  */
 void
diff --git a/dom/backgroundsync/BackgroundSyncService.h b/dom/backgroundsync/BackgroundSyncService.h
--- a/dom/backgroundsync/BackgroundSyncService.h
+++ b/dom/backgroundsync/BackgroundSyncService.h
@@ -90,23 +90,21 @@ private:
   // For each content origin, we will have a separated registrations DB
   // where we will store the specific information of each registration.
   class StorageManagerRef;
   nsClassHashtable<nsIDHashKey, StorageManagerRef> mStorageManagers;
 
   // --------------------------------------------------------------------------
   // ChromeStorageManager
 
-  void AddChromeStorageManagerRef(const nsID& aRequestId,
-                                  ChromeStorageManager* aChromeStorageManager);
-  void ReleaseChromeStorageManagerRef(const nsID& aRequestId);
+  RefPtr<ChromeStorageManager> mChromeStorageManager;
+  nsTArray<nsID> mPendingChromeStorageRequest;
 
-  // References to the ChromeStorageManager managing the system principal
-  // storage.
-  nsRefPtrHashtable<nsIDHashKey, ChromeStorageManager> mChromeStorageManagers;
+  void AddChromeStorageRequest(const nsID& aRequestId);
+  void RemoveChromeStorageRequest(const nsID& aRequestId);
 
   // --------------------------------------------------------------------------
   // OnlineStateObserver::Listener method
 
   virtual void
   OnOnlineStateChanged(OnlineStateObserver::OnlineState aState) override;
 
   RefPtr<OnlineStateObserver> mOnlineStateObserver;
diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
--- a/dom/backgroundsync/ChromeStorageManager.cpp
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -201,26 +201,28 @@ public:
   NS_IMETHODIMP
   Observe(nsISupports* aSubject,
           const char* aTopic, const char16_t* aData) override
   {
     AssertIsOnMainThread();
 
     MOZ_ASSERT(!strcmp(aTopic, "xpcom-shutdown"));
 
+    printf_stderr("Observed xpcom-shutdown\n");
+
     nsresult rv = mBackgroundThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
 private:
   ~XPCOMShutdownObserver()
   {
-    AssertIsOnBackgroundThread();
+    //AssertIsOnBackgroundThread();
   };
 
   RefPtr<ChromeStorageManager> mManager;
   nsCOMPtr<nsIThread> mIOThread;
   nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
 NS_IMPL_ISUPPORTS(XPCOMShutdownObserver, nsIRunnable, nsIObserver)
@@ -437,23 +439,25 @@ ChromeStorageManager::GetOrCreate()
 
 ChromeStorageManager::ChromeStorageManager()
   : mService(BackgroundSyncService::GetOrCreate())
   , mShuttingDown(false)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(mService);
 
+  printf_stderr("ChromeStorageManager::ChromeStorageManager\n");
   Init();
 }
 
 ChromeStorageManager::~ChromeStorageManager()
 {
-  AssertIsOnBackgroundThread();
+//  AssertIsOnBackgroundThread();
 
+  printf_stderr("ChromeStorageManager::~ChromeStorageManager\n");
   MOZ_ASSERT(!mShutdownObserver);
   MOZ_ASSERT(!mDBConn);
   MOZ_ASSERT(mPendingActions.IsEmpty());
 
   csmInstance = nullptr;
   mService = nullptr;
 }
 
@@ -487,16 +491,18 @@ ChromeStorageManager::OnInitialized(mozI
     ExecuteStorageAction(mPendingActions[i]);
   }
   mPendingActions.Clear();
 }
 
 void
 ChromeStorageManager::Shutdown()
 {
+  printf_stderr("ChromeStorageManager::Shutdown()\n");
+
   AssertIsOnBackgroundThread();
 
   // During the shutdown process we jump to the IO thread to close the DB.
   // Then jump to the main thread to stop observing for xpcom-shutdown and
   // to shutdown the IO thread. After that we jump back to the PBackground
   // thread to clean up the rest of resources and close the door.
 
   if (mShuttingDown) {
@@ -509,24 +515,27 @@ ChromeStorageManager::Shutdown()
     new ShutdownRunnable(this, mDBConn, mShutdownObserver);
   mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
   mDBConn = nullptr;
 }
 
 void
 ChromeStorageManager::FinishShutdown()
 {
+  printf_stderr("ChromeStorageManager::FinishShutdown()\n");
   AssertIsOnBackgroundThread();
 
   mPendingActions.Clear();
 
   nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
+
+  mShutdownObserver = nullptr;
 }
 
 void
 ChromeStorageManager::ExecuteStorageAction(ChromeStorageAction* aAction)
 {
   AssertIsOnBackgroundThread();
 
   if (mShuttingDown) {
diff --git a/dom/backgroundsync/ChromeStorageManager.h b/dom/backgroundsync/ChromeStorageManager.h
--- a/dom/backgroundsync/ChromeStorageManager.h
+++ b/dom/backgroundsync/ChromeStorageManager.h
@@ -26,16 +26,17 @@ namespace dom {
 namespace backgroundsync {
 
 class ChromeStorageAction;
 class Registration;
 class XPCOMShutdownObserver;
 
 class ChromeStorageManager final
 {
+  friend class BackgroundSyncService;
   friend class ContinueInitRunnable;
   friend class ContinueShutdownRunnable;
   friend class StorageActionRunnable;
   friend class XPCOMShutdownObserver;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageManager)
 
