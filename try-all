# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  194d0266252c7b39355841e33b9756bdc7786aad
try: -b do -p linux -u all -t none

diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
--- a/dom/backgroundsync/ChromeStorageManager.cpp
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -84,106 +84,257 @@ private:
   nsID mRequestId;
   nsString mOrigin;
   Registration mRegistration;
 };
 
 //-----------------------------------------------------------------------------
 // IO thread
 
-class InitRunnable final : public nsIRunnable,
-                           public nsICancelableRunnable
+class ContinueInitRunnable final : public nsIRunnable
+                                 , public nsICancelableRunnable
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
-  explicit InitRunnable(ChromeStorageManager* aManager)
+  ContinueInitRunnable(ChromeStorageManager* aManager,
+                       nsIThread* aBackgroundThread)
     : mManager(aManager)
-    , mInitiatingThread(do_GetCurrentThread())
+    , mBackgroundThread(aBackgroundThread)
   {
   }
 
   NS_IMETHODIMP
   Run() override
   {
-    if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+    if (mBackgroundThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
       MOZ_ASSERT(mDBConn);
       mManager->OnInitialized(mDBConn);
       return NS_OK;
     }
 
     nsCOMPtr<nsIFile> dbFile;
     nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
                                          getter_AddRefs(dbFile));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = dbFile->AppendNative(NS_LITERAL_CSTRING("backgroundsync.sqlite"));
+    rv = dbFile->AppendNative(NS_LITERAL_CSTRING("backgroundsync_chrome.sqlite"));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     nsCOMPtr<mozIStorageService> storage =
       do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
     if (NS_WARN_IF(!storage)) { return rv; }
 
     rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     MOZ_ASSERT(mDBConn);
 
     chromedb::CreateOrMigrateSchema(mDBConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    rv = mBackgroundThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     return rv;
   }
 
   NS_IMETHODIMP
   Cancel() override
   {
     return NS_OK;
   }
 
 private:
-  ~InitRunnable() {};
+  ~ContinueInitRunnable() {};
 
   nsCOMPtr<mozIStorageConnection> mDBConn;
   RefPtr<ChromeStorageManager> mManager;
-  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
-NS_IMPL_ISUPPORTS(InitRunnable, nsICancelableRunnable, nsIRunnable)
+NS_IMPL_ISUPPORTS(ContinueInitRunnable, nsICancelableRunnable, nsIRunnable)
+
+//-----------------------------------------------------------------------------
+// Main thread
+
+class XPCOMShutdownObserver final : public nsIRunnable
+                                  , public nsIObserver
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  XPCOMShutdownObserver(ChromeStorageManager* aManager, nsIThread* aIOThread)
+    : mManager(aManager)
+    , mIOThread(aIOThread)
+    , mBackgroundThread(do_GetCurrentThread())
+  {
+    AssertIsOnBackgroundThread();
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    if (mBackgroundThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      MOZ_ASSERT(mManager);
+      mManager->Shutdown();
+      return NS_OK;
+    }
+
+    AssertIsOnMainThread();
+
+    nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+    if (NS_WARN_IF(!os)) {
+      return NS_ERROR_FAILURE;
+    }
+
+    nsresult rv = os->AddObserver(this, "xpcom-shutdown",
+                                  /* holdsWeak */ false);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    RefPtr<ContinueInitRunnable> runnable =
+      new ContinueInitRunnable(mManager, mBackgroundThread);
+    rv = mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  Observe(nsISupports* aSubject,
+          const char* aTopic, const char16_t* aData) override
+  {
+    AssertIsOnMainThread();
+
+    MOZ_ASSERT(!strcmp(aTopic, "xpcom-shutdown"));
+
+    nsresult rv = mBackgroundThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+private:
+  ~XPCOMShutdownObserver()
+  {
+    AssertIsOnBackgroundThread();
+  };
+
+  RefPtr<ChromeStorageManager> mManager;
+  nsCOMPtr<nsIThread> mIOThread;
+  nsCOMPtr<nsIThread> mBackgroundThread;
+};
+
+NS_IMPL_ISUPPORTS(XPCOMShutdownObserver, nsIRunnable, nsIObserver)
+
+class ContinueShutdownRunnable final : public nsIRunnable
+                                     , public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  ContinueShutdownRunnable(ChromeStorageManager* aManager,
+                           XPCOMShutdownObserver* aObserver,
+                           nsIThread* aBackgroundThread)
+    : mManager(aManager)
+    , mObserver(aObserver)
+    , mBackgroundThread(aBackgroundThread)
+  {
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    if (mBackgroundThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      mManager->FinishShutdown();
+      return NS_OK;
+    }
+
+    AssertIsOnMainThread();
+
+    nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
+    if (obs) {
+      obs->RemoveObserver(mObserver, "xpcom-shutdown");
+    }
+
+    nsresult rv =
+      mBackgroundThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~ContinueShutdownRunnable() {};
+
+  RefPtr<ChromeStorageManager> mManager;
+  RefPtr<XPCOMShutdownObserver> mObserver;
+  nsCOMPtr<nsIThread> mBackgroundThread;
+};
+
+NS_IMPL_ISUPPORTS(ContinueShutdownRunnable, nsICancelableRunnable, nsIRunnable)
+
+//-----------------------------------------------------------------------------
+// IO thread
 
 class ShutdownRunnable : public nsIRunnable,
                          public nsICancelableRunnable
 {
 public:
   NS_DECL_THREADSAFE_ISUPPORTS
 
-  explicit ShutdownRunnable(mozIStorageConnection* aConn)
-    : mDBConn(aConn)
-  {}
+  explicit ShutdownRunnable(ChromeStorageManager* aManager,
+                            mozIStorageConnection* aConn,
+                            XPCOMShutdownObserver* aObserver)
+    : mManager(aManager)
+    , mDBConn(aConn)
+    , mObserver(aObserver)
+    , mBackgroundThread(do_GetCurrentThread())
+  {
+    AssertIsOnBackgroundThread();
+  }
 
   NS_IMETHODIMP
   Run() override
   {
     MOZ_ASSERT(mDBConn);
 
-    return mDBConn->Close();
+    nsresult rv;
+    if (mDBConn) {
+      rv = mDBConn->Close();
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+
+    RefPtr<ContinueShutdownRunnable> runnable =
+      new ContinueShutdownRunnable(mManager, mObserver, mBackgroundThread);
+    rv = NS_DispatchToMainThread(runnable, nsIThread::DISPATCH_NORMAL);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    return NS_OK;
   }
 
   NS_IMETHODIMP
   Cancel() override
   {
     return NS_OK;
   }
 
 private:
   ~ShutdownRunnable() {};
 
+  RefPtr<ChromeStorageManager> mManager;
   nsCOMPtr<mozIStorageConnection> mDBConn;
+  RefPtr<XPCOMShutdownObserver> mObserver;
+  nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
 NS_IMPL_ISUPPORTS(ShutdownRunnable, nsICancelableRunnable, nsIRunnable)
 
 class StorageActionRunnable : public nsIRunnable,
                               public nsICancelableRunnable
 {
 public:
@@ -268,69 +419,67 @@ private:
   SyncOpResponse mResponse;
 };
 
 NS_IMPL_ISUPPORTS(StorageActionRunnable, nsICancelableRunnable, nsIRunnable)
 
 //-----------------------------------------------------------------------------
 // PBackground thread
 
-ChromeStorageManager::ChromeStorageManager()
-  : mService(BackgroundSyncService::GetOrCreate())
-{
-  AssertIsOnBackgroundThread();
-  MOZ_ASSERT(mService);
-
-  Init();
-}
-
-ChromeStorageManager::~ChromeStorageManager()
-{
-  AssertIsOnBackgroundThread();
-
-  if (mDBConn) {
-    RefPtr<ShutdownRunnable> runnable = new ShutdownRunnable(mDBConn);
-    mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
-    mDBConn = nullptr;
-  }
-
-  mPendingActions.Clear();
-
-  nsCOMPtr<nsIThread> ioThread;
-  mIOThread.swap(ioThread);
-  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
-        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
-
-  csmInstance = nullptr;
-  mService = nullptr;
-}
-
 // static
 already_AddRefed<ChromeStorageManager>
 ChromeStorageManager::GetOrCreate()
 {
   AssertIsOnBackgroundThread();
 
   RefPtr<ChromeStorageManager> instance = csmInstance;
   if (!instance) {
     instance = new ChromeStorageManager();
   }
   return instance.forget();
 }
 
+ChromeStorageManager::ChromeStorageManager()
+  : mService(BackgroundSyncService::GetOrCreate())
+  , mShuttingDown(false)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mService);
+
+  Init();
+}
+
+ChromeStorageManager::~ChromeStorageManager()
+{
+  AssertIsOnBackgroundThread();
+
+  MOZ_ASSERT(!mShutdownObserver);
+  MOZ_ASSERT(!mDBConn);
+  MOZ_ASSERT(mPendingActions.IsEmpty());
+
+  csmInstance = nullptr;
+  mService = nullptr;
+}
+
 void
 ChromeStorageManager::Init()
 {
   AssertIsOnBackgroundThread();
 
+  // During the initialization process we create the IO thread and jump to
+  // the main thread to observe for xpcom-shutdown. Then we jump to the IO
+  // thread to open the DB and jump back to the PBackground thread with the
+  // DB connection reference.
+
   nsresult rv = NS_NewNamedThread("BSyncChIOThread", getter_AddRefs(mIOThread));
   if (NS_WARN_IF(NS_FAILED(rv))) { return; }
 
-  RefPtr<InitRunnable> runnable = new InitRunnable(this);
-  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  mShutdownObserver = new XPCOMShutdownObserver(this, mIOThread);
+  NS_WARNING_ASSERTION(NS_SUCCEEDED(NS_DispatchToMainThread(mShutdownObserver)),
+                       "Failed to dispatch runnable to main thread");
 }
 
 void
 ChromeStorageManager::OnInitialized(mozIStorageConnection* aConn)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aConn);
 
@@ -338,20 +487,59 @@ ChromeStorageManager::OnInitialized(mozI
 
   for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
     ExecuteStorageAction(mPendingActions[i]);
   }
   mPendingActions.Clear();
 }
 
 void
+ChromeStorageManager::Shutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  // During the shutdown process we jump to the IO thread to close the DB.
+  // Then jump to the main thread to stop observing for xpcom-shutdown and
+  // to shutdown the IO thread. After that we jump back to the PBackground
+  // thread to clean up the rest of resources and close the door.
+
+  if (mShuttingDown) {
+    return;
+  }
+
+  mShuttingDown = true;
+
+  RefPtr<ShutdownRunnable> runnable =
+    new ShutdownRunnable(this, mDBConn, mShutdownObserver);
+  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+  mDBConn = nullptr;
+}
+
+void
+ChromeStorageManager::FinishShutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  mPendingActions.Clear();
+
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
+}
+
+void
 ChromeStorageManager::ExecuteStorageAction(ChromeStorageAction* aAction)
 {
   AssertIsOnBackgroundThread();
 
+  if (mShuttingDown) {
+    return;
+  }
+
   if (!mDBConn) {
     mPendingActions.AppendElement(aAction);
     return;
   }
 
   RefPtr<StorageActionRunnable> runnable = new StorageActionRunnable(this,
                                                                      mDBConn,
                                                                      aAction);
diff --git a/dom/backgroundsync/ChromeStorageManager.h b/dom/backgroundsync/ChromeStorageManager.h
--- a/dom/backgroundsync/ChromeStorageManager.h
+++ b/dom/backgroundsync/ChromeStorageManager.h
@@ -22,21 +22,24 @@
 #include "nsISupportsImpl.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
 class ChromeStorageAction;
 class Registration;
+class XPCOMShutdownObserver;
 
 class ChromeStorageManager final
 {
-  friend class InitRunnable;
+  friend class ContinueInitRunnable;
+  friend class ContinueShutdownRunnable;
   friend class StorageActionRunnable;
+  friend class XPCOMShutdownObserver;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageManager)
 
   static already_AddRefed<ChromeStorageManager>
   GetOrCreate();
 
   void Register(const nsID& aRequestId, const Registration& aRegistration);
@@ -45,26 +48,33 @@ public:
 
 private:
   ChromeStorageManager();
   ~ChromeStorageManager();
 
   void Init();
   void OnInitialized(mozIStorageConnection* aConn);
 
+  void Shutdown();
+  void FinishShutdown();
+
   void ExecuteStorageAction(ChromeStorageAction* aAction);
 
   void OnRequestComplete(const nsID& aRequestId,
                          const SyncOpResponse& aResponse);
 
   RefPtr<BackgroundSyncService> mService;
 
+  RefPtr<XPCOMShutdownObserver> mShutdownObserver;
+
   nsCOMPtr<nsIThread> mIOThread;
   nsCOMPtr<mozIStorageConnection> mDBConn;
 
   nsTArray<RefPtr<ChromeStorageAction>> mPendingActions;
+
+  bool mShuttingDown;
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ChromeStorageManager_h
