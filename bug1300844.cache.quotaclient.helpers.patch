# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  03bc93753a16d2b661cba3bab8dd5508f7e5ecc5
Bug 1300844 - Remove Action* and Context* and use QuotaClient helpers introduced in bug 1217544. r=bkelly

diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
deleted file mode 100644
--- a/dom/cache/Action.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/cache/Action.h"
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-void
-Action::CancelOnInitiatingThread()
-{
-  NS_ASSERT_OWNINGTHREAD(Action);
-  // It is possible for cancellation to be duplicated.  For example, an
-  // individual Cache could have its Actions canceled and then shutdown
-  // could trigger a second action.
-  mCanceled = true;
-}
-
-Action::Action()
-  : mCanceled(false)
-{
-}
-
-Action::~Action()
-{
-}
-
-bool
-Action::IsCanceled() const
-{
-  return mCanceled;
-}
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
deleted file mode 100644
--- a/dom/cache/Action.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_Action_h
-#define mozilla_dom_cache_Action_h
-
-#include "mozilla/Atomics.h"
-#include "mozilla/dom/cache/Types.h"
-#include "nsISupportsImpl.h"
-
-class mozIStorageConnection;
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-class Action
-{
-public:
-  class Resolver
-  {
-  public:
-    // Note: Action must drop Resolver ref after calling Resolve()!
-    // Note: Must be called on the same thread used to execute
-    //       Action::RunOnTarget().
-    virtual void Resolve(nsresult aRv) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    AddRef(void) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    Release(void) = 0;
-  };
-
-  // Class containing data that can be opportunistically shared between
-  // multiple Actions running on the same thread/Context.  In theory
-  // this could be abstracted to a generic key/value map, but for now
-  // just explicitly provide accessors for the data we need.
-  class Data
-  {
-  public:
-    virtual mozIStorageConnection*
-    GetConnection() const = 0;
-
-    virtual void
-    SetConnection(mozIStorageConnection* aConn) = 0;
-  };
-
-  // Execute operations on the target thread.  Once complete call
-  // Resolver::Resolve().  This can be done sync or async.
-  // Note: Action should hold Resolver ref until its ready to call Resolve().
-  // Note: The "target" thread is determined when the Action is scheduled on
-  //       Context.  The Action should not assume any particular thread is used.
-  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
-                           Data* aOptionalData) = 0;
-
-  // Called on initiating thread when the Action is canceled.  The Action is
-  // responsible for calling Resolver::Resolve() as normal; either with a
-  // normal error code or NS_ERROR_ABORT.  If CancelOnInitiatingThread() is
-  // called after Resolve() has already occurred, then the cancel can be
-  // ignored.
-  //
-  // Cancellation is a best effort to stop processing as soon as possible, but
-  // does not guarantee the Action will not run.
-  //
-  // CancelOnInitiatingThread() may be called more than once.  Subsequent
-  // calls should have no effect.
-  //
-  // Default implementation sets an internal cancellation flag that can be
-  // queried with IsCanceled().
-  virtual void CancelOnInitiatingThread();
-
-  // Executed on the initiating thread and is passed the nsresult given to
-  // Resolver::Resolve().
-  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
-
-  // Executed on the initiating thread.  If this Action will operate on the
-  // given cache ID then override this to return true.
-  virtual bool MatchesCacheId(CacheId aCacheId) const { return false; }
-
-  NS_INLINE_DECL_REFCOUNTING(cache::Action)
-
-protected:
-  Action();
-
-  // virtual because deleted through base class pointer
-  virtual ~Action();
-
-  // Check if this Action has been canceled.  May be called from any thread,
-  // but typically used from the target thread.
-  bool IsCanceled() const;
-
-private:
-  // Accessible from any thread.
-  Atomic<bool> mCanceled;
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
deleted file mode 100644
--- a/dom/cache/Context.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_Context_h
-#define mozilla_dom_cache_Context_h
-
-#include "mozilla/dom/cache/Types.h"
-#include "nsCOMPtr.h"
-#include "nsISupportsImpl.h"
-#include "nsProxyRelease.h"
-#include "nsString.h"
-#include "nsTArray.h"
-#include "nsTObserverArray.h"
-
-class nsIEventTarget;
-class nsIThread;
-
-namespace mozilla {
-namespace dom {
-
-namespace quota {
-
-class DirectoryLock;
-
-} // namespace quota
-
-namespace cache {
-
-class Action;
-class Manager;
-
-// The Context class is RAII-style class for managing IO operations within the
-// Cache.
-//
-// When a Context is created it performs the complicated steps necessary to
-// initialize the QuotaManager.  Action objects dispatched on the Context are
-// delayed until this initialization is complete.  They are then allow to
-// execute on any specified thread.  Once all references to the Context are
-// gone, then the steps necessary to release the QuotaManager are performed.
-// After initialization the Context holds a self reference, so it will stay
-// alive until one of three conditions occur:
-//
-//  1) The Manager will call Context::AllowToClose() when all of the actors
-//     have removed themselves as listener.  This means an idle context with
-//     no active DOM objects will close gracefully.
-//  2) The QuotaManager aborts all operations so it can delete the files.
-//     In this case the QuotaManager calls Client::AbortOperations() which
-//     in turn cancels all existing Action objects and then marks the Manager
-//     as invalid.
-//  3) Browser shutdown occurs and the Manager calls Context::CancelAll().
-//
-// In either case, though, the Action objects must be destroyed first to
-// allow the Context to be destroyed.
-//
-// While the Context performs operations asynchronously on threads, all of
-// methods in its public interface must be called on the same thread
-// originally used to create the Context.
-//
-// As an invariant, all Context objects must be destroyed before permitting
-// the "profile-before-change" shutdown event to complete.  This is ensured
-// via the code in ShutdownObserver.cpp.
-class Context final
-{
-  typedef mozilla::dom::quota::DirectoryLock DirectoryLock;
-
-public:
-  // Define a class allowing other threads to hold the Context alive.  This also
-  // allows these other threads to safely close or cancel the Context.
-  class ThreadsafeHandle final
-  {
-    friend class Context;
-  public:
-    void AllowToClose();
-    void InvalidateAndAllowToClose();
-  private:
-    explicit ThreadsafeHandle(Context* aContext);
-    ~ThreadsafeHandle();
-
-    // disallow copying
-    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
-    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
-
-    void AllowToCloseOnOwningThread();
-    void InvalidateAndAllowToCloseOnOwningThread();
-
-    void ContextDestroyed(Context* aContext);
-
-    // Cleared to allow the Context to close.  Only safe to access on
-    // owning thread.
-    RefPtr<Context> mStrongRef;
-
-    // Used to support cancelation even while the Context is already allowed
-    // to close.  Cleared by ~Context() calling ContextDestroyed().  Only
-    // safe to access on owning thread.
-    Context* mWeakRef;
-
-    nsCOMPtr<nsIThread> mOwningThread;
-
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Context::ThreadsafeHandle)
-  };
-
-  // Different objects hold references to the Context while some work is being
-  // performed asynchronously.  These objects must implement the Activity
-  // interface and register themselves with the AddActivity().  When they are
-  // destroyed they must call RemoveActivity().  This allows the Context to
-  // cancel any outstanding Activity work when the Context is cancelled.
-  class Activity
-  {
-  public:
-    virtual void Cancel() = 0;
-    virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
-  };
-
-  // Create a Context attached to the given Manager.  The given Action
-  // will run on the QuotaManager IO thread.  Note, this Action must
-  // be execute synchronously.
-  static already_AddRefed<Context>
-  Create(Manager* aManager, nsIThread* aTarget,
-         Action* aInitAction, Context* aOldContext);
-
-  // Execute given action on the target once the quota manager has been
-  // initialized.
-  //
-  // Only callable from the thread that created the Context.
-  void Dispatch(Action* aAction);
-
-  // Cancel any Actions running or waiting to run.  This should allow the
-  // Context to be released and Listener::RemoveContext() will be called
-  // when complete.
-  //
-  // Only callable from the thread that created the Context.
-  void CancelAll();
-
-  // True if CancelAll() has been called.
-  bool IsCanceled() const;
-
-  // Like CancelAll(), but also marks the Manager as "invalid".
-  void Invalidate();
-
-  // Remove any self references and allow the Context to be released when
-  // there are no more Actions to process.
-  void AllowToClose();
-
-  // Cancel any Actions running or waiting to run that operate on the given
-  // cache ID.
-  //
-  // Only callable from the thread that created the Context.
-  void CancelForCacheId(CacheId aCacheId);
-
-  void AddActivity(Activity* aActivity);
-  void RemoveActivity(Activity* aActivity);
-
-  const QuotaInfo&
-  GetQuotaInfo() const
-  {
-    return mQuotaInfo;
-  }
-
-  // Tell the Context that some state information has been orphaned in the
-  // data store and won't be cleaned up.  The Context will leave the marker
-  // in place to trigger cleanup the next times its opened.
-  void NoteOrphanedData();
-
-private:
-  class Data;
-  class QuotaInitRunnable;
-  class ActionRunnable;
-
-  enum State
-  {
-    STATE_CONTEXT_PREINIT,
-    STATE_CONTEXT_INIT,
-    STATE_CONTEXT_READY,
-    STATE_CONTEXT_CANCELED
-  };
-
-  struct PendingAction
-  {
-    nsCOMPtr<nsIEventTarget> mTarget;
-    RefPtr<Action> mAction;
-  };
-
-  Context(Manager* aManager, nsIThread* aTarget, Action* aInitAction);
-  ~Context();
-  void Init(Context* aOldContext);
-  void Start();
-  void DispatchAction(Action* aAction, bool aDoomData = false);
-  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
-                   already_AddRefed<DirectoryLock> aDirectoryLock);
-
-
-  already_AddRefed<ThreadsafeHandle>
-  CreateThreadsafeHandle();
-
-  void
-  SetNextContext(Context* aNextContext);
-
-  void
-  DoomTargetData();
-
-  RefPtr<Manager> mManager;
-  nsCOMPtr<nsIThread> mTarget;
-  RefPtr<Data> mData;
-  State mState;
-  bool mOrphanedData;
-  QuotaInfo mQuotaInfo;
-  RefPtr<QuotaInitRunnable> mInitRunnable;
-  RefPtr<Action> mInitAction;
-  nsTArray<PendingAction> mPendingActions;
-
-  // Weak refs since activites must remove themselves from this list before
-  // being destroyed by calling RemoveActivity().
-  typedef nsTObserverArray<Activity*> ActivityList;
-  ActivityList mActivityList;
-
-  // The ThreadsafeHandle may have a strong ref back to us.  This creates
-  // a ref-cycle that keeps the Context alive.  The ref-cycle is broken
-  // when ThreadsafeHandle::AllowToClose() is called.
-  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
-
-  RefPtr<DirectoryLock> mDirectoryLock;
-  RefPtr<Context> mNextContext;
-
-public:
-  NS_INLINE_DECL_REFCOUNTING(cache::Context)
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/DBAction.h b/dom/cache/DBAction.h
--- a/dom/cache/DBAction.h
+++ b/dom/cache/DBAction.h
@@ -2,28 +2,32 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_DBAction_h
 #define mozilla_dom_cache_DBAction_h
 
-#include "mozilla/dom/cache/Action.h"
+#include "mozilla/dom/quota/shared/ClientAction.h"
+#include "mozilla/dom/quota/shared/QuotaInfo.h"
 #include "mozilla/RefPtr.h"
 #include "nsString.h"
 
 class mozIStorageConnection;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-class DBAction : public Action
+using quota::shared::ClientAction;
+using quota::shared::QuotaInfo;
+
+class DBAction : public ClientAction
 {
 protected:
   // The mode specifies whether the database should already exist or if its
   // ok to create a new database.
   enum Mode
   {
     Existing,
     Create
@@ -54,17 +58,17 @@ private:
   const Mode mMode;
 };
 
 class SyncDBAction : public DBAction
 {
 protected:
   explicit SyncDBAction(Mode aMode);
 
-  // Action objects are deleted through their base pointer
+  // ClientAction objects are deleted through their base pointer
   virtual ~SyncDBAction();
 
   virtual nsresult
   RunSyncWithDBOnTarget(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
                         mozIStorageConnection* aConn) = 0;
 
 private:
   virtual void
diff --git a/dom/cache/FileUtils.h b/dom/cache/FileUtils.h
--- a/dom/cache/FileUtils.h
+++ b/dom/cache/FileUtils.h
@@ -4,26 +4,29 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_FileUtils_h
 #define mozilla_dom_cache_FileUtils_h
 
 #include "mozilla/Attributes.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/shared/QuotaInfo.h"
 #include "nsStreamUtils.h"
 #include "nsTArrayForwardDeclare.h"
 
 struct nsID;
 class nsIFile;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
+using quota::shared::QuotaInfo;
+
 nsresult
 BodyCreateDir(nsIFile* aBaseDir);
 
 // Note that this function can only be used during the initialization of the
 // database.  We're unlikely to be able to delete the DB successfully past
 // that point due to the file being in use.
 nsresult
 BodyDeleteDir(nsIFile* aBaseDir);
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -6,44 +6,44 @@
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/AutoRestore.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/Unused.h"
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/shared/ClientContext.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
 #include "nsTObserverArray.h"
 
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 namespace {
 
-// An Action that is executed when a Context is first created.  It ensures that
-// the directory and database are setup properly.  This lets other actions
-// not worry about these details.
+// A ClientAction that is executed when a ClientContext is first created.
+// It ensures that the directory and database are setup properly.
+// This lets other actions not worry about these details.
 class SetupAction final : public SyncDBAction
 {
 public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
@@ -52,17 +52,17 @@ public:
   {
     nsresult rv = BodyCreateDir(aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // executes in its own transaction
     rv = db::CreateOrMigrateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    // If the Context marker file exists, then the last session was
+    // If the ClientContext marker file exists, then the last session was
     // not cleanly shutdown.  In these cases sqlite will ensure that
     // the database is valid, but we might still orphan data.  Both
     // Cache objects and body files can be referenced by DOM objects
     // after they are "removed" from their parent.  So we need to
     // look and see if any of these late access objects have been
     // orphaned.
     //
     // Note, this must be done after any schema version updates to
@@ -95,19 +95,19 @@ public:
     }
 
     return rv;
   }
 };
 
 // ----------------------------------------------------------------------------
 
-// Action that is executed when we determine that content has stopped using
+// ClientAction that is executed when we determine that content has stopped using
 // a body file that has been orphaned.
-class DeleteOrphanedBodyAction final : public Action
+class DeleteOrphanedBodyAction final : public ClientAction
 {
 public:
   explicit DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
     : mDeletedBodyIdList(aDeletedBodyIdList)
   { }
 
   explicit DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
@@ -391,18 +391,18 @@ StaticAutoPtr<Manager::Factory> Manager:
 // static
 StaticMutex Manager::Factory::sMutex;
 
 // static
 bool Manager::Factory::sFactoryShutdown = false;
 
 // ----------------------------------------------------------------------------
 
-// Abstract class to help implement the various Actions.  The vast majority
-// of Actions are synchronous and need to report back to a Listener on the
+// Abstract class to help implement the various ClientActions.  The vast majority
+// of ClientActions are synchronous and need to report back to a Listener on the
 // Manager.
 class Manager::BaseAction : public SyncDBAction
 {
 protected:
   BaseAction(Manager* aManager, ListenerId aListenerId)
     : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mListenerId(aListenerId)
@@ -426,17 +426,17 @@ protected:
   }
 
   RefPtr<Manager> mManager;
   const ListenerId mListenerId;
 };
 
 // ----------------------------------------------------------------------------
 
-// Action that is executed when we determine that content has stopped using
+// ClientAction that is executed when we determine that content has stopped using
 // a Cache object that has been orphaned.
 class Manager::DeleteOrphanedCacheAction final : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
     : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mCacheId(aCacheId)
@@ -520,19 +520,19 @@ public:
     } else {
       mStreamList->Activate(mCacheId);
       aListener->OnOpComplete(Move(aRv), CacheMatchResult(void_t()), mResponse,
                               mStreamList);
     }
     mStreamList = nullptr;
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    return aCacheId == mCacheId;
+    return aId == mCacheId;
   }
 
 private:
   const CacheId mCacheId;
   const CacheMatchArgs mArgs;
   RefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
@@ -583,33 +583,33 @@ public:
   Complete(Listener* aListener, ErrorResult&& aRv) override
   {
     mStreamList->Activate(mCacheId);
     aListener->OnOpComplete(Move(aRv), CacheMatchAllResult(), mSavedResponses,
                             mStreamList);
     mStreamList = nullptr;
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    return aCacheId == mCacheId;
+    return aId == mCacheId;
   }
 
 private:
   const CacheId mCacheId;
   const CacheMatchAllArgs mArgs;
   RefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
 // ----------------------------------------------------------------------------
 
-// This is the most complex Action.  It puts a request/response pair into the
-// Cache.  It does not complete until all of the body data has been saved to
-// disk.  This means its an asynchronous Action.
+// This is the most complex ClientAction.  It puts a request/response pair into
+// the Cache.  It does not complete until all of the body data has been saved to
+// disk.  This means its an asynchronous ClientAction.
 class Manager::CachePutAllAction final : public DBAction
 {
 public:
   CachePutAllAction(Manager* aManager, ListenerId aListenerId,
                     CacheId aCacheId,
                     const nsTArray<CacheRequestResponse>& aPutList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
@@ -735,17 +735,17 @@ private:
 
     // We have finished with all async copying.  Indicate this by clearing all
     // our copy contexts.
     {
       MutexAutoLock lock(mMutex);
       mCopyContextList.Clear();
     }
 
-    // An error occurred while async copying.  Terminate the Action.
+    // An error occurred while async copying.  Terminate the ClientAction.
     // DoResolve() will clean up any files we may have written.
     if (NS_FAILED(mAsyncResult)) {
       DoResolve(mAsyncResult);
       return;
     }
 
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
@@ -783,17 +783,17 @@ private:
     Unused << NS_WARN_IF(NS_FAILED(rv));
 
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
 
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mList[i].mRequestStream = nullptr;
       mList[i].mResponseStream = nullptr;
     }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
@@ -802,25 +802,25 @@ private:
     if (listener) {
       listener->OnOpComplete(ErrorResult(aRv), CachePutAllResult());
     }
   }
 
   virtual void
   CancelOnInitiatingThread() override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
-    Action::CancelOnInitiatingThread();
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
+    ClientAction::CancelOnInitiatingThread();
     CancelAllStreamCopying();
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
-    return aCacheId == mCacheId;
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
+    return aId == mCacheId;
   }
 
   struct Entry
   {
     CacheRequest mRequest;
     nsCOMPtr<nsIInputStream> mRequestStream;
     nsID mRequestBodyId;
     nsCOMPtr<nsISupports> mRequestCopyContext;
@@ -904,17 +904,17 @@ private:
     CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
     action->CallOnAsyncCopyCompleteOnTargetThread(aRv);
   }
 
   void
   CallOnAsyncCopyCompleteOnTargetThread(nsresult aRv)
   {
     // May be on any thread, including STS event target.  Non-owning runnable
-    // here since we are guaranteed the Action will survive until
+    // here since we are guaranteed the ClientAction will survive until
     // CompleteOnInitiatingThread is called.
     nsCOMPtr<nsIRunnable> runnable = NewNonOwningRunnableMethod<nsresult>(
       this, &CachePutAllAction::OnAsyncCopyComplete, aRv);
     MOZ_ALWAYS_SUCCEEDS(
       mTargetThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
   }
 
   void
@@ -938,18 +938,18 @@ private:
     // Must be released on the target thread where it was opened.
     mConn = nullptr;
 
     // Drop our ref to the target thread as we are done with this thread.
     // Also makes our thread assertions catch any incorrect method calls
     // after resolve.
     mTargetThread = nullptr;
 
-    // Make sure to de-ref the resolver per the Action API contract.
-    RefPtr<Action::Resolver> resolver;
+    // Make sure to de-ref the resolver per the ClientAction API contract.
+    RefPtr<ClientAction::Resolver> resolver;
     mResolver.swap(resolver);
     resolver->Resolve(aRv);
   }
 
   // initiating thread only
   RefPtr<Manager> mManager;
   const ListenerId mListenerId;
 
@@ -1012,19 +1012,19 @@ public:
 
   virtual void
   Complete(Listener* aListener, ErrorResult&& aRv) override
   {
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
     aListener->OnOpComplete(Move(aRv), CacheDeleteResult(mSuccess));
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    return aCacheId == mCacheId;
+    return aId == mCacheId;
   }
 
 private:
   const CacheId mCacheId;
   const CacheDeleteArgs mArgs;
   bool mSuccess;
   nsTArray<nsID> mDeletedBodyIdList;
 };
@@ -1074,19 +1074,19 @@ public:
   Complete(Listener* aListener, ErrorResult&& aRv) override
   {
     mStreamList->Activate(mCacheId);
     aListener->OnOpComplete(Move(aRv), CacheKeysResult(), mSavedRequests,
                             mStreamList);
     mStreamList = nullptr;
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    return aCacheId == mCacheId;
+    return aId == mCacheId;
   }
 
 private:
   const CacheId mCacheId;
   const CacheKeysArgs mArgs;
   RefPtr<StreamList> mStreamList;
   nsTArray<SavedRequest> mSavedRequests;
 };
@@ -1287,23 +1287,23 @@ public:
   Complete(Listener* aListener, ErrorResult&& aRv) override
   {
     if (mCacheDeleted) {
       // If content is referencing this cache, mark it orphaned to be
       // deleted later.
       if (!mManager->SetCacheIdOrphanedIfRefed(mCacheId)) {
 
         // no outstanding references, delete immediately
-        RefPtr<Context> context = mManager->mContext;
+        RefPtr<ClientContext> context = mManager->mContext;
 
         if (context->IsCanceled()) {
           context->NoteOrphanedData();
         } else {
-          context->CancelForCacheId(mCacheId);
-          RefPtr<Action> action =
+          context->CancelForStorageId(mCacheId);
+          RefPtr<ClientAction> action =
             new DeleteOrphanedCacheAction(mManager, mCacheId);
           context->Dispatch(action);
         }
       }
     }
 
     aListener->OnOpComplete(Move(aRv), StorageDeleteResult(mCacheDeleted));
   }
@@ -1445,30 +1445,30 @@ Manager::RemoveListener(Listener* aListe
   // before it can perform any actual async requests on Manager.
   mListeners.RemoveElement(aListener, ListenerEntryListenerComparator());
   MOZ_ASSERT(!mListeners.Contains(aListener,
                                   ListenerEntryListenerComparator()));
   MaybeAllowContextToClose();
 }
 
 void
-Manager::RemoveContext(Context* aContext)
+Manager::RemoveClientContext(ClientContext* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
-  // Whether the Context destruction was triggered from the Manager going
+  // Whether the ClientContext destruction was triggered from the Manager going
   // idle or the underlying storage being invalidated, we should know we
-  // are closing before the Context is destroyed.
+  // are closing before the ClientContext is destroyed.
   MOZ_ASSERT(mState == Closing);
 
-  // Before forgetting the Context, check to see if we have any outstanding
-  // cache or body objects waiting for deletion.  If so, note that we've
-  // orphaned data so it will be cleaned up on the next open.
+  // Before forgetting the ClientContext, check to see if we have any
+  // outstanding cache or body objects waiting for deletion.  If so, note that
+  // we've orphaned data so it will be cleaned up on the next open.
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mOrphaned) {
       aContext->NoteOrphanedData();
       break;
     }
   }
 
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
@@ -1481,16 +1481,25 @@ Manager::RemoveContext(Context* aContext
   mContext = nullptr;
 
   // Once the context is gone, we can immediately remove ourself from the
   // Factory list.  We don't need to block shutdown by staying in the list
   // any more.
   Factory::Remove(this);
 }
 
+already_AddRefed<nsIPrincipal>
+Manager::GetPrincipal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIPrincipal> ref = mManagerId->Principal();
+  return ref.forget();
+}
+
 void
 Manager::NoteClosing()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
@@ -1524,26 +1533,26 @@ Manager::ReleaseCacheId(CacheId aCacheId
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount == 0) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
-        RefPtr<Context> context = mContext;
+        RefPtr<ClientContext> context = mContext;
         // If the context is already gone, then orphan flag should have been
-        // set in RemoveContext().
+        // set in RemoveClientContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
             context->NoteOrphanedData();
           } else {
-            context->CancelForCacheId(aCacheId);
-            RefPtr<Action> action = new DeleteOrphanedCacheAction(this,
-                                                                    aCacheId);
+            context->CancelForStorageId(aCacheId);
+            RefPtr<ClientAction> action = new DeleteOrphanedCacheAction(this,
+                                                                        aCacheId);
             context->Dispatch(action);
           }
         }
       }
       MaybeAllowContextToClose();
       return;
     }
   }
@@ -1573,24 +1582,24 @@ Manager::ReleaseBodyId(const nsID& aBody
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
       DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
       mBodyIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
       if (mBodyIdRefs[i].mCount < 1) {
         bool orphaned = mBodyIdRefs[i].mOrphaned;
         mBodyIdRefs.RemoveElementAt(i);
-        RefPtr<Context> context = mContext;
+        RefPtr<ClientContext> context = mContext;
         // If the context is already gone, then orphan flag should have been
-        // set in RemoveContext().
+        // set in RemoveClientContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
             context->NoteOrphanedData();
           } else {
-            RefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
+            RefPtr<ClientAction> action = new DeleteOrphanedBodyAction(aBodyId);
             context->Dispatch(action);
           }
         }
       }
       MaybeAllowContextToClose();
       return;
     }
   }
@@ -1628,23 +1637,23 @@ Manager::ExecuteCacheOp(Listener* aListe
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(aOpArgs.type() != CacheOpArgs::TCachePutAllArgs);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action;
+  RefPtr<ClientAction> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
       action = new CacheMatchAction(this, listenerId, aCacheId,
                                     aOpArgs.get_CacheMatchArgs(), streamList);
       break;
     case CacheOpArgs::TCacheMatchAllArgs:
       action = new CacheMatchAllAction(this, listenerId, aCacheId,
                                        aOpArgs.get_CacheMatchAllArgs(),
@@ -1672,23 +1681,23 @@ Manager::ExecuteStorageOp(Listener* aLis
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action;
+  RefPtr<ClientAction> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TStorageMatchArgs:
       action = new StorageMatchAction(this, listenerId, aNamespace,
                                       aOpArgs.get_StorageMatchArgs(),
                                       streamList);
       break;
     case CacheOpArgs::TStorageHasArgs:
       action = new StorageHasAction(this, listenerId, aNamespace,
@@ -1721,24 +1730,24 @@ Manager::ExecutePutAll(Listener* aListen
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), CachePutAllResult());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action = new CachePutAllAction(this, listenerId, aCacheId,
-                                                  aPutList, aRequestStreamList,
-                                                  aResponseStreamList);
+  RefPtr<ClientAction> action = new CachePutAllAction(this, listenerId, aCacheId,
+                                                     aPutList, aRequestStreamList,
+                                                     aResponseStreamList);
 
   context->Dispatch(action);
 }
 
 Manager::Manager(ManagerId* aManagerId, nsIThread* aIOThread)
   : mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
@@ -1763,27 +1772,28 @@ Manager::~Manager()
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
 }
 
 void
 Manager::Init(Manager* aOldManager)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
-  RefPtr<Context> oldContext;
+  RefPtr<ClientContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
-  // Create the context immediately.  Since there can at most be one Context
-  // per Manager now, this lets us cleanly call Factory::Remove() once the
-  // Context goes away.
-  RefPtr<Action> setupAction = new SetupAction();
-  RefPtr<Context> ref = Context::Create(this, mIOThread, setupAction,
-                                          oldContext);
+  // Create the context immediately.  Since there can at most be one
+  // ClientContext per Manager now, this lets us cleanly call Factory::Remove()
+  // once the ClientContext goes away.
+  RefPtr<ClientAction> setupAction = new SetupAction();
+  RefPtr<ClientContext> ref = ClientContext::Create(this, quota::Client::DOMCACHE,
+                                                    NS_LITERAL_STRING("cache"),
+                                                    mIOThread, setupAction, oldContext);
   mContext = ref;
 }
 
 void
 Manager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
@@ -1792,42 +1802,42 @@ Manager::Shutdown()
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
 
   mShuttingDown = true;
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new Context.  We must ensure all Contexts and IO operations are
-  // complete before shutdown proceeds.
+  // creating a new ClientContext.  We must ensure all ClientContexts and IO
+  // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // If there is a context, then cancel and only note that we are done after
   // its cleaned up.
   if (mContext) {
-    RefPtr<Context> context = mContext;
+    RefPtr<ClientContext> context = mContext;
     context->CancelAll();
     return;
   }
 }
 
 void
 Manager::Abort()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new Context.  We must ensure all Contexts and IO operations are
-  // complete before origin clear proceeds.
+  // creating a new ClientContext.  We must ensure all ClientContexts and IO
+  // operations are complete before origin clear proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   context->CancelAll();
 }
 
 Manager::ListenerId
 Manager::SaveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
@@ -1904,41 +1914,41 @@ Manager::NoteOrphanedBodyIdList(const ns
 
   for (uint32_t i = 0; i < aDeletedBodyIdList.Length(); ++i) {
     if (!SetBodyIdOrphanedIfRefed(aDeletedBodyIdList[i])) {
       deleteNowList.AppendElement(aDeletedBodyIdList[i]);
     }
   }
 
   // TODO: note that we need to check these bodies for staleness on startup (bug 1110446)
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   if (!deleteNowList.IsEmpty() && context && !context->IsCanceled()) {
-    RefPtr<Action> action = new DeleteOrphanedBodyAction(deleteNowList);
+    RefPtr<ClientAction> action = new DeleteOrphanedBodyAction(deleteNowList);
     context->Dispatch(action);
   }
 }
 
 void
 Manager::MaybeAllowContextToClose()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
   // If we have an active context, but we have no more users of the Manager,
   // then let it shut itself down.  We must wait for all possible users of
   // Cache state information to complete before doing this.  Once we allow
-  // the Context to close we may not reliably get notified of storage
+  // the ClientContext to close we may not reliably get notified of storage
   // invalidation.
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   if (context && mListeners.IsEmpty()
               && mCacheIdRefs.IsEmpty()
               && mBodyIdRefs.IsEmpty()) {
 
     // Mark this Manager as invalid so that it won't get used again.  We don't
-    // want to start any new operations once we allow the Context to close since
-    // it may race with the underlying storage getting invalidated.
+    // want to start any new operations once we allow the ClientContext to close
+    // since it may race with the underlying storage getting invalidated.
     NoteClosing();
 
     context->AllowToClose();
   }
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/shared/ClientContext.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "mozilla/RefPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIThread;
@@ -22,22 +23,23 @@ namespace mozilla {
 class ErrorResult;
 
 namespace dom {
 namespace cache {
 
 class CacheOpArgs;
 class CacheOpResult;
 class CacheRequestResponse;
-class Context;
 class ManagerId;
 struct SavedRequest;
 struct SavedResponse;
 class StreamList;
 
+using mozilla::dom::quota::shared::ClientContext;
+
 // The Manager is class is responsible for performing all of the underlying
 // work for a Cache or CacheStorage operation.  The DOM objects and IPC actors
 // are basically just plumbing to get the request to the right Manager object
 // running in the parent process.
 //
 // There should be exactly one Manager object for each origin or app using the
 // Cache API.  This uniqueness is defined by the ManagerId equality operator.
 // The uniqueness is enforced by the Manager GetOrCreate() factory method.
@@ -57,17 +59,17 @@ class StreamList;
 //
 // Even once a Manager becomes invalid, however, it may still continue to
 // exist.  This is allowed so that any in-progress Actions can gracefully
 // complete.
 //
 // As an invariant, all Manager objects must cease all IO before shutdown.  This
 // is enforced by the Manager::Factory.  If content still holds references to
 // Cache DOM objects during shutdown, then all operations will begin rejecting.
-class Manager final
+class Manager final : public ClientContext::Listener
 {
 public:
   // Callback interface implemented by clients of Manager, such as CacheParent
   // and CacheStorageParent.  In general, if you call a Manager method you
   // should expect to receive exactly one On*() callback.  For example, if
   // you call Manager::CacheMatch(), then you should expect to receive
   // OnCacheMatch() back in response.
   //
@@ -135,23 +137,16 @@ public:
   static void ShutdownAll();
 
   // Cancel actions for given origin or all actions if passed string is null.
   static void Abort(const nsACString& aOrigin);
 
   // Must be called by Listener objects before they are destroyed.
   void RemoveListener(Listener* aListener);
 
-  // Must be called by Context objects before they are destroyed.
-  void RemoveContext(Context* aContext);
-
-  // Marks the Manager "invalid".  Once the Context completes no new operations
-  // will be permitted with this Manager.  New actors will get a new Manager.
-  void NoteClosing();
-
   State GetState() const;
 
   // If an actor represents a long term reference to a cache or body stream,
   // then they must call AddRefCacheId() or AddRefBodyId().  This will
   // cause the Manager to keep the backing data store alive for the given
   // object.  The actor must then call ReleaseCacheId() or ReleaseBodyId()
   // exactly once for every AddRef*() call it made.  Any delayed deletion
   // will then be performed.
@@ -172,16 +167,28 @@ public:
   void ExecutePutAll(Listener* aListener, CacheId aCacheId,
                      const nsTArray<CacheRequestResponse>& aPutList,
                      const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                      const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList);
 
   void ExecuteStorageOp(Listener* aListener, Namespace aNamespace,
                         const CacheOpArgs& aOpArgs);
 
+  /* ClientContext::Listener */
+
+  // Must be called by ClientContext objects before they are destroyed.
+  virtual void RemoveClientContext(ClientContext* aContext) override;
+
+  // Marks the Manager "invalid".  Once the ClientContext completes no new
+  // operations will be permitted with this Manager.  New actors will get a
+  // new Manager.
+  virtual void NoteClosing() override;
+
+  virtual already_AddRefed<nsIPrincipal> GetPrincipal() const override;
+
 private:
   class Factory;
   class BaseAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAllAction;
@@ -210,18 +217,19 @@ private:
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
 
   void MaybeAllowContextToClose();
 
   RefPtr<ManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
-  // Weak reference cleared by RemoveContext() in Context destructor.
-  Context* MOZ_NON_OWNING_REF mContext;
+  // Weak reference cleared by RemoveClientContext() in ClientContext
+  // destructor.
+  ClientContext* MOZ_NON_OWNING_REF mContext;
 
   // Weak references cleared by RemoveListener() in Listener destructors.
   struct ListenerEntry
   {
     ListenerEntry()
       : mId(UINT64_MAX)
       , mListener(nullptr)
     {
@@ -277,16 +285,16 @@ private:
   {
     nsID mBodyId;
     MozRefCountType mCount;
     bool mOrphaned;
   };
   nsTArray<BodyIdRefCounter> mBodyIdRefs;
 
 public:
-  NS_INLINE_DECL_REFCOUNTING(cache::Manager)
+  NS_INLINE_DECL_REFCOUNTING(cache::Manager, override)
 };
 
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Manager_h
diff --git a/dom/cache/StreamList.cpp b/dom/cache/StreamList.cpp
--- a/dom/cache/StreamList.cpp
+++ b/dom/cache/StreamList.cpp
@@ -2,25 +2,24 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/StreamList.h"
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "nsIInputStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-StreamList::StreamList(Manager* aManager, Context* aContext)
+StreamList::StreamList(Manager* aManager, ClientContext* aContext)
   : mManager(aManager)
   , mContext(aContext)
   , mCacheId(INVALID_CACHE_ID)
   , mStreamControl(nullptr)
   , mActivated(false)
 {
   MOZ_ASSERT(mManager);
   mContext->AddActivity(this);
@@ -145,17 +144,17 @@ StreamList::CloseAll()
 void
 StreamList::Cancel()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   CloseAll();
 }
 
 bool
-StreamList::MatchesCacheId(CacheId aCacheId) const
+StreamList::MatchesStorageId(int64_t aCacheId) const
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   return aCacheId == mCacheId;
 }
 
 StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
diff --git a/dom/cache/StreamList.h b/dom/cache/StreamList.h
--- a/dom/cache/StreamList.h
+++ b/dom/cache/StreamList.h
@@ -2,61 +2,63 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_StreamList_h
 #define mozilla_dom_cache_StreamList_h
 
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/shared/ClientContext.h"
 #include "mozilla/RefPtr.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheStreamControlParent;
 class Manager;
 
-class StreamList final : public Context::Activity
+using quota::shared::ClientContext;
+
+class StreamList final : public ClientContext::Activity
 {
 public:
-  StreamList(Manager* aManager, Context* aContext);
+  StreamList(Manager* aManager, ClientContext* aContext);
 
   void SetStreamControl(CacheStreamControlParent* aStreamControl);
   void RemoveStreamControl(CacheStreamControlParent* aStreamControl);
 
   void Activate(CacheId aCacheId);
 
   void Add(const nsID& aId, nsIInputStream* aStream);
   already_AddRefed<nsIInputStream> Extract(const nsID& aId);
 
   void NoteClosed(const nsID& aId);
   void NoteClosedAll();
   void Close(const nsID& aId);
   void CloseAll();
 
-  // Context::Activity methods
+  // ClientContext::Activity methods
   virtual void Cancel() override;
-  virtual bool MatchesCacheId(CacheId aCacheId) const override;
+  virtual bool MatchesStorageId(int64_t aCacheId) const override;
 
 private:
   ~StreamList();
   struct Entry
   {
     nsID mId;
     nsCOMPtr<nsIInputStream> mStream;
   };
   RefPtr<Manager> mManager;
-  RefPtr<Context> mContext;
+  RefPtr<ClientContext> mContext;
   CacheId mCacheId;
   CacheStreamControlParent* mStreamControl;
   nsTArray<Entry> mList;
   bool mActivated;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(cache::StreamList)
 };
diff --git a/dom/cache/Types.h b/dom/cache/Types.h
--- a/dom/cache/Types.h
+++ b/dom/cache/Types.h
@@ -22,23 +22,13 @@ enum Namespace
   CHROME_ONLY_NAMESPACE,
   NUMBER_OF_NAMESPACES
 };
 static const Namespace INVALID_NAMESPACE = NUMBER_OF_NAMESPACES;
 
 typedef int64_t CacheId;
 static const CacheId INVALID_CACHE_ID = -1;
 
-struct QuotaInfo
-{
-  QuotaInfo() : mIsApp(false) { }
-  nsCOMPtr<nsIFile> mDir;
-  nsCString mSuffix;
-  nsCString mGroup;
-  nsCString mOrigin;
-  bool mIsApp;
-};
-
 } // namespace cache
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_cache_Types_h
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -1,32 +1,30 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.cache += [
-    'Action.h',
     'ActorChild.h',
     'ActorUtils.h',
     'AutoUtils.h',
     'Cache.h',
     'CacheChild.h',
     'CacheOpChild.h',
     'CacheOpParent.h',
     'CacheParent.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlParent.h',
     'CacheWorkerHolder.h',
     'Connection.h',
-    'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
     'PrincipalVerifier.h',
     'QuotaClient.h',
@@ -34,32 +32,30 @@ EXPORTS.mozilla.dom.cache += [
     'SavedTypes.h',
     'StreamControl.h',
     'StreamList.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 UNIFIED_SOURCES += [
-    'Action.cpp',
     'ActorChild.cpp',
     'AutoUtils.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheOpChild.cpp',
     'CacheOpParent.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'CacheWorkerHolder.cpp',
     'Connection.cpp',
-    'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'PrincipalVerifier.cpp',
     'QuotaClient.cpp',
     'ReadStream.cpp',
