# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  67d9f3a1cce7080438668a83cc87391d9dc80a39
Bug 1300844 - Remove Action* and Context* and use QuotaClient helpers introduced in bug 1217544. r=bkelly

diff --git a/dom/cache/Action.cpp b/dom/cache/Action.cpp
deleted file mode 100644
--- a/dom/cache/Action.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/cache/Action.h"
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-void
-Action::CancelOnInitiatingThread()
-{
-  NS_ASSERT_OWNINGTHREAD(Action);
-  // It is possible for cancellation to be duplicated.  For example, an
-  // individual Cache could have its Actions canceled and then shutdown
-  // could trigger a second action.
-  mCanceled = true;
-}
-
-Action::Action()
-  : mCanceled(false)
-{
-}
-
-Action::~Action()
-{
-}
-
-bool
-Action::IsCanceled() const
-{
-  return mCanceled;
-}
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/Action.h b/dom/cache/Action.h
deleted file mode 100644
--- a/dom/cache/Action.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_Action_h
-#define mozilla_dom_cache_Action_h
-
-#include "mozilla/Atomics.h"
-#include "mozilla/dom/cache/Types.h"
-#include "nsISupportsImpl.h"
-
-class mozIStorageConnection;
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-class Action
-{
-public:
-  class Resolver
-  {
-  public:
-    // Note: Action must drop Resolver ref after calling Resolve()!
-    // Note: Must be called on the same thread used to execute
-    //       Action::RunOnTarget().
-    virtual void Resolve(nsresult aRv) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    AddRef(void) = 0;
-
-    NS_IMETHOD_(MozExternalRefCountType)
-    Release(void) = 0;
-  };
-
-  // Class containing data that can be opportunistically shared between
-  // multiple Actions running on the same thread/Context.  In theory
-  // this could be abstracted to a generic key/value map, but for now
-  // just explicitly provide accessors for the data we need.
-  class Data
-  {
-  public:
-    virtual mozIStorageConnection*
-    GetConnection() const = 0;
-
-    virtual void
-    SetConnection(mozIStorageConnection* aConn) = 0;
-  };
-
-  // Execute operations on the target thread.  Once complete call
-  // Resolver::Resolve().  This can be done sync or async.
-  // Note: Action should hold Resolver ref until its ready to call Resolve().
-  // Note: The "target" thread is determined when the Action is scheduled on
-  //       Context.  The Action should not assume any particular thread is used.
-  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
-                           Data* aOptionalData) = 0;
-
-  // Called on initiating thread when the Action is canceled.  The Action is
-  // responsible for calling Resolver::Resolve() as normal; either with a
-  // normal error code or NS_ERROR_ABORT.  If CancelOnInitiatingThread() is
-  // called after Resolve() has already occurred, then the cancel can be
-  // ignored.
-  //
-  // Cancellation is a best effort to stop processing as soon as possible, but
-  // does not guarantee the Action will not run.
-  //
-  // CancelOnInitiatingThread() may be called more than once.  Subsequent
-  // calls should have no effect.
-  //
-  // Default implementation sets an internal cancellation flag that can be
-  // queried with IsCanceled().
-  virtual void CancelOnInitiatingThread();
-
-  // Executed on the initiating thread and is passed the nsresult given to
-  // Resolver::Resolve().
-  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
-
-  // Executed on the initiating thread.  If this Action will operate on the
-  // given cache ID then override this to return true.
-  virtual bool MatchesCacheId(CacheId aCacheId) const { return false; }
-
-  NS_INLINE_DECL_REFCOUNTING(cache::Action)
-
-protected:
-  Action();
-
-  // virtual because deleted through base class pointer
-  virtual ~Action();
-
-  // Check if this Action has been canceled.  May be called from any thread,
-  // but typically used from the target thread.
-  bool IsCanceled() const;
-
-private:
-  // Accessible from any thread.
-  Atomic<bool> mCanceled;
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_Action_h
diff --git a/dom/cache/Context.cpp b/dom/cache/Context.cpp
deleted file mode 100644
--- a/dom/cache/Context.cpp
+++ /dev/null
@@ -1,1151 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/dom/cache/Context.h"
-
-#include "mozilla/AutoRestore.h"
-#include "mozilla/DebugOnly.h"
-#include "mozilla/dom/cache/Action.h"
-#include "mozilla/dom/cache/FileUtils.h"
-#include "mozilla/dom/cache/Manager.h"
-#include "mozilla/dom/cache/ManagerId.h"
-#include "mozilla/dom/quota/QuotaManager.h"
-#include "mozIStorageConnection.h"
-#include "nsIFile.h"
-#include "nsIPrincipal.h"
-#include "nsIRunnable.h"
-#include "nsThreadUtils.h"
-
-namespace {
-
-using mozilla::dom::cache::Action;
-using mozilla::dom::cache::QuotaInfo;
-
-class NullAction final : public Action
-{
-public:
-  NullAction()
-  {
-  }
-
-  virtual void
-  RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
-  {
-    // Resolve success immediately.  This Action does no actual work.
-    MOZ_ASSERT(aResolver);
-    aResolver->Resolve(NS_OK);
-  }
-};
-
-} // namespace
-
-namespace mozilla {
-namespace dom {
-namespace cache {
-
-using mozilla::DebugOnly;
-using mozilla::dom::quota::AssertIsOnIOThread;
-using mozilla::dom::quota::OpenDirectoryListener;
-using mozilla::dom::quota::QuotaManager;
-using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
-using mozilla::dom::quota::PersistenceType;
-
-class Context::Data final : public Action::Data
-{
-public:
-  explicit Data(nsIThread* aTarget)
-    : mTarget(aTarget)
-  {
-    MOZ_ASSERT(mTarget);
-  }
-
-  virtual mozIStorageConnection*
-  GetConnection() const override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    return mConnection;
-  }
-
-  virtual void
-  SetConnection(mozIStorageConnection* aConn) override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(!mConnection);
-    mConnection = aConn;
-    MOZ_ASSERT(mConnection);
-  }
-
-private:
-  ~Data()
-  {
-    // We could proxy release our data here, but instead just assert.  The
-    // Context code should guarantee that we are destroyed on the target
-    // thread once the connection is initialized.  If we're not, then
-    // QuotaManager might race and try to clear the origin out from under us.
-    MOZ_ASSERT_IF(mConnection, mTarget == NS_GetCurrentThread());
-  }
-
-  nsCOMPtr<nsIThread> mTarget;
-  nsCOMPtr<mozIStorageConnection> mConnection;
-
-  // Threadsafe counting because we're created on the PBackground thread
-  // and destroyed on the target IO thread.
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(Context::Data)
-};
-
-// Executed to perform the complicated dance of steps necessary to initialize
-// the QuotaManager.  This must be performed for each origin before any disk
-// IO occurrs.
-class Context::QuotaInitRunnable final : public nsIRunnable
-                                       , public OpenDirectoryListener
-{
-public:
-  QuotaInitRunnable(Context* aContext,
-                    Manager* aManager,
-                    Data* aData,
-                    nsIThread* aTarget,
-                    Action* aInitAction)
-    : mContext(aContext)
-    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
-    , mManager(aManager)
-    , mData(aData)
-    , mTarget(aTarget)
-    , mInitAction(aInitAction)
-    , mInitiatingThread(NS_GetCurrentThread())
-    , mResult(NS_OK)
-    , mState(STATE_INIT)
-    , mCanceled(false)
-  {
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mManager);
-    MOZ_ASSERT(mData);
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mInitiatingThread);
-    MOZ_ASSERT(mInitAction);
-  }
-
-  nsresult Dispatch()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
-
-    mState = STATE_GET_INFO;
-    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      mState = STATE_COMPLETE;
-      Clear();
-    }
-    return rv;
-  }
-
-  void Cancel()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(!mCanceled);
-    mCanceled = true;
-    mInitAction->CancelOnInitiatingThread();
-  }
-
-  void OpenDirectory();
-
-  // OpenDirectoryListener methods
-  virtual void
-  DirectoryLockAcquired(DirectoryLock* aLock) override;
-
-  virtual void
-  DirectoryLockFailed() override;
-
-private:
-  class SyncResolver final : public Action::Resolver
-  {
-  public:
-    SyncResolver()
-      : mResolved(false)
-      , mResult(NS_OK)
-    { }
-
-    virtual void
-    Resolve(nsresult aRv) override
-    {
-      MOZ_ASSERT(!mResolved);
-      mResolved = true;
-      mResult = aRv;
-    };
-
-    bool Resolved() const { return mResolved; }
-    nsresult Result() const { return mResult; }
-
-  private:
-    ~SyncResolver() { }
-
-    bool mResolved;
-    nsresult mResult;
-
-    NS_INLINE_DECL_REFCOUNTING(Context::QuotaInitRunnable::SyncResolver, override)
-  };
-
-  ~QuotaInitRunnable()
-  {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mInitAction);
-  }
-
-  enum State
-  {
-    STATE_INIT,
-    STATE_GET_INFO,
-    STATE_CREATE_QUOTA_MANAGER,
-    STATE_OPEN_DIRECTORY,
-    STATE_WAIT_FOR_DIRECTORY_LOCK,
-    STATE_ENSURE_ORIGIN_INITIALIZED,
-    STATE_RUN_ON_TARGET,
-    STATE_RUNNING,
-    STATE_COMPLETING,
-    STATE_COMPLETE
-  };
-
-  void Complete(nsresult aResult)
-  {
-    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
-
-    MOZ_ASSERT(NS_SUCCEEDED(mResult));
-    mResult = aResult;
-
-    mState = STATE_COMPLETING;
-    MOZ_ALWAYS_SUCCEEDS(
-      mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-  }
-
-  void Clear()
-  {
-    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-    MOZ_ASSERT(mContext);
-    mContext = nullptr;
-    mManager = nullptr;
-    mInitAction = nullptr;
-  }
-
-  RefPtr<Context> mContext;
-  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
-  RefPtr<Manager> mManager;
-  RefPtr<Data> mData;
-  nsCOMPtr<nsIThread> mTarget;
-  RefPtr<Action> mInitAction;
-  nsCOMPtr<nsIThread> mInitiatingThread;
-  nsresult mResult;
-  QuotaInfo mQuotaInfo;
-  RefPtr<DirectoryLock> mDirectoryLock;
-  State mState;
-  Atomic<bool> mCanceled;
-
-public:
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIRUNNABLE
-};
-
-void
-Context::QuotaInitRunnable::OpenDirectory()
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
-             mState == STATE_OPEN_DIRECTORY);
-  MOZ_ASSERT(QuotaManager::Get());
-
-  // QuotaManager::OpenDirectory() will hold a reference to us as
-  // a listener.  We will then get DirectoryLockAcquired() on the owning
-  // thread when it is safe to access our storage directory.
-  mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
-  QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
-                                     mQuotaInfo.mGroup,
-                                     mQuotaInfo.mOrigin,
-                                     mQuotaInfo.mIsApp,
-                                     quota::Client::DOMCACHE,
-                                     /* aExclusive */ false,
-                                     this);
-}
-
-void
-Context::QuotaInitRunnable::DirectoryLockAcquired(DirectoryLock* aLock)
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
-
-  mDirectoryLock = aLock;
-
-  if (mCanceled) {
-    Complete(NS_ERROR_ABORT);
-    return;
-  }
-
-  QuotaManager* qm = QuotaManager::Get();
-  MOZ_ASSERT(qm);
-
-  mState = STATE_ENSURE_ORIGIN_INITIALIZED;
-  nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    Complete(rv);
-    return;
-  }
-}
-
-void
-Context::QuotaInitRunnable::DirectoryLockFailed()
-{
-  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
-  MOZ_ASSERT(!mDirectoryLock);
-
-  NS_WARNING("Failed to acquire a directory lock!");
-
-  Complete(NS_ERROR_FAILURE);
-}
-
-NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::QuotaInitRunnable, nsIRunnable);
-
-// The QuotaManager init state machine is represented in the following diagram:
-//
-//    +---------------+
-//    |     Start     |      Resolve(error)
-//    | (Orig Thread) +---------------------+
-//    +-------+-------+                     |
-//            |                             |
-// +----------v-----------+                 |
-// |       GetInfo        |  Resolve(error) |
-// |    (Main Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// |  CreateQuotaManager  |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// |    OpenDirectory     |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v-----------+                 |
-// | WaitForDirectoryLock |  Resolve(error) |
-// |    (Orig Thread)     +-----------------+
-// +----------+-----------+                 |
-//            |                             |
-// +----------v------------+                |
-// |EnsureOriginInitialized| Resolve(error) |
-// |   (Quota IO Thread)   +----------------+
-// +----------+------------+                |
-//            |                             |
-// +----------v------------+                |
-// |     RunOnTarget       | Resolve(error) |
-// |   (Target Thread)     +----------------+
-// +----------+------------+                |
-//            |                             |
-//  +---------v---------+            +------v------+
-//  |      Running      |            |  Completing |
-//  | (Target Thread)   +------------>(Orig Thread)|
-//  +-------------------+            +------+------+
-//                                          |
-//                                    +-----v----+
-//                                    | Complete |
-//                                    +----------+
-//
-// The initialization process proceeds through the main states.  If an error
-// occurs, then we transition to Completing state back on the original thread.
-NS_IMETHODIMP
-Context::QuotaInitRunnable::Run()
-{
-  // May run on different threads depending on the state.  See individual
-  // state cases for thread assertions.
-
-  RefPtr<SyncResolver> resolver = new SyncResolver();
-
-  switch(mState) {
-    // -----------------------------------
-    case STATE_GET_INFO:
-    {
-      MOZ_ASSERT(NS_IsMainThread());
-
-      if (mCanceled) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      RefPtr<ManagerId> managerId = mManager->GetManagerId();
-      nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
-      nsresult rv = QuotaManager::GetInfoFromPrincipal(principal,
-                                                       &mQuotaInfo.mSuffix,
-                                                       &mQuotaInfo.mGroup,
-                                                       &mQuotaInfo.mOrigin,
-                                                       &mQuotaInfo.mIsApp);
-      if (NS_WARN_IF(NS_FAILED(rv))) {
-        resolver->Resolve(rv);
-        break;
-      }
-
-      mState = STATE_CREATE_QUOTA_MANAGER;
-      MOZ_ALWAYS_SUCCEEDS(
-        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // ----------------------------------
-    case STATE_CREATE_QUOTA_MANAGER:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-
-      if (mCanceled || QuotaManager::IsShuttingDown()) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      if (QuotaManager::Get()) {
-        OpenDirectory();
-        return NS_OK;
-      }
-
-      mState = STATE_OPEN_DIRECTORY;
-      QuotaManager::GetOrCreate(this);
-      break;
-    }
-    // ----------------------------------
-    case STATE_OPEN_DIRECTORY:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-
-      if (NS_WARN_IF(!QuotaManager::Get())) {
-        resolver->Resolve(NS_ERROR_FAILURE);
-        break;
-      }
-
-      OpenDirectory();
-      break;
-    }
-    // ----------------------------------
-    case STATE_ENSURE_ORIGIN_INITIALIZED:
-    {
-      AssertIsOnIOThread();
-
-      if (mCanceled) {
-        resolver->Resolve(NS_ERROR_ABORT);
-        break;
-      }
-
-      QuotaManager* qm = QuotaManager::Get();
-      MOZ_ASSERT(qm);
-      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
-                                                  mQuotaInfo.mSuffix,
-                                                  mQuotaInfo.mGroup,
-                                                  mQuotaInfo.mOrigin,
-                                                  mQuotaInfo.mIsApp,
-                                                  getter_AddRefs(mQuotaInfo.mDir));
-      if (NS_FAILED(rv)) {
-        resolver->Resolve(rv);
-        break;
-      }
-
-      mState = STATE_RUN_ON_TARGET;
-
-      MOZ_ALWAYS_SUCCEEDS(
-        mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // -------------------
-    case STATE_RUN_ON_TARGET:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-
-      mState = STATE_RUNNING;
-
-      // Execute the provided initialization Action.  The Action must Resolve()
-      // before returning.
-      mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
-      MOZ_ASSERT(resolver->Resolved());
-
-      mData = nullptr;
-
-      // If the database was opened, then we should always succeed when creating
-      // the marker file. If it wasn't opened successfully, then no need to
-      // create a marker file anyway.
-      if (NS_SUCCEEDED(resolver->Result())) {
-        MOZ_ALWAYS_SUCCEEDS(CreateMarkerFile(mQuotaInfo));
-      }
-
-      break;
-    }
-    // -------------------
-    case STATE_COMPLETING:
-    {
-      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
-      mInitAction->CompleteOnInitiatingThread(mResult);
-      mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
-      mState = STATE_COMPLETE;
-
-      // Explicitly cleanup here as the destructor could fire on any of
-      // the threads we have bounced through.
-      Clear();
-      break;
-    }
-    // -----
-    case STATE_WAIT_FOR_DIRECTORY_LOCK:
-    default:
-    {
-      MOZ_CRASH("unexpected state in QuotaInitRunnable");
-    }
-  }
-
-  if (resolver->Resolved()) {
-    Complete(resolver->Result());
-  }
-
-  return NS_OK;
-}
-
-// Runnable wrapper around Action objects dispatched on the Context.  This
-// runnable executes the Action on the appropriate threads while the Context
-// is initialized.
-class Context::ActionRunnable final : public nsIRunnable
-                                    , public Action::Resolver
-                                    , public Context::Activity
-{
-public:
-  ActionRunnable(Context* aContext, Data* aData, nsIEventTarget* aTarget,
-                 Action* aAction, const QuotaInfo& aQuotaInfo)
-    : mContext(aContext)
-    , mData(aData)
-    , mTarget(aTarget)
-    , mAction(aAction)
-    , mQuotaInfo(aQuotaInfo)
-    , mInitiatingThread(NS_GetCurrentThread())
-    , mState(STATE_INIT)
-    , mResult(NS_OK)
-    , mExecutingRunOnTarget(false)
-  {
-    MOZ_ASSERT(mContext);
-    // mData may be nullptr
-    MOZ_ASSERT(mTarget);
-    MOZ_ASSERT(mAction);
-    // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
-    MOZ_ASSERT(mInitiatingThread);
-  }
-
-  nsresult Dispatch()
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mState == STATE_INIT);
-
-    mState = STATE_RUN_ON_TARGET;
-    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
-    if (NS_WARN_IF(NS_FAILED(rv))) {
-      mState = STATE_COMPLETE;
-      Clear();
-    }
-    return rv;
-  }
-
-  virtual bool
-  MatchesCacheId(CacheId aCacheId) const override
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    return mAction->MatchesCacheId(aCacheId);
-  }
-
-  virtual void
-  Cancel() override
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    mAction->CancelOnInitiatingThread();
-  }
-
-  virtual void Resolve(nsresult aRv) override
-  {
-    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
-    MOZ_ASSERT(mState == STATE_RUNNING);
-
-    mResult = aRv;
-
-    // We ultimately must complete on the initiating thread, but bounce through
-    // the current thread again to ensure that we don't destroy objects and
-    // state out from under the currently running action's stack.
-    mState = STATE_RESOLVING;
-
-    // If we were resolved synchronously within Action::RunOnTarget() then we
-    // can avoid a thread bounce and just resolve once RunOnTarget() returns.
-    // The Run() method will handle this by looking at mState after
-    // RunOnTarget() returns.
-    if (mExecutingRunOnTarget) {
-      return;
-    }
-
-    // Otherwise we are in an asynchronous resolve.  And must perform a thread
-    // bounce to run on the target thread again.
-    MOZ_ALWAYS_SUCCEEDS(
-      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-  }
-
-private:
-  ~ActionRunnable()
-  {
-    MOZ_ASSERT(mState == STATE_COMPLETE);
-    MOZ_ASSERT(!mContext);
-    MOZ_ASSERT(!mAction);
-  }
-
-  void Clear()
-  {
-    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-    MOZ_ASSERT(mContext);
-    MOZ_ASSERT(mAction);
-    mContext->RemoveActivity(this);
-    mContext = nullptr;
-    mAction = nullptr;
-  }
-
-  enum State
-  {
-    STATE_INIT,
-    STATE_RUN_ON_TARGET,
-    STATE_RUNNING,
-    STATE_RESOLVING,
-    STATE_COMPLETING,
-    STATE_COMPLETE
-  };
-
-  RefPtr<Context> mContext;
-  RefPtr<Data> mData;
-  nsCOMPtr<nsIEventTarget> mTarget;
-  RefPtr<Action> mAction;
-  const QuotaInfo mQuotaInfo;
-  nsCOMPtr<nsIThread> mInitiatingThread;
-  State mState;
-  nsresult mResult;
-
-  // Only accessible on target thread;
-  bool mExecutingRunOnTarget;
-
-public:
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIRUNNABLE
-};
-
-NS_IMPL_ISUPPORTS(mozilla::dom::cache::Context::ActionRunnable, nsIRunnable);
-
-// The ActionRunnable has a simpler state machine.  It basically needs to run
-// the action on the target thread and then complete on the original thread.
-//
-//   +-------------+
-//   |    Start    |
-//   |(Orig Thread)|
-//   +-----+-------+
-//         |
-// +-------v---------+
-// |  RunOnTarget    |
-// |Target IO Thread)+---+ Resolve()
-// +-------+---------+   |
-//         |             |
-// +-------v----------+  |
-// |     Running      |  |
-// |(Target IO Thread)|  |
-// +------------------+  |
-//         | Resolve()   |
-// +-------v----------+  |
-// |     Resolving    <--+                   +-------------+
-// |                  |                      |  Completing |
-// |(Target IO Thread)+---------------------->(Orig Thread)|
-// +------------------+                      +-------+-----+
-//                                                   |
-//                                                   |
-//                                              +----v---+
-//                                              |Complete|
-//                                              +--------+
-//
-// Its important to note that synchronous actions will effectively Resolve()
-// out of the Running state immediately.  Asynchronous Actions may remain
-// in the Running state for some time, but normally the ActionRunnable itself
-// does not see any execution there.  Its all handled internal to the Action.
-NS_IMETHODIMP
-Context::ActionRunnable::Run()
-{
-  switch(mState) {
-    // ----------------------
-    case STATE_RUN_ON_TARGET:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      MOZ_ASSERT(!mExecutingRunOnTarget);
-
-      // Note that we are calling RunOnTarget().  This lets us detect
-      // if Resolve() is called synchronously.
-      AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
-      mExecutingRunOnTarget = true;
-
-      mState = STATE_RUNNING;
-      mAction->RunOnTarget(this, mQuotaInfo, mData);
-
-      mData = nullptr;
-
-      // Resolve was called synchronously from RunOnTarget().  We can
-      // immediately move to completing now since we are sure RunOnTarget()
-      // completed.
-      if (mState == STATE_RESOLVING) {
-        // Use recursion instead of switch case fall-through...  Seems slightly
-        // easier to understand.
-        Run();
-      }
-
-      break;
-    }
-    // -----------------
-    case STATE_RESOLVING:
-    {
-      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
-      // The call to Action::RunOnTarget() must have returned now if we
-      // are running on the target thread again.  We may now proceed
-      // with completion.
-      mState = STATE_COMPLETING;
-      // Shutdown must be delayed until all Contexts are destroyed.  Crash
-      // for this invariant violation.
-      MOZ_ALWAYS_SUCCEEDS(
-        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
-      break;
-    }
-    // -------------------
-    case STATE_COMPLETING:
-    {
-      NS_ASSERT_OWNINGTHREAD(ActionRunnable);
-      mAction->CompleteOnInitiatingThread(mResult);
-      mState = STATE_COMPLETE;
-      // Explicitly cleanup here as the destructor could fire on any of
-      // the threads we have bounced through.
-      Clear();
-      break;
-    }
-    // -----------------
-    default:
-    {
-      MOZ_CRASH("unexpected state in ActionRunnable");
-      break;
-    }
-  }
-  return NS_OK;
-}
-
-void
-Context::ThreadsafeHandle::AllowToClose()
-{
-  if (mOwningThread == NS_GetCurrentThread()) {
-    AllowToCloseOnOwningThread();
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all Contexts have been destroyed.
-  nsCOMPtr<nsIRunnable> runnable =
-    NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
-  MOZ_ALWAYS_SUCCEEDS(
-    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
-}
-
-void
-Context::ThreadsafeHandle::InvalidateAndAllowToClose()
-{
-  if (mOwningThread == NS_GetCurrentThread()) {
-    InvalidateAndAllowToCloseOnOwningThread();
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all Contexts have been destroyed.
-  nsCOMPtr<nsIRunnable> runnable =
-    NewRunnableMethod(this, &ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread);
-  MOZ_ALWAYS_SUCCEEDS(
-    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
-}
-
-Context::ThreadsafeHandle::ThreadsafeHandle(Context* aContext)
-  : mStrongRef(aContext)
-  , mWeakRef(aContext)
-  , mOwningThread(NS_GetCurrentThread())
-{
-}
-
-Context::ThreadsafeHandle::~ThreadsafeHandle()
-{
-  // Normally we only touch mStrongRef on the owning thread.  This is safe,
-  // however, because when we do use mStrongRef on the owning thread we are
-  // always holding a strong ref to the ThreadsafeHandle via the owning
-  // runnable.  So we cannot run the ThreadsafeHandle destructor simultaneously.
-  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
-    return;
-  }
-
-  // Dispatch is guaranteed to succeed here because we block shutdown until
-  // all Contexts have been destroyed.
-  NS_ProxyRelease(mOwningThread, mStrongRef.forget());
-}
-
-void
-Context::ThreadsafeHandle::AllowToCloseOnOwningThread()
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-
-  // A Context "closes" when its ref count drops to zero.  Dropping this
-  // strong ref is necessary, but not sufficient for the close to occur.
-  // Any outstanding IO will continue and keep the Context alive.  Once
-  // the Context is idle, it will be destroyed.
-
-  // First, tell the context to flush any target thread shared data.  This
-  // data must be released on the target thread prior to running the Context
-  // destructor.  This will schedule an Action which ensures that the
-  // ~Context() is not immediately executed when we drop the strong ref.
-  if (mStrongRef) {
-    mStrongRef->DoomTargetData();
-  }
-
-  // Now drop our strong ref and let Context finish running any outstanding
-  // Actions.
-  mStrongRef = nullptr;
-}
-
-void
-Context::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-  // Cancel the Context through the weak reference.  This means we can
-  // allow the Context to close by dropping the strong ref, but then
-  // still cancel ongoing IO if necessary.
-  if (mWeakRef) {
-    mWeakRef->Invalidate();
-  }
-  // We should synchronously have AllowToCloseOnOwningThread called when
-  // the Context is canceled.
-  MOZ_ASSERT(!mStrongRef);
-}
-
-void
-Context::ThreadsafeHandle::ContextDestroyed(Context* aContext)
-{
-  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
-  MOZ_ASSERT(!mStrongRef);
-  MOZ_ASSERT(mWeakRef);
-  MOZ_ASSERT(mWeakRef == aContext);
-  mWeakRef = nullptr;
-}
-
-// static
-already_AddRefed<Context>
-Context::Create(Manager* aManager, nsIThread* aTarget,
-                Action* aInitAction, Context* aOldContext)
-{
-  RefPtr<Context> context = new Context(aManager, aTarget, aInitAction);
-  context->Init(aOldContext);
-  return context.forget();
-}
-
-Context::Context(Manager* aManager, nsIThread* aTarget, Action* aInitAction)
-  : mManager(aManager)
-  , mTarget(aTarget)
-  , mData(new Data(aTarget))
-  , mState(STATE_CONTEXT_PREINIT)
-  , mOrphanedData(false)
-  , mInitAction(aInitAction)
-{
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(mTarget);
-}
-
-void
-Context::Dispatch(Action* aAction)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aAction);
-
-  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
-  if (mState == STATE_CONTEXT_CANCELED) {
-    return;
-  } else if (mState == STATE_CONTEXT_INIT ||
-             mState == STATE_CONTEXT_PREINIT) {
-    PendingAction* pending = mPendingActions.AppendElement();
-    pending->mAction = aAction;
-    return;
-  }
-
-  MOZ_ASSERT(STATE_CONTEXT_READY);
-  DispatchAction(aAction);
-}
-
-void
-Context::CancelAll()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  // In PREINIT state we have not dispatch the init action yet.  Just
-  // forget it.
-  if (mState == STATE_CONTEXT_PREINIT) {
-    MOZ_ASSERT(!mInitRunnable);
-    mInitAction = nullptr;
-
-  // In INIT state we have dispatched the runnable, but not received the
-  // async completion yet.  Cancel the runnable, but don't forget about it
-  // until we get OnQuotaInit() callback.
-  } else if (mState == STATE_CONTEXT_INIT) {
-    mInitRunnable->Cancel();
-  }
-
-  mState = STATE_CONTEXT_CANCELED;
-  mPendingActions.Clear();
-  {
-    ActivityList::ForwardIterator iter(mActivityList);
-    while (iter.HasMore()) {
-      iter.GetNext()->Cancel();
-    }
-  }
-  AllowToClose();
-}
-
-bool
-Context::IsCanceled() const
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  return mState == STATE_CONTEXT_CANCELED;
-}
-
-void
-Context::Invalidate()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  mManager->NoteClosing();
-  CancelAll();
-}
-
-void
-Context::AllowToClose()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  if (mThreadsafeHandle) {
-    mThreadsafeHandle->AllowToClose();
-  }
-}
-
-void
-Context::CancelForCacheId(CacheId aCacheId)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  // Remove matching pending actions
-  for (int32_t i = mPendingActions.Length() - 1; i >= 0; --i) {
-    if (mPendingActions[i].mAction->MatchesCacheId(aCacheId)) {
-      mPendingActions.RemoveElementAt(i);
-    }
-  }
-
-  // Cancel activities and let them remove themselves
-  ActivityList::ForwardIterator iter(mActivityList);
-  while (iter.HasMore()) {
-    Activity* activity = iter.GetNext();
-    if (activity->MatchesCacheId(aCacheId)) {
-      activity->Cancel();
-    }
-  }
-}
-
-Context::~Context()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(mManager);
-  MOZ_ASSERT(!mData);
-
-  if (mThreadsafeHandle) {
-    mThreadsafeHandle->ContextDestroyed(this);
-  }
-
-  // Note, this may set the mOrphanedData flag.
-  mManager->RemoveContext(this);
-
-  if (mQuotaInfo.mDir && !mOrphanedData) {
-    MOZ_ALWAYS_SUCCEEDS(DeleteMarkerFile(mQuotaInfo));
-  }
-
-  if (mNextContext) {
-    mNextContext->Start();
-  }
-}
-
-void
-Context::Init(Context* aOldContext)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  if (aOldContext) {
-    aOldContext->SetNextContext(this);
-    return;
-  }
-
-  Start();
-}
-
-void
-Context::Start()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  // Previous context closing delayed our start, but then we were canceled.
-  // In this case, just do nothing here.
-  if (mState == STATE_CONTEXT_CANCELED) {
-    MOZ_ASSERT(!mInitRunnable);
-    MOZ_ASSERT(!mInitAction);
-    return;
-  }
-
-  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
-  MOZ_ASSERT(!mInitRunnable);
-
-  mInitRunnable = new QuotaInitRunnable(this, mManager, mData, mTarget,
-                                        mInitAction);
-  mInitAction = nullptr;
-
-  mState = STATE_CONTEXT_INIT;
-
-  nsresult rv = mInitRunnable->Dispatch();
-  if (NS_FAILED(rv)) {
-    // Shutdown must be delayed until all Contexts are destroyed.  Shutdown
-    // must also prevent any new Contexts from being constructed.  Crash
-    // for this invariant violation.
-    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
-  }
-}
-
-void
-Context::DispatchAction(Action* aAction, bool aDoomData)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  RefPtr<ActionRunnable> runnable =
-    new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
-
-  if (aDoomData) {
-    mData = nullptr;
-  }
-
-  nsresult rv = runnable->Dispatch();
-  if (NS_FAILED(rv)) {
-    // Shutdown must be delayed until all Contexts are destroyed.  Crash
-    // for this invariant violation.
-    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
-  }
-  AddActivity(runnable);
-}
-
-void
-Context::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
-                     already_AddRefed<DirectoryLock> aDirectoryLock)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-
-  MOZ_ASSERT(mInitRunnable);
-  mInitRunnable = nullptr;
-
-  mQuotaInfo = aQuotaInfo;
-
-  // Always save the directory lock to ensure QuotaManager does not shutdown
-  // before the Context has gone away.
-  MOZ_ASSERT(!mDirectoryLock);
-  mDirectoryLock = aDirectoryLock;
-
-  // If we opening the context failed, but we were not explicitly canceled,
-  // still treat the entire context as canceled.  We don't want to allow
-  // new actions to be dispatched.  We also cannot leave the context in
-  // the INIT state after failing to open.
-  if (NS_FAILED(aRv)) {
-    mState = STATE_CONTEXT_CANCELED;
-  }
-
-  if (mState == STATE_CONTEXT_CANCELED) {
-    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
-    }
-    mPendingActions.Clear();
-    mThreadsafeHandle->AllowToClose();
-    // Context will destruct after return here and last ref is released.
-    return;
-  }
-
-  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
-  mState = STATE_CONTEXT_READY;
-
-  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
-    DispatchAction(mPendingActions[i].mAction);
-  }
-  mPendingActions.Clear();
-}
-
-void
-Context::AddActivity(Activity* aActivity)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActivity);
-  MOZ_ASSERT(!mActivityList.Contains(aActivity));
-  mActivityList.AppendElement(aActivity);
-}
-
-void
-Context::RemoveActivity(Activity* aActivity)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aActivity);
-  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
-  MOZ_ASSERT(!mActivityList.Contains(aActivity));
-}
-
-void
-Context::NoteOrphanedData()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  // This may be called more than once
-  mOrphanedData = true;
-}
-
-already_AddRefed<Context::ThreadsafeHandle>
-Context::CreateThreadsafeHandle()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  if (!mThreadsafeHandle) {
-    mThreadsafeHandle = new ThreadsafeHandle(this);
-  }
-  RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
-  return ref.forget();
-}
-
-void
-Context::SetNextContext(Context* aNextContext)
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(aNextContext);
-  MOZ_ASSERT(!mNextContext);
-  mNextContext = aNextContext;
-}
-
-void
-Context::DoomTargetData()
-{
-  NS_ASSERT_OWNINGTHREAD(Context);
-  MOZ_ASSERT(mData);
-
-  // We are about to drop our reference to the Data.  We need to ensure that
-  // the ~Context() destructor does not run until contents of Data have been
-  // released on the Target thread.
-
-  // Dispatch a no-op Action.  This will hold the Context alive through a
-  // roundtrip to the target thread and back to the owning thread.  The
-  // ref to the Data object is cleared on the owning thread after creating
-  // the ActionRunnable, but before dispatching it.
-  RefPtr<Action> action = new NullAction();
-  DispatchAction(action, true /* doomed data */);
-
-  MOZ_ASSERT(!mData);
-}
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
diff --git a/dom/cache/Context.h b/dom/cache/Context.h
deleted file mode 100644
--- a/dom/cache/Context.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_cache_Context_h
-#define mozilla_dom_cache_Context_h
-
-#include "mozilla/dom/cache/Types.h"
-#include "nsCOMPtr.h"
-#include "nsISupportsImpl.h"
-#include "nsProxyRelease.h"
-#include "nsString.h"
-#include "nsTArray.h"
-#include "nsTObserverArray.h"
-
-class nsIEventTarget;
-class nsIThread;
-
-namespace mozilla {
-namespace dom {
-
-namespace quota {
-
-class DirectoryLock;
-
-} // namespace quota
-
-namespace cache {
-
-class Action;
-class Manager;
-
-// The Context class is RAII-style class for managing IO operations within the
-// Cache.
-//
-// When a Context is created it performs the complicated steps necessary to
-// initialize the QuotaManager.  Action objects dispatched on the Context are
-// delayed until this initialization is complete.  They are then allow to
-// execute on any specified thread.  Once all references to the Context are
-// gone, then the steps necessary to release the QuotaManager are performed.
-// After initialization the Context holds a self reference, so it will stay
-// alive until one of three conditions occur:
-//
-//  1) The Manager will call Context::AllowToClose() when all of the actors
-//     have removed themselves as listener.  This means an idle context with
-//     no active DOM objects will close gracefully.
-//  2) The QuotaManager aborts all operations so it can delete the files.
-//     In this case the QuotaManager calls Client::AbortOperations() which
-//     in turn cancels all existing Action objects and then marks the Manager
-//     as invalid.
-//  3) Browser shutdown occurs and the Manager calls Context::CancelAll().
-//
-// In either case, though, the Action objects must be destroyed first to
-// allow the Context to be destroyed.
-//
-// While the Context performs operations asynchronously on threads, all of
-// methods in its public interface must be called on the same thread
-// originally used to create the Context.
-//
-// As an invariant, all Context objects must be destroyed before permitting
-// the "profile-before-change" shutdown event to complete.  This is ensured
-// via the code in ShutdownObserver.cpp.
-class Context final
-{
-  typedef mozilla::dom::quota::DirectoryLock DirectoryLock;
-
-public:
-  // Define a class allowing other threads to hold the Context alive.  This also
-  // allows these other threads to safely close or cancel the Context.
-  class ThreadsafeHandle final
-  {
-    friend class Context;
-  public:
-    void AllowToClose();
-    void InvalidateAndAllowToClose();
-  private:
-    explicit ThreadsafeHandle(Context* aContext);
-    ~ThreadsafeHandle();
-
-    // disallow copying
-    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
-    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
-
-    void AllowToCloseOnOwningThread();
-    void InvalidateAndAllowToCloseOnOwningThread();
-
-    void ContextDestroyed(Context* aContext);
-
-    // Cleared to allow the Context to close.  Only safe to access on
-    // owning thread.
-    RefPtr<Context> mStrongRef;
-
-    // Used to support cancelation even while the Context is already allowed
-    // to close.  Cleared by ~Context() calling ContextDestroyed().  Only
-    // safe to access on owning thread.
-    Context* mWeakRef;
-
-    nsCOMPtr<nsIThread> mOwningThread;
-
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(cache::Context::ThreadsafeHandle)
-  };
-
-  // Different objects hold references to the Context while some work is being
-  // performed asynchronously.  These objects must implement the Activity
-  // interface and register themselves with the AddActivity().  When they are
-  // destroyed they must call RemoveActivity().  This allows the Context to
-  // cancel any outstanding Activity work when the Context is cancelled.
-  class Activity
-  {
-  public:
-    virtual void Cancel() = 0;
-    virtual bool MatchesCacheId(CacheId aCacheId) const = 0;
-  };
-
-  // Create a Context attached to the given Manager.  The given Action
-  // will run on the QuotaManager IO thread.  Note, this Action must
-  // be execute synchronously.
-  static already_AddRefed<Context>
-  Create(Manager* aManager, nsIThread* aTarget,
-         Action* aInitAction, Context* aOldContext);
-
-  // Execute given action on the target once the quota manager has been
-  // initialized.
-  //
-  // Only callable from the thread that created the Context.
-  void Dispatch(Action* aAction);
-
-  // Cancel any Actions running or waiting to run.  This should allow the
-  // Context to be released and Listener::RemoveContext() will be called
-  // when complete.
-  //
-  // Only callable from the thread that created the Context.
-  void CancelAll();
-
-  // True if CancelAll() has been called.
-  bool IsCanceled() const;
-
-  // Like CancelAll(), but also marks the Manager as "invalid".
-  void Invalidate();
-
-  // Remove any self references and allow the Context to be released when
-  // there are no more Actions to process.
-  void AllowToClose();
-
-  // Cancel any Actions running or waiting to run that operate on the given
-  // cache ID.
-  //
-  // Only callable from the thread that created the Context.
-  void CancelForCacheId(CacheId aCacheId);
-
-  void AddActivity(Activity* aActivity);
-  void RemoveActivity(Activity* aActivity);
-
-  const QuotaInfo&
-  GetQuotaInfo() const
-  {
-    return mQuotaInfo;
-  }
-
-  // Tell the Context that some state information has been orphaned in the
-  // data store and won't be cleaned up.  The Context will leave the marker
-  // in place to trigger cleanup the next times its opened.
-  void NoteOrphanedData();
-
-private:
-  class Data;
-  class QuotaInitRunnable;
-  class ActionRunnable;
-
-  enum State
-  {
-    STATE_CONTEXT_PREINIT,
-    STATE_CONTEXT_INIT,
-    STATE_CONTEXT_READY,
-    STATE_CONTEXT_CANCELED
-  };
-
-  struct PendingAction
-  {
-    nsCOMPtr<nsIEventTarget> mTarget;
-    RefPtr<Action> mAction;
-  };
-
-  Context(Manager* aManager, nsIThread* aTarget, Action* aInitAction);
-  ~Context();
-  void Init(Context* aOldContext);
-  void Start();
-  void DispatchAction(Action* aAction, bool aDoomData = false);
-  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
-                   already_AddRefed<DirectoryLock> aDirectoryLock);
-
-
-  already_AddRefed<ThreadsafeHandle>
-  CreateThreadsafeHandle();
-
-  void
-  SetNextContext(Context* aNextContext);
-
-  void
-  DoomTargetData();
-
-  RefPtr<Manager> mManager;
-  nsCOMPtr<nsIThread> mTarget;
-  RefPtr<Data> mData;
-  State mState;
-  bool mOrphanedData;
-  QuotaInfo mQuotaInfo;
-  RefPtr<QuotaInitRunnable> mInitRunnable;
-  RefPtr<Action> mInitAction;
-  nsTArray<PendingAction> mPendingActions;
-
-  // Weak refs since activites must remove themselves from this list before
-  // being destroyed by calling RemoveActivity().
-  typedef nsTObserverArray<Activity*> ActivityList;
-  ActivityList mActivityList;
-
-  // The ThreadsafeHandle may have a strong ref back to us.  This creates
-  // a ref-cycle that keeps the Context alive.  The ref-cycle is broken
-  // when ThreadsafeHandle::AllowToClose() is called.
-  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
-
-  RefPtr<DirectoryLock> mDirectoryLock;
-  RefPtr<Context> mNextContext;
-
-public:
-  NS_INLINE_DECL_REFCOUNTING(cache::Context)
-};
-
-} // namespace cache
-} // namespace dom
-} // namespace mozilla
-
-#endif // mozilla_dom_cache_Context_h
diff --git a/dom/cache/Manager.cpp b/dom/cache/Manager.cpp
--- a/dom/cache/Manager.cpp
+++ b/dom/cache/Manager.cpp
@@ -6,44 +6,44 @@
 
 #include "mozilla/dom/cache/Manager.h"
 
 #include "mozilla/AutoRestore.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/StaticMutex.h"
 #include "mozilla/StaticPtr.h"
 #include "mozilla/Unused.h"
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/DBAction.h"
 #include "mozilla/dom/cache/DBSchema.h"
 #include "mozilla/dom/cache/FileUtils.h"
 #include "mozilla/dom/cache/ManagerId.h"
 #include "mozilla/dom/cache/CacheTypes.h"
 #include "mozilla/dom/cache/SavedTypes.h"
 #include "mozilla/dom/cache/StreamList.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/ClientContext.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozStorageHelper.h"
 #include "nsIInputStream.h"
 #include "nsID.h"
 #include "nsIFile.h"
 #include "nsIThread.h"
 #include "nsThreadUtils.h"
 #include "nsTObserverArray.h"
 
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 namespace {
 
-// An Action that is executed when a Context is first created.  It ensures that
-// the directory and database are setup properly.  This lets other actions
-// not worry about these details.
+// A ClientAction that is executed when a ClientContext is first created.
+// It ensures that the directory and database are setup properly.
+// This lets other actions not worry about these details.
 class SetupAction final : public SyncDBAction
 {
 public:
   SetupAction()
     : SyncDBAction(DBAction::Create)
   { }
 
   virtual nsresult
@@ -52,17 +52,17 @@ public:
   {
     nsresult rv = BodyCreateDir(aDBDir);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
     // executes in its own transaction
     rv = db::CreateOrMigrateSchema(aConn);
     if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
 
-    // If the Context marker file exists, then the last session was
+    // If the ClientContext marker file exists, then the last session was
     // not cleanly shutdown.  In these cases sqlite will ensure that
     // the database is valid, but we might still orphan data.  Both
     // Cache objects and body files can be referenced by DOM objects
     // after they are "removed" from their parent.  So we need to
     // look and see if any of these late access objects have been
     // orphaned.
     //
     // Note, this must be done after any schema version updates to
@@ -95,19 +95,19 @@ public:
     }
 
     return rv;
   }
 };
 
 // ----------------------------------------------------------------------------
 
-// Action that is executed when we determine that content has stopped using
+// ClientAction that is executed when we determine that content has stopped using
 // a body file that has been orphaned.
-class DeleteOrphanedBodyAction final : public Action
+class DeleteOrphanedBodyAction final : public ClientAction
 {
 public:
   explicit DeleteOrphanedBodyAction(const nsTArray<nsID>& aDeletedBodyIdList)
     : mDeletedBodyIdList(aDeletedBodyIdList)
   { }
 
   explicit DeleteOrphanedBodyAction(const nsID& aBodyId)
   {
@@ -391,18 +391,18 @@ StaticAutoPtr<Manager::Factory> Manager:
 // static
 StaticMutex Manager::Factory::sMutex;
 
 // static
 bool Manager::Factory::sFactoryShutdown = false;
 
 // ----------------------------------------------------------------------------
 
-// Abstract class to help implement the various Actions.  The vast majority
-// of Actions are synchronous and need to report back to a Listener on the
+// Abstract class to help implement the various ClientActions.  The vast majority
+// of ClientActions are synchronous and need to report back to a Listener on the
 // Manager.
 class Manager::BaseAction : public SyncDBAction
 {
 protected:
   BaseAction(Manager* aManager, ListenerId aListenerId)
     : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mListenerId(aListenerId)
@@ -426,17 +426,17 @@ protected:
   }
 
   RefPtr<Manager> mManager;
   const ListenerId mListenerId;
 };
 
 // ----------------------------------------------------------------------------
 
-// Action that is executed when we determine that content has stopped using
+// ClientAction that is executed when we determine that content has stopped using
 // a Cache object that has been orphaned.
 class Manager::DeleteOrphanedCacheAction final : public SyncDBAction
 {
 public:
   DeleteOrphanedCacheAction(Manager* aManager, CacheId aCacheId)
     : SyncDBAction(DBAction::Existing)
     , mManager(aManager)
     , mCacheId(aCacheId)
@@ -520,19 +520,19 @@ public:
     } else {
       mStreamList->Activate(mCacheId);
       aListener->OnOpComplete(Move(aRv), CacheMatchResult(void_t()), mResponse,
                               mStreamList);
     }
     mStreamList = nullptr;
   }
 
-  virtual bool MatchesCacheId(CacheId aCacheId) const override
+  virtual bool MatchesStorageId(int64_t aId) const override
   {
-    return aCacheId == mCacheId;
+    return aCacheId == mId;
   }
 
 private:
   const CacheId mCacheId;
   const CacheMatchArgs mArgs;
   RefPtr<StreamList> mStreamList;
   bool mFoundResponse;
   SavedResponse mResponse;
@@ -597,19 +597,19 @@ private:
   const CacheId mCacheId;
   const CacheMatchAllArgs mArgs;
   RefPtr<StreamList> mStreamList;
   nsTArray<SavedResponse> mSavedResponses;
 };
 
 // ----------------------------------------------------------------------------
 
-// This is the most complex Action.  It puts a request/response pair into the
-// Cache.  It does not complete until all of the body data has been saved to
-// disk.  This means its an asynchronous Action.
+// This is the most complex ClientAction.  It puts a request/response pair into
+// the Cache.  It does not complete until all of the body data has been saved to
+// disk.  This means its an asynchronous ClientAction.
 class Manager::CachePutAllAction final : public DBAction
 {
 public:
   CachePutAllAction(Manager* aManager, ListenerId aListenerId,
                     CacheId aCacheId,
                     const nsTArray<CacheRequestResponse>& aPutList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                     const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList)
@@ -735,17 +735,17 @@ private:
 
     // We have finished with all async copying.  Indicate this by clearing all
     // our copy contexts.
     {
       MutexAutoLock lock(mMutex);
       mCopyContextList.Clear();
     }
 
-    // An error occurred while async copying.  Terminate the Action.
+    // An error occurred while async copying.  Terminate the ClientAction.
     // DoResolve() will clean up any files we may have written.
     if (NS_FAILED(mAsyncResult)) {
       DoResolve(mAsyncResult);
       return;
     }
 
     mozStorageTransaction trans(mConn, false,
                                 mozIStorageConnection::TRANSACTION_IMMEDIATE);
@@ -783,17 +783,17 @@ private:
     Unused << NS_WARN_IF(NS_FAILED(rv));
 
     DoResolve(rv);
   }
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
 
     for (uint32_t i = 0; i < mList.Length(); ++i) {
       mList[i].mRequestStream = nullptr;
       mList[i].mResponseStream = nullptr;
     }
 
     mManager->NoteOrphanedBodyIdList(mDeletedBodyIdList);
 
@@ -802,24 +802,24 @@ private:
     if (listener) {
       listener->OnOpComplete(ErrorResult(aRv), CachePutAllResult());
     }
   }
 
   virtual void
   CancelOnInitiatingThread() override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
-    Action::CancelOnInitiatingThread();
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
+    ClientAction::CancelOnInitiatingThread();
     CancelAllStreamCopying();
   }
 
   virtual bool MatchesCacheId(CacheId aCacheId) const override
   {
-    NS_ASSERT_OWNINGTHREAD(Action);
+    NS_ASSERT_OWNINGTHREAD(ClientAction);
     return aCacheId == mCacheId;
   }
 
   struct Entry
   {
     CacheRequest mRequest;
     nsCOMPtr<nsIInputStream> mRequestStream;
     nsID mRequestBodyId;
@@ -904,17 +904,17 @@ private:
     CachePutAllAction* action = static_cast<CachePutAllAction*>(aClosure);
     action->CallOnAsyncCopyCompleteOnTargetThread(aRv);
   }
 
   void
   CallOnAsyncCopyCompleteOnTargetThread(nsresult aRv)
   {
     // May be on any thread, including STS event target.  Non-owning runnable
-    // here since we are guaranteed the Action will survive until
+    // here since we are guaranteed the ClientAction will survive until
     // CompleteOnInitiatingThread is called.
     nsCOMPtr<nsIRunnable> runnable = NewNonOwningRunnableMethod<nsresult>(
       this, &CachePutAllAction::OnAsyncCopyComplete, aRv);
     MOZ_ALWAYS_SUCCEEDS(
       mTargetThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
   }
 
   void
@@ -938,18 +938,18 @@ private:
     // Must be released on the target thread where it was opened.
     mConn = nullptr;
 
     // Drop our ref to the target thread as we are done with this thread.
     // Also makes our thread assertions catch any incorrect method calls
     // after resolve.
     mTargetThread = nullptr;
 
-    // Make sure to de-ref the resolver per the Action API contract.
-    RefPtr<Action::Resolver> resolver;
+    // Make sure to de-ref the resolver per the ClientAction API contract.
+    RefPtr<ClientAction::Resolver> resolver;
     mResolver.swap(resolver);
     resolver->Resolve(aRv);
   }
 
   // initiating thread only
   RefPtr<Manager> mManager;
   const ListenerId mListenerId;
 
@@ -1287,23 +1287,23 @@ public:
   Complete(Listener* aListener, ErrorResult&& aRv) override
   {
     if (mCacheDeleted) {
       // If content is referencing this cache, mark it orphaned to be
       // deleted later.
       if (!mManager->SetCacheIdOrphanedIfRefed(mCacheId)) {
 
         // no outstanding references, delete immediately
-        RefPtr<Context> context = mManager->mContext;
+        RefPtr<ClientContext> context = mManager->mContext;
 
         if (context->IsCanceled()) {
           context->NoteOrphanedData();
         } else {
           context->CancelForCacheId(mCacheId);
-          RefPtr<Action> action =
+          RefPtr<ClientAction> action =
             new DeleteOrphanedCacheAction(mManager, mCacheId);
           context->Dispatch(action);
         }
       }
     }
 
     aListener->OnOpComplete(Move(aRv), StorageDeleteResult(mCacheDeleted));
   }
@@ -1445,30 +1445,30 @@ Manager::RemoveListener(Listener* aListe
   // before it can perform any actual async requests on Manager.
   mListeners.RemoveElement(aListener, ListenerEntryListenerComparator());
   MOZ_ASSERT(!mListeners.Contains(aListener,
                                   ListenerEntryListenerComparator()));
   MaybeAllowContextToClose();
 }
 
 void
-Manager::RemoveContext(Context* aContext)
+Manager::RemoveClientContext(ClientContext* aContext)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(mContext == aContext);
 
-  // Whether the Context destruction was triggered from the Manager going
+  // Whether the ClientContext destruction was triggered from the Manager going
   // idle or the underlying storage being invalidated, we should know we
-  // are closing before the Context is destroyed.
+  // are closing before the ClientContext is destroyed.
   MOZ_ASSERT(mState == Closing);
 
-  // Before forgetting the Context, check to see if we have any outstanding
-  // cache or body objects waiting for deletion.  If so, note that we've
-  // orphaned data so it will be cleaned up on the next open.
+  // Before forgetting the ClientContext, check to see if we have any
+  // outstanding cache or body objects waiting for deletion.  If so, note that
+  // we've orphaned data so it will be cleaned up on the next open.
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mOrphaned) {
       aContext->NoteOrphanedData();
       break;
     }
   }
 
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
@@ -1481,16 +1481,25 @@ Manager::RemoveContext(Context* aContext
   mContext = nullptr;
 
   // Once the context is gone, we can immediately remove ourself from the
   // Factory list.  We don't need to block shutdown by staying in the list
   // any more.
   Factory::Remove(this);
 }
 
+already_AddRefed<nsIPrincipal>
+Manager::GetPrincipal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIPrincipal> ref = mManagerId->Principal();
+  return ref.forget();
+}
+
 void
 Manager::NoteClosing()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   // This can be called more than once legitimately through different paths.
   mState = Closing;
 }
 
@@ -1524,26 +1533,26 @@ Manager::ReleaseCacheId(CacheId aCacheId
   for (uint32_t i = 0; i < mCacheIdRefs.Length(); ++i) {
     if (mCacheIdRefs[i].mCacheId == aCacheId) {
       DebugOnly<uint32_t> oldRef = mCacheIdRefs[i].mCount;
       mCacheIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mCacheIdRefs[i].mCount < oldRef);
       if (mCacheIdRefs[i].mCount == 0) {
         bool orphaned = mCacheIdRefs[i].mOrphaned;
         mCacheIdRefs.RemoveElementAt(i);
-        RefPtr<Context> context = mContext;
+        RefPtr<ClientContext> context = mContext;
         // If the context is already gone, then orphan flag should have been
-        // set in RemoveContext().
+        // set in RemoveClientContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
             context->NoteOrphanedData();
           } else {
             context->CancelForCacheId(aCacheId);
-            RefPtr<Action> action = new DeleteOrphanedCacheAction(this,
-                                                                    aCacheId);
+            RefPtr<ClientAction> action = new DeleteOrphanedCacheAction(this,
+                                                                        aCacheId);
             context->Dispatch(action);
           }
         }
       }
       MaybeAllowContextToClose();
       return;
     }
   }
@@ -1573,24 +1582,24 @@ Manager::ReleaseBodyId(const nsID& aBody
   for (uint32_t i = 0; i < mBodyIdRefs.Length(); ++i) {
     if (mBodyIdRefs[i].mBodyId == aBodyId) {
       DebugOnly<uint32_t> oldRef = mBodyIdRefs[i].mCount;
       mBodyIdRefs[i].mCount -= 1;
       MOZ_ASSERT(mBodyIdRefs[i].mCount < oldRef);
       if (mBodyIdRefs[i].mCount < 1) {
         bool orphaned = mBodyIdRefs[i].mOrphaned;
         mBodyIdRefs.RemoveElementAt(i);
-        RefPtr<Context> context = mContext;
+        RefPtr<ClientContext> context = mContext;
         // If the context is already gone, then orphan flag should have been
-        // set in RemoveContext().
+        // set in RemoveClientContext().
         if (orphaned && context) {
           if (context->IsCanceled()) {
             context->NoteOrphanedData();
           } else {
-            RefPtr<Action> action = new DeleteOrphanedBodyAction(aBodyId);
+            RefPtr<ClientAction> action = new DeleteOrphanedBodyAction(aBodyId);
             context->Dispatch(action);
           }
         }
       }
       MaybeAllowContextToClose();
       return;
     }
   }
@@ -1628,23 +1637,23 @@ Manager::ExecuteCacheOp(Listener* aListe
   MOZ_ASSERT(aListener);
   MOZ_ASSERT(aOpArgs.type() != CacheOpArgs::TCachePutAllArgs);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action;
+  RefPtr<ClientAction> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TCacheMatchArgs:
       action = new CacheMatchAction(this, listenerId, aCacheId,
                                     aOpArgs.get_CacheMatchArgs(), streamList);
       break;
     case CacheOpArgs::TCacheMatchAllArgs:
       action = new CacheMatchAllAction(this, listenerId, aCacheId,
                                        aOpArgs.get_CacheMatchAllArgs(),
@@ -1672,23 +1681,23 @@ Manager::ExecuteStorageOp(Listener* aLis
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), void_t());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StreamList> streamList = new StreamList(this, context);
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action;
+  RefPtr<ClientAction> action;
   switch(aOpArgs.type()) {
     case CacheOpArgs::TStorageMatchArgs:
       action = new StorageMatchAction(this, listenerId, aNamespace,
                                       aOpArgs.get_StorageMatchArgs(),
                                       streamList);
       break;
     case CacheOpArgs::TStorageHasArgs:
       action = new StorageHasAction(this, listenerId, aNamespace,
@@ -1721,24 +1730,24 @@ Manager::ExecutePutAll(Listener* aListen
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(aListener);
 
   if (NS_WARN_IF(mState == Closing)) {
     aListener->OnOpComplete(ErrorResult(NS_ERROR_FAILURE), CachePutAllResult());
     return;
   }
 
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   ListenerId listenerId = SaveListener(aListener);
 
-  RefPtr<Action> action = new CachePutAllAction(this, listenerId, aCacheId,
-                                                  aPutList, aRequestStreamList,
-                                                  aResponseStreamList);
+  RefPtr<ClientAction> action = new CachePutAllAction(this, listenerId, aCacheId,
+                                                     aPutList, aRequestStreamList,
+                                                     aResponseStreamList);
 
   context->Dispatch(action);
 }
 
 Manager::Manager(ManagerId* aManagerId, nsIThread* aIOThread)
   : mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
@@ -1763,27 +1772,27 @@ Manager::~Manager()
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
 }
 
 void
 Manager::Init(Manager* aOldManager)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
-  RefPtr<Context> oldContext;
+  RefPtr<ClientContext> oldContext;
   if (aOldManager) {
     oldContext = aOldManager->mContext;
   }
 
-  // Create the context immediately.  Since there can at most be one Context
-  // per Manager now, this lets us cleanly call Factory::Remove() once the
-  // Context goes away.
-  RefPtr<Action> setupAction = new SetupAction();
-  RefPtr<Context> ref = Context::Create(this, mIOThread, setupAction,
-                                          oldContext);
+  // Create the context immediately.  Since there can at most be one
+  // ClientContext per Manager now, this lets us cleanly call Factory::Remove()
+  // once the ClientContext goes away.
+  RefPtr<ClientAction> setupAction = new SetupAction();
+  RefPtr<ClientContext> ref = ClientContext::Create(this, mIOThread, setupAction,
+                                                    oldContext);
   mContext = ref;
 }
 
 void
 Manager::Shutdown()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
@@ -1792,42 +1801,42 @@ Manager::Shutdown()
   // calls Shutdown().
   if (mShuttingDown) {
     return;
   }
 
   mShuttingDown = true;
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new Context.  We must ensure all Contexts and IO operations are
-  // complete before shutdown proceeds.
+  // creating a new ClientContext.  We must ensure all ClientContexts and IO
+  // operations are complete before shutdown proceeds.
   NoteClosing();
 
   // If there is a context, then cancel and only note that we are done after
   // its cleaned up.
   if (mContext) {
-    RefPtr<Context> context = mContext;
+    RefPtr<ClientContext> context = mContext;
     context->CancelAll();
     return;
   }
 }
 
 void
 Manager::Abort()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
   MOZ_ASSERT(mContext);
 
   // Note that we are closing to prevent any new requests from coming in and
-  // creating a new Context.  We must ensure all Contexts and IO operations are
-  // complete before origin clear proceeds.
+  // creating a new ClientContext.  We must ensure all ClientContexts and IO
+  // operations are complete before origin clear proceeds.
   NoteClosing();
 
   // Cancel and only note that we are done after the context is cleaned up.
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   context->CancelAll();
 }
 
 Manager::ListenerId
 Manager::SaveListener(Listener* aListener)
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
@@ -1904,41 +1913,41 @@ Manager::NoteOrphanedBodyIdList(const ns
 
   for (uint32_t i = 0; i < aDeletedBodyIdList.Length(); ++i) {
     if (!SetBodyIdOrphanedIfRefed(aDeletedBodyIdList[i])) {
       deleteNowList.AppendElement(aDeletedBodyIdList[i]);
     }
   }
 
   // TODO: note that we need to check these bodies for staleness on startup (bug 1110446)
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   if (!deleteNowList.IsEmpty() && context && !context->IsCanceled()) {
-    RefPtr<Action> action = new DeleteOrphanedBodyAction(deleteNowList);
+    RefPtr<ClientAction> action = new DeleteOrphanedBodyAction(deleteNowList);
     context->Dispatch(action);
   }
 }
 
 void
 Manager::MaybeAllowContextToClose()
 {
   NS_ASSERT_OWNINGTHREAD(Manager);
 
   // If we have an active context, but we have no more users of the Manager,
   // then let it shut itself down.  We must wait for all possible users of
   // Cache state information to complete before doing this.  Once we allow
-  // the Context to close we may not reliably get notified of storage
+  // the ClientContext to close we may not reliably get notified of storage
   // invalidation.
-  RefPtr<Context> context = mContext;
+  RefPtr<ClientContext> context = mContext;
   if (context && mListeners.IsEmpty()
               && mCacheIdRefs.IsEmpty()
               && mBodyIdRefs.IsEmpty()) {
 
     // Mark this Manager as invalid so that it won't get used again.  We don't
-    // want to start any new operations once we allow the Context to close since
-    // it may race with the underlying storage getting invalidated.
+    // want to start any new operations once we allow the ClientContext to close
+    // since it may race with the underlying storage getting invalidated.
     NoteClosing();
 
     context->AllowToClose();
   }
 }
 
 } // namespace cache
 } // namespace dom
diff --git a/dom/cache/Manager.h b/dom/cache/Manager.h
--- a/dom/cache/Manager.h
+++ b/dom/cache/Manager.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_Manager_h
 #define mozilla_dom_cache_Manager_h
 
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/ClientContext.h"
 #include "nsCOMPtr.h"
 #include "nsISupportsImpl.h"
 #include "mozilla/RefPtr.h"
 #include "nsString.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 class nsIThread;
@@ -22,17 +23,16 @@ namespace mozilla {
 class ErrorResult;
 
 namespace dom {
 namespace cache {
 
 class CacheOpArgs;
 class CacheOpResult;
 class CacheRequestResponse;
-class Context;
 class ManagerId;
 struct SavedRequest;
 struct SavedResponse;
 class StreamList;
 
 // The Manager is class is responsible for performing all of the underlying
 // work for a Cache or CacheStorage operation.  The DOM objects and IPC actors
 // are basically just plumbing to get the request to the right Manager object
@@ -57,17 +57,17 @@ class StreamList;
 //
 // Even once a Manager becomes invalid, however, it may still continue to
 // exist.  This is allowed so that any in-progress Actions can gracefully
 // complete.
 //
 // As an invariant, all Manager objects must cease all IO before shutdown.  This
 // is enforced by the Manager::Factory.  If content still holds references to
 // Cache DOM objects during shutdown, then all operations will begin rejecting.
-class Manager final
+class Manager final : public quota::ClientContext::Listener
 {
 public:
   // Callback interface implemented by clients of Manager, such as CacheParent
   // and CacheStorageParent.  In general, if you call a Manager method you
   // should expect to receive exactly one On*() callback.  For example, if
   // you call Manager::CacheMatch(), then you should expect to receive
   // OnCacheMatch() back in response.
   //
@@ -135,23 +135,16 @@ public:
   static void ShutdownAll();
 
   // Cancel actions for given origin or all actions if passed string is null.
   static void Abort(const nsACString& aOrigin);
 
   // Must be called by Listener objects before they are destroyed.
   void RemoveListener(Listener* aListener);
 
-  // Must be called by Context objects before they are destroyed.
-  void RemoveContext(Context* aContext);
-
-  // Marks the Manager "invalid".  Once the Context completes no new operations
-  // will be permitted with this Manager.  New actors will get a new Manager.
-  void NoteClosing();
-
   State GetState() const;
 
   // If an actor represents a long term reference to a cache or body stream,
   // then they must call AddRefCacheId() or AddRefBodyId().  This will
   // cause the Manager to keep the backing data store alive for the given
   // object.  The actor must then call ReleaseCacheId() or ReleaseBodyId()
   // exactly once for every AddRef*() call it made.  Any delayed deletion
   // will then be performed.
@@ -172,16 +165,28 @@ public:
   void ExecutePutAll(Listener* aListener, CacheId aCacheId,
                      const nsTArray<CacheRequestResponse>& aPutList,
                      const nsTArray<nsCOMPtr<nsIInputStream>>& aRequestStreamList,
                      const nsTArray<nsCOMPtr<nsIInputStream>>& aResponseStreamList);
 
   void ExecuteStorageOp(Listener* aListener, Namespace aNamespace,
                         const CacheOpArgs& aOpArgs);
 
+  /* quota::ClientContext::Listener */
+
+  // Must be called by ClientContext objects before they are destroyed.
+  virtual void RemoveClientContext(ClientContext* aContext) override;
+
+  // Marks the Manager "invalid".  Once the ClientContext completes no new
+  // operations will be permitted with this Manager.  New actors will get a
+  // new Manager.
+  virtual void NoteClosing() override;
+
+  virtual already_AddRefed<nsIPrincipal> GetPrincipal() const override;
+
 private:
   class Factory;
   class BaseAction;
   class DeleteOrphanedCacheAction;
 
   class CacheMatchAction;
   class CacheMatchAllAction;
   class CachePutAllAction;
@@ -210,18 +215,19 @@ private:
   bool SetBodyIdOrphanedIfRefed(const nsID& aBodyId);
   void NoteOrphanedBodyIdList(const nsTArray<nsID>& aDeletedBodyIdList);
 
   void MaybeAllowContextToClose();
 
   RefPtr<ManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
-  // Weak reference cleared by RemoveContext() in Context destructor.
-  Context* MOZ_NON_OWNING_REF mContext;
+  // Weak reference cleared by RemoveClientContext() in ClientContext
+  // destructor.
+  ClientContext* MOZ_NON_OWNING_REF mContext;
 
   // Weak references cleared by RemoveListener() in Listener destructors.
   struct ListenerEntry
   {
     ListenerEntry()
       : mId(UINT64_MAX)
       , mListener(nullptr)
     {
diff --git a/dom/cache/StreamList.cpp b/dom/cache/StreamList.cpp
--- a/dom/cache/StreamList.cpp
+++ b/dom/cache/StreamList.cpp
@@ -2,25 +2,24 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "mozilla/dom/cache/StreamList.h"
 
 #include "mozilla/dom/cache/CacheStreamControlParent.h"
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Manager.h"
 #include "nsIInputStream.h"
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
-StreamList::StreamList(Manager* aManager, Context* aContext)
+StreamList::StreamList(Manager* aManager, ClientContext* aContext)
   : mManager(aManager)
   , mContext(aContext)
   , mCacheId(INVALID_CACHE_ID)
   , mStreamControl(nullptr)
   , mActivated(false)
 {
   MOZ_ASSERT(mManager);
   mContext->AddActivity(this);
@@ -145,17 +144,17 @@ StreamList::CloseAll()
 void
 StreamList::Cancel()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   CloseAll();
 }
 
 bool
-StreamList::MatchesCacheId(CacheId aCacheId) const
+StreamList::MatchesStorageId(int64_t aCacheId) const
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
   return aCacheId == mCacheId;
 }
 
 StreamList::~StreamList()
 {
   NS_ASSERT_OWNINGTHREAD(StreamList);
diff --git a/dom/cache/StreamList.h b/dom/cache/StreamList.h
--- a/dom/cache/StreamList.h
+++ b/dom/cache/StreamList.h
@@ -2,61 +2,61 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_cache_StreamList_h
 #define mozilla_dom_cache_StreamList_h
 
-#include "mozilla/dom/cache/Context.h"
 #include "mozilla/dom/cache/Types.h"
+#include "mozilla/dom/quota/ClientContext.h"
 #include "mozilla/RefPtr.h"
 #include "nsTArray.h"
 
 class nsIInputStream;
 
 namespace mozilla {
 namespace dom {
 namespace cache {
 
 class CacheStreamControlParent;
 class Manager;
 
-class StreamList final : public Context::Activity
+class StreamList final : public ClientContext::Activity
 {
 public:
-  StreamList(Manager* aManager, Context* aContext);
+  StreamList(Manager* aManager, ClientContext* aContext);
 
   void SetStreamControl(CacheStreamControlParent* aStreamControl);
   void RemoveStreamControl(CacheStreamControlParent* aStreamControl);
 
   void Activate(CacheId aCacheId);
 
   void Add(const nsID& aId, nsIInputStream* aStream);
   already_AddRefed<nsIInputStream> Extract(const nsID& aId);
 
   void NoteClosed(const nsID& aId);
   void NoteClosedAll();
   void Close(const nsID& aId);
   void CloseAll();
 
-  // Context::Activity methods
+  // ClientContext::Activity methods
   virtual void Cancel() override;
-  virtual bool MatchesCacheId(CacheId aCacheId) const override;
+  virtual bool MatchesStorageId(int64_t aCacheId) const override;
 
 private:
   ~StreamList();
   struct Entry
   {
     nsID mId;
     nsCOMPtr<nsIInputStream> mStream;
   };
   RefPtr<Manager> mManager;
-  RefPtr<Context> mContext;
+  RefPtr<ClientContext> mContext;
   CacheId mCacheId;
   CacheStreamControlParent* mStreamControl;
   nsTArray<Entry> mList;
   bool mActivated;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(cache::StreamList)
 };
diff --git a/dom/cache/moz.build b/dom/cache/moz.build
--- a/dom/cache/moz.build
+++ b/dom/cache/moz.build
@@ -1,32 +1,30 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.cache += [
-    'Action.h',
     'ActorChild.h',
     'ActorUtils.h',
     'AutoUtils.h',
     'Cache.h',
     'CacheChild.h',
     'CacheOpChild.h',
     'CacheOpParent.h',
     'CacheParent.h',
     'CacheStorage.h',
     'CacheStorageChild.h',
     'CacheStorageParent.h',
     'CacheStreamControlChild.h',
     'CacheStreamControlParent.h',
     'CacheWorkerHolder.h',
     'Connection.h',
-    'Context.h',
     'DBAction.h',
     'DBSchema.h',
     'FileUtils.h',
     'IPCUtils.h',
     'Manager.h',
     'ManagerId.h',
     'PrincipalVerifier.h',
     'QuotaClient.h',
@@ -34,32 +32,30 @@ EXPORTS.mozilla.dom.cache += [
     'SavedTypes.h',
     'StreamControl.h',
     'StreamList.h',
     'Types.h',
     'TypeUtils.h',
 ]
 
 UNIFIED_SOURCES += [
-    'Action.cpp',
     'ActorChild.cpp',
     'AutoUtils.cpp',
     'Cache.cpp',
     'CacheChild.cpp',
     'CacheOpChild.cpp',
     'CacheOpParent.cpp',
     'CacheParent.cpp',
     'CacheStorage.cpp',
     'CacheStorageChild.cpp',
     'CacheStorageParent.cpp',
     'CacheStreamControlChild.cpp',
     'CacheStreamControlParent.cpp',
     'CacheWorkerHolder.cpp',
     'Connection.cpp',
-    'Context.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'FileUtils.cpp',
     'Manager.cpp',
     'ManagerId.cpp',
     'PrincipalVerifier.cpp',
     'QuotaClient.cpp',
     'ReadStream.cpp',
