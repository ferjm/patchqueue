# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Parent  a8f8e440d627d686fa8898483aa9c5da928a8fa4
Bug 1371393 - Stylo: inDOMUtils::GetRuleColumn reports differently than Gecko

diff --git a/servo/components/selectors/matching.rs b/servo/components/selectors/matching.rs
--- a/servo/components/selectors/matching.rs
+++ b/servo/components/selectors/matching.rs
@@ -140,17 +140,17 @@ impl<'a, 'b, Impl> LocalMatchingContext<
 }
 
 pub fn matches_selector_list<E>(selector_list: &SelectorList<E::Impl>,
                                 element: &E,
                                 context: &mut MatchingContext)
                                 -> bool
     where E: Element
 {
-    selector_list.0.iter().any(|selector_and_hashes| {
+    selector_list.selector_and_hashes.iter().any(|selector_and_hashes| {
         matches_selector(&selector_and_hashes.selector,
                          0,
                          &selector_and_hashes.hashes,
                          element,
                          context,
                          &mut |_, _| {})
     })
 }
diff --git a/servo/components/selectors/parser.rs b/servo/components/selectors/parser.rs
--- a/servo/components/selectors/parser.rs
+++ b/servo/components/selectors/parser.rs
@@ -1,16 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 use attr::{AttrSelectorWithNamespace, ParsedAttrSelectorOperation, AttrSelectorOperator};
 use attr::{ParsedCaseSensitivity, SELECTOR_WHITESPACE, NamespaceConstraint};
 use bloom::BLOOM_HASH_MASK;
-use cssparser::{ParseError, BasicParseError};
+use cssparser::{ParseError, BasicParseError, SourceLocation};
 use cssparser::{Token, Parser as CssParser, parse_nth, ToCss, serialize_identifier, CssStringWriter};
 use precomputed_hash::PrecomputedHash;
 use servo_arc::{Arc, HeaderWithLength, ThinArc};
 use smallvec::SmallVec;
 use std::ascii::AsciiExt;
 use std::borrow::{Borrow, Cow};
 use std::cmp;
 use std::fmt::{self, Display, Debug, Write};
@@ -179,33 +179,46 @@ impl<Impl: SelectorImpl> SelectorAndHash
         SelectorAndHashes {
             selector: selector,
             hashes: hashes,
         }
     }
 }
 
 #[derive(PartialEq, Eq, Clone, Debug)]
-pub struct SelectorList<Impl: SelectorImpl>(pub Vec<SelectorAndHashes<Impl>>);
+pub struct SelectorList<Impl: SelectorImpl> {
+    pub selector_and_hashes: Vec<SelectorAndHashes<Impl>>,
+    pub source_location: SourceLocation,
+}
 
 impl<Impl: SelectorImpl> SelectorList<Impl> {
     /// Parse a comma-separated list of Selectors.
     /// https://drafts.csswg.org/selectors/#grouping
     ///
     /// Return the Selectors or Err if there is an invalid selector.
     pub fn parse<'i, 't, P, E>(parser: &P, input: &mut CssParser<'i, 't>)
                                -> Result<Self, ParseError<'i, SelectorParseError<'i, E>>>
     where P: Parser<'i, Impl=Impl, Error=E> {
+        let location = input.current_source_location();
         input.parse_comma_separated(|input| parse_selector(parser, input).map(SelectorAndHashes::new))
-             .map(SelectorList)
+             .map(|selector_and_hashes| SelectorList {
+                 selector_and_hashes: selector_and_hashes,
+                 source_location: location,
+             })
     }
 
     /// Creates a SelectorList from a Vec of selectors. Used in tests.
     pub fn from_vec(v: Vec<Selector<Impl>>) -> Self {
-        SelectorList(v.into_iter().map(SelectorAndHashes::new).collect())
+        SelectorList {
+            selector_and_hashes: v.into_iter().map(SelectorAndHashes::new).collect(),
+            source_location: SourceLocation {
+                line: 0,
+                column: 0,
+            }
+        }
     }
 }
 
 /// Ancestor hashes for the bloom filter. We precompute these and store them
 /// inline with selectors to optimize cache performance during matching.
 /// This matters a lot.
 ///
 /// We use 4 hashes, which is copied from Gecko, who copied it from WebKit.
@@ -720,17 +733,17 @@ impl<Impl: SelectorImpl> Debug for AttrS
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { self.to_css(f) }
 }
 impl<Impl: SelectorImpl> Debug for LocalName<Impl> {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { self.to_css(f) }
 }
 
 impl<Impl: SelectorImpl> ToCss for SelectorList<Impl> {
     fn to_css<W>(&self, dest: &mut W) -> fmt::Result where W: fmt::Write {
-        let mut iter = self.0.iter();
+        let mut iter = self.selector_and_hashes.iter();
         let first = iter.next()
             .expect("Empty SelectorList, should contain at least one selector");
         first.selector.to_css(dest)?;
         for selector_and_hashes in iter {
             dest.write_str(", ")?;
             selector_and_hashes.selector.to_css(dest)?;
         }
         Ok(())
diff --git a/servo/components/style/invalidation/stylesheets.rs b/servo/components/style/invalidation/stylesheets.rs
--- a/servo/components/style/invalidation/stylesheets.rs
+++ b/servo/components/style/invalidation/stylesheets.rs
@@ -258,17 +258,17 @@ impl StylesheetInvalidationSet {
     {
         use stylesheets::CssRule::*;
         debug!("StylesheetInvalidationSet::collect_invalidations_for_rule");
         debug_assert!(!self.fully_invalid, "Not worth to be here!");
 
         match *rule {
             Style(ref lock) => {
                 let style_rule = lock.read_with(guard);
-                for selector_and_hashes in &style_rule.selectors.0 {
+                for selector_and_hashes in &style_rule.selectors.selector_and_hashes {
                     self.collect_scopes(&selector_and_hashes.selector);
                     if self.fully_invalid {
                         return;
                     }
                 }
             }
             Document(..) |
             Namespace(..) |
diff --git a/servo/components/style/stylesheets/rule_parser.rs b/servo/components/style/stylesheets/rule_parser.rs
--- a/servo/components/style/stylesheets/rule_parser.rs
+++ b/servo/components/style/stylesheets/rule_parser.rs
@@ -496,17 +496,17 @@ impl<'a, 'b, 'i> QualifiedRuleParser<'i>
         SelectorList::parse(&selector_parser, input)
     }
 
     fn parse_block<'t>(
         &mut self,
         prelude: SelectorList<SelectorImpl>,
         input: &mut Parser<'i, 't>
     ) -> Result<CssRule, ParseError<'i>> {
-        let location = get_location_with_offset(input.current_source_location(),
+        let location = get_location_with_offset(prelude.source_location,
                                                 self.context.line_number_offset);
         let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Style));
         let declarations = parse_property_declaration_list(&context, input);
         Ok(CssRule::Style(Arc::new(self.shared_lock.wrap(StyleRule {
             selectors: prelude,
             block: Arc::new(self.shared_lock.wrap(declarations)),
             source_location: location,
         }))))
diff --git a/servo/components/style/stylist.rs b/servo/components/style/stylist.rs
--- a/servo/components/style/stylist.rs
+++ b/servo/components/style/stylist.rs
@@ -460,17 +460,17 @@ impl Stylist {
 
         self.effective_media_query_results.saw_effective(stylesheet);
 
         for rule in stylesheet.effective_rules(&self.device, guard) {
             match *rule {
                 CssRule::Style(ref locked) => {
                     let style_rule = locked.read_with(&guard);
                     self.num_declarations += style_rule.block.read_with(&guard).len();
-                    for selector_and_hashes in &style_rule.selectors.0 {
+                    for selector_and_hashes in &style_rule.selectors.selector_and_hashes {
                         self.num_selectors += 1;
 
                         let map = if let Some(pseudo) = selector_and_hashes.selector.pseudo_element() {
                             self.pseudos_map
                                 .entry(pseudo.canonical())
                                 .or_insert_with(PerPseudoElementSelectorMap::new)
                                 .borrow_for_origin(&stylesheet.origin)
                         } else {
diff --git a/servo/ports/geckolib/glue.rs b/servo/ports/geckolib/glue.rs
--- a/servo/ports/geckolib/glue.rs
+++ b/servo/ports/geckolib/glue.rs
@@ -1197,42 +1197,44 @@ pub extern "C" fn Servo_StyleRule_GetSel
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_StyleRule_GetSelectorTextAtIndex(rule: RawServoStyleRuleBorrowed,
                                                          index: u32,
                                                          result: *mut nsAString) {
     read_locked_arc(rule, |rule: &StyleRule| {
         let index = index as usize;
-        if index >= rule.selectors.0.len() {
+        if index >= rule.selectors.selector_and_hashes.len() {
             return;
         }
-        rule.selectors.0[index].selector.to_css(unsafe { result.as_mut().unwrap() }).unwrap();
+        rule.selectors.selector_and_hashes[index].selector.to_css(
+            unsafe { result.as_mut().unwrap() }
+        ).unwrap();
     })
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_StyleRule_GetSelectorCount(rule: RawServoStyleRuleBorrowed, count: *mut u32) {
     read_locked_arc(rule, |rule: &StyleRule| {
-        *unsafe { count.as_mut().unwrap() } = rule.selectors.0.len() as u32;
+        *unsafe { count.as_mut().unwrap() } = rule.selectors.selector_and_hashes.len() as u32;
     })
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_StyleRule_GetSpecificityAtIndex(rule: RawServoStyleRuleBorrowed,
                                                         index: u32,
                                                         specificity: *mut u64) {
     read_locked_arc(rule, |rule: &StyleRule| {
         let mut specificity =  unsafe { specificity.as_mut().unwrap() };
         let index = index as usize;
-        if index >= rule.selectors.0.len() {
+        if index >= rule.selectors.selector_and_hashes.len() {
             *specificity = 0;
             return;
         }
-        *specificity = rule.selectors.0[index].selector.specificity() as u64;
+        *specificity = rule.selectors.selector_and_hashes[index].selector.specificity() as u64;
     })
 }
 
 #[no_mangle]
 pub extern "C" fn Servo_ImportRule_GetHref(rule: RawServoImportRuleBorrowed, result: *mut nsAString) {
     read_locked_arc(rule, |rule: &ImportRule| {
         write!(unsafe { &mut *result }, "{}", rule.url.as_str()).unwrap();
     })
