# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  1c4eb9fbf138099d58bbacb0da858949530b13eb
Bug 1217544 - Implement one-off BackgroundSync API. Part 9: BackgroundSyncService. r=baku

diff --git a/dom/backgroundsync/BackgroundSyncChild.cpp b/dom/backgroundsync/BackgroundSyncChild.cpp
--- a/dom/backgroundsync/BackgroundSyncChild.cpp
+++ b/dom/backgroundsync/BackgroundSyncChild.cpp
@@ -104,16 +104,17 @@ BackgroundSyncChild::RecvResponse(const 
   Promise* p = GetPendingRequest(aRequestId);
   if (NS_WARN_IF(!p)) {
     // This should never happen.
     return IPC_FAIL_NO_REASON(this);
   }
 
   switch(aResponse.type()) {
     case SyncOpResponse::TSyncRegisterResponse:
+    case SyncOpResponse::TSyncRegisterOriginResponse:
       p->MaybeResolve(true);
       return IPC_OK();
     case SyncOpResponse::TSyncGetTagsResponse:
       p->MaybeResolve(aResponse.get_SyncGetTagsResponse().mTags());
       return IPC_OK();
     case SyncOpResponse::TSyncOpError:
       p->MaybeReject(
           static_cast<nsresult>(aResponse.get_SyncOpError().mCode()));
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -1,26 +1,31 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSyncParent.h"
+#include "BackgroundSyncService.h"
 
 #include "mozilla/Unused.h"
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 namespace backgroundsync {
 
+namespace {
+uint64_t sBackgroundSyncManagerParentId = 0;
+}
+
 class BackgroundSyncParent::PendingRequest final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(PendingRequest)
 
   explicit PendingRequest(const nsID& aRequestId,
                           const SyncOp& aOp)
     : mRequestId(aRequestId)
@@ -39,95 +44,121 @@ public:
 private:
   ~PendingRequest() {}
 
   const nsID mRequestId;
   const SyncOp mOp;
 };
 
 BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
-
+  : mService(BackgroundSyncService::GetOrCreate())
+  , mId(++sBackgroundSyncManagerParentId)
+  , mActorDestroyed(false)
 {
   AssertIsOnBackgroundThread();
 
   mStorageManagerIdFactory =
     StorageManagerIdFactory::Create(this, aPrincipalInfo);
+
+  mService->RegisterActor(this);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
 void
 BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
+  MOZ_ASSERT(!mActorDestroyed);
+
+  Shutdown();
 }
 
 void
+BackgroundSyncParent::Shutdown()
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mService);
+  MOZ_ASSERT(!mActorDestroyed);
+
+  mService->UnregisterActor(this);
+  mService = nullptr;
+  mPendingRequests.Clear();
+  mActorDestroyed = true;
+}
+
+mozilla::ipc::IPCResult
 BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
                                      const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
-  // XXX Progress request to BackgroundSyncService.
+  MOZ_ASSERT(mService);
+
+  return mService->Request(mId, mStorageManagerId, aRequestId, aOp) ?
+    IPC_OK() : IPC_FAIL_NO_REASON(this);
 }
 
 mozilla::ipc::IPCResult
 BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
                                   const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
   // If we haven't created a StorageManagerId for this parent yet, we
   // queue the request.
   if (!mStorageManagerId) {
     RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
     mPendingRequests.AppendElement(pendingRequest);
     return IPC_OK();
   }
 
-  ExecuteRequest(aRequestId, aOp);
-  return IPC_OK();
+  return ExecuteRequest(aRequestId, aOp) ? IPC_OK() : IPC_FAIL_NO_REASON(this);
 }
 
 mozilla::ipc::IPCResult
 BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return IPC_OK();
 }
 
 void
-BackgroundSyncParent::OnStorageManagerIdCreated(
-    StorageManagerId* aManagerId)
+BackgroundSyncParent::OnStorageManagerIdCreated(StorageManagerId* aManagerId,
+                                                StorageManagerIdFactory* aFactory,
+                                                const SyncInternalOp& aUnused)
 {
   MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(mStorageManagerIdFactory == aFactory);
   MOZ_ASSERT(!mStorageManagerId);
 
   mStorageManagerId = aManagerId;
   mStorageManagerIdFactory->RemoveListener(this);
   mStorageManagerIdFactory = nullptr;
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
     MOZ_ASSERT(mPendingRequests[i]);
     ExecuteRequest(mPendingRequests[i]->RequestId(),
                    mPendingRequests[i]->Op());
   }
   mPendingRequests.Clear();
 }
 
-void
+bool
 BackgroundSyncParent::NotifyResponse(const nsID& aRequestId,
                                      const SyncOpResponse& aResponse)
 {
   AssertIsOnBackgroundThread();
 
   Unused << SendResponse(aRequestId, aResponse);
+
+  return true;
 }
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -19,45 +19,71 @@ namespace mozilla {
 namespace ipc {
   class BackgroundParentImpl;
   class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
+class BackgroundSyncService;
+
 class BackgroundSyncParent final : public PBackgroundSyncParent
                                  , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
   friend class CreateManagerIdRunnable;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
 
   virtual mozilla::ipc::IPCResult
   RecvRequest(const nsID& aRequestId, const SyncOp& aOp) override;
 
   virtual mozilla::ipc::IPCResult
   RecvShutdown() override;
 
-  void NotifyResponse(const nsID& aRequestId,
+  bool NotifyResponse(const nsID& aRequestId,
                       const SyncOpResponse& aResponse);
 
+  uint64_t Id() const
+  {
+    return mId;
+  }
+
+  bool ActorDestroyed() const
+  {
+    return mActorDestroyed;
+  }
+
 private:
   explicit BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
-  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+  void Shutdown();
+
+  mozilla::ipc::IPCResult
+  ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
 
   // StorageManagerId method
   virtual void
-  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId,
+                            StorageManagerIdFactory* aManagerIdFactory,
+                            const SyncInternalOp& aUnused) override;
+
+  // BackgroundSyncParent objects keep BackgroundSyncService alive.
+  RefPtr<BackgroundSyncService> mService;
+
+  // The identifier will be used by the BackgroundSyncService to know
+  // which request belongs to which parent actor.
+  uint64_t mId;
+
+  bool mActorDestroyed;
 
   RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
   // We use this Id to ensure that we have a single StorageManager
   // per principal.
   RefPtr<StorageManagerId> mStorageManagerId;
 
   class PendingRequest;
   nsTArray<RefPtr<PendingRequest>> mPendingRequests;
diff --git a/dom/backgroundsync/BackgroundSyncService.cpp b/dom/backgroundsync/BackgroundSyncService.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncService.cpp
@@ -0,0 +1,688 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * This singleton object is kept alive by the BackgroundSyncParent and
+ * ServiceWorkerManagerParent instances.
+ *
+ * It proxies storage requests such as sync registrations and get tags
+ * coming from the DOM objects through the IPC actors and makes sure that
+ * the storage context is ready for them.
+ *
+ * It also observes online/offline state changes and triggers the appropriate
+ * `sync` events whenever is needed.
+ */
+
+#include "BackgroundSyncService.h"
+#include "ChromeStorageManager.h"
+#include "StorageManager.h"
+
+#include "mozilla/ipc/BackgroundUtils.h"
+#include "nsContentUtils.h"
+#include "nsIScriptSecurityManager.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+namespace {
+BackgroundSyncService* sInstance = nullptr;
+} // namespace
+
+// ----------------------------------------------------------------------------
+
+class GetStorageManagerRunnable final : public CancelableRunnable
+{
+public:
+  GetStorageManagerRunnable(BackgroundSyncService* aService,
+                            const nsString& aOrigin,
+                            const SyncInternalOp& aOp)
+    : mService(aService)
+    , mInitiatingThread(do_GetCurrentThread())
+    , mOp(aOp)
+  {
+    AssertIsOnBackgroundThread();
+
+    mOrigins.AppendElement(aOrigin);
+  }
+
+  GetStorageManagerRunnable(BackgroundSyncService* aService,
+                            const nsTArray<nsString>& aOrigins,
+                            const SyncInternalOp& aOp)
+    : mService(aService)
+    , mOrigins(aOrigins)
+    , mInitiatingThread(do_GetCurrentThread())
+    , mOp(aOp)
+  {
+    AssertIsOnBackgroundThread();
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      // The successful construction of the StorageManagerId instance ends up
+      // calling mService->OnStorageManagerIdCreated with mOp, so the operation
+      // can continue with the appropriate StorageManager.
+      RefPtr<StorageManagerIdFactory> factory =
+        StorageManagerIdFactory::Create(mService, mPrincipalInfo, mOp);
+      mService->AddStorageManagerIdFactory(factory);
+      return NS_OK;
+    }
+
+    MOZ_ASSERT(NS_IsMainThread());
+
+    nsIScriptSecurityManager *securityManager =
+      nsContentUtils::GetSecurityManager();
+    if (NS_WARN_IF(!securityManager)) {
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    // We only have more than one origin in mOrigins when we are getting the
+    // StorageManagers for a GetAll operation.
+    for (uint32_t i = 0; i < mOrigins.Length(); i++) {
+      nsCOMPtr<nsIPrincipal> principal;
+      nsresult rv = securityManager->CreateCodebasePrincipalFromOrigin(
+        NS_ConvertUTF16toUTF8(mOrigins[i]), getter_AddRefs(principal));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        continue;
+      }
+
+      MOZ_ASSERT(principal);
+
+      rv = PrincipalToPrincipalInfo(principal, &mPrincipalInfo);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        continue;
+      }
+
+      MOZ_ASSERT(mInitiatingThread);
+
+      rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        continue;
+      }
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHOD
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~GetStorageManagerRunnable() {}
+
+  RefPtr<BackgroundSyncService> mService;
+  nsTArray<nsString> mOrigins;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  const SyncInternalOp mOp;
+  PrincipalInfo mPrincipalInfo;
+};
+
+// ----------------------------------------------------------------------------
+
+class BackgroundSyncService::StorageManagerRef final
+{
+public:
+  StorageManagerRef(const uint64_t aActorId, StorageManager* aStorageManager)
+    : mActorId(aActorId)
+    , mStorageManager(aStorageManager)
+  {}
+
+  uint64_t mActorId;
+  RefPtr<StorageManager> mStorageManager;
+};
+
+void
+BackgroundSyncService::AddStorageManagerRef(const nsID& aRequestId,
+                                            const uint64_t aActorId,
+                                            StorageManager* aStorageManager)
+{
+  AssertIsOnBackgroundThread();
+
+  StorageManagerRef* ref = new StorageManagerRef(aActorId, aStorageManager);
+  mStorageManagers.Put(aRequestId, ref);
+}
+
+uint64_t
+BackgroundSyncService::ReleaseStorageManagerRef(const nsID& aRequestId)
+{
+  AssertIsOnBackgroundThread();
+
+  nsAutoPtr<StorageManagerRef> ref;
+  mStorageManagers.RemoveAndForget(aRequestId, ref);
+
+  // It is possible that we call OnRequestComplete before AddStorageManagerRef
+  if (!ref) {
+    return 0;
+  }
+  return ref->mActorId;
+}
+
+void
+BackgroundSyncService::ReleaseStorageManagerRef(const uint64_t aActorId)
+{
+  AssertIsOnBackgroundThread();
+
+  for (auto iter = mStorageManagers.Iter(); !iter.Done(); iter.Next()) {
+    StorageManagerRef* ref = iter.UserData();
+    if (ref->mActorId == aActorId) {
+      ref->mStorageManager = nullptr;
+      nsAutoPtr<StorageManagerRef> doomed;
+      mStorageManagers.RemoveAndForget(iter.Key(), doomed);
+      break;
+    }
+  }
+}
+
+// ----------------------------------------------------------------------------
+// ChromeStorageManager
+
+void
+BackgroundSyncService::AddChromeStorageRequest(const nsID& aRequestId)
+{
+  AssertIsOnBackgroundThread();
+
+  mPendingChromeStorageRequest.AppendElement(aRequestId);
+}
+
+void
+BackgroundSyncService::RemoveChromeStorageRequest(const nsID& aRequestId)
+{
+  AssertIsOnBackgroundThread();
+
+  mPendingChromeStorageRequest.RemoveElement(aRequestId);
+
+  if (mPendingChromeStorageRequest.IsEmpty()) {
+    MaybeShutdown();
+  }
+}
+
+// ----------------------------------------------------------------------------
+
+BackgroundSyncService::BackgroundSyncService()
+  : mOnlineState(OnlineStateObserver::eUnknown)
+{
+  AssertIsOnBackgroundThread();
+
+  // sInstance is a raw BackgroundSyncService*. It is kept alive by
+  // ServiceWorkerManagerParent and BackgroundSyncParent instances.
+  MOZ_ASSERT(!sInstance);
+  sInstance = this;
+}
+
+BackgroundSyncService::~BackgroundSyncService()
+{
+  MOZ_ASSERT(sInstance == this);
+  MOZ_ASSERT(mBackgroundSyncActors.Length() == 0);
+  MOZ_ASSERT(mStorageManagers.Count() == 0);
+  MOZ_ASSERT(!mChromeStorageManager);
+  MOZ_ASSERT(mPendingChromeStorageRequest.IsEmpty());
+  MOZ_ASSERT(!mOnlineStateObserver);
+
+  sInstance = nullptr;
+}
+
+// static
+already_AddRefed<BackgroundSyncService>
+BackgroundSyncService::GetOrCreate()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<BackgroundSyncService> instance = sInstance;
+  if (!instance) {
+    instance = new BackgroundSyncService();
+    instance->Init();
+  }
+  return instance.forget();
+}
+
+void
+BackgroundSyncService::Init()
+{
+  mOnlineStateObserver = OnlineStateObserver::Init(this);
+  mChromeStorageManager = ChromeStorageManager::GetOrCreate();
+}
+
+void
+BackgroundSyncService::MaybeShutdown()
+{
+  AssertIsOnBackgroundThread();
+
+  if (mBackgroundSyncActors.Length() == 0 &&
+      mServiceWorkerManagerActors.Length() == 0 &&
+      mStorageManagers.Count() == 0 &&
+      mPendingChromeStorageRequest.IsEmpty()) {
+    mOnlineStateObserver->Shutdown(this);
+    mOnlineStateObserver = nullptr;
+    mChromeStorageManager->Shutdown();
+    mChromeStorageManager = nullptr;
+  }
+}
+
+// --------------------------------------------------------------------------
+
+void
+BackgroundSyncService::RegisterActor(BackgroundSyncParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(!mBackgroundSyncActors.Contains(aParent));
+
+  mBackgroundSyncActors.AppendElement(aParent);
+}
+
+void
+BackgroundSyncService::UnregisterActor(BackgroundSyncParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(mBackgroundSyncActors.Contains(aParent));
+
+  ReleaseStorageManagerRef(aParent->Id());
+  mBackgroundSyncActors.RemoveElement(aParent);
+
+  MaybeShutdown();
+}
+
+void
+BackgroundSyncService::RegisterActor(
+    workers::ServiceWorkerManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(!mServiceWorkerManagerActors.Contains(aParent));
+
+  mServiceWorkerManagerActors.AppendElement(aParent);
+}
+
+void
+BackgroundSyncService::UnregisterActor(
+    workers::ServiceWorkerManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(mServiceWorkerManagerActors.Contains(aParent));
+
+  mServiceWorkerManagerActors.RemoveElement(aParent);
+
+  MaybeShutdown();
+}
+
+// --------------------------------------------------------------------------
+
+bool
+BackgroundSyncService::Request(const uint64_t aActorId,
+                               StorageManagerId* aManagerId,
+                               const nsID& aRequestId,
+                               const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManager> manager;
+  nsresult rv = StorageManager::GetOrCreate(this,
+                                            aManagerId,
+                                            getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return Response(aActorId, aRequestId,
+                    SyncOpError(static_cast<uint32_t>(NS_ERROR_UNEXPECTED)));
+  }
+
+  AddStorageManagerRef(aRequestId, aActorId, manager);
+
+  return manager->ExecuteRequest(aRequestId, aOp);
+}
+
+bool
+BackgroundSyncService::Response(const uint64_t aActorId,
+                                const nsID& aRequestId,
+                                const SyncOpResponse& aResponse)
+{
+  AssertIsOnBackgroundThread();
+
+  for (uint32_t i = 0, len = mBackgroundSyncActors.Length(); i < len; ++i) {
+    RefPtr<BackgroundSyncParent> parent = mBackgroundSyncActors[i];
+    MOZ_ASSERT(parent);
+
+    if (parent->Id() != aActorId) {
+      continue;
+    }
+
+    if (!parent->ActorDestroyed()) {
+      return parent->NotifyResponse(aRequestId, aResponse);
+    }
+  }
+
+  return false;
+}
+
+/**
+ * This method handles the completion of a storage request.
+ *
+ * A storage request can be external or internal.
+ *
+ * External requests are the requests triggered as part of DOM requests. So far
+ * we have these two DOM API methods:
+ * 1. Promise<void> SyncManager.register(DOMString tag)
+ * 2. Promise<sequence<DOMString>> SyncManager.getTags()
+ *
+ * A call to (1) starts a registration operation that is handled by the
+ * StorageManager in charge of the requesting origin and which completion
+ * generates a response of type SyncOpResponse::TSyncRegisterResponse. If this
+ * is the first time a sync registration is requested from that origin, we also
+ * need to start a origin registration operation that should end up with a
+ * response of type SyncOpResponse::TSyncRegisterOriginResponse.
+ *
+ * A call to (2) starts a storage operation to get all the sync registrations
+ * that we have for the requesting origin. If everything goes well, we should
+ * get a response of type SyncOpResponse::TSyncGetAllResponse.
+ *
+ * In both cases, the associated StorageManager is released if it has no more
+ * pending operations and the response is progressed to the content process
+ * through the IPC actor.
+ *
+ * Internal requests are the rest of requests and are started as part of the
+ * sync event firing process that can be started in two situations:
+ *
+ * 1. When we go from an offline to an online state.
+ * 2. Or right after registering a sync request, if we are online.
+ *
+ * In the case of (1), the first thing that we need to do is to get the list of
+ * all origins that have pending sync registrations. That should end up
+ * generating a response with type SyncOpResponse::TSyncGetAllOriginsResponse.
+ * From this point on, the process for (1) and (2) is pretty much the same.
+ * In the case of (1) we do it for each origin, in the case of (2) we just do
+ * it for a single origin (the one that registered the sync request).
+ * We need to get the list of sync requests registered for each (or for the)
+ * origin. That should give us a SyncOpResponse::TSyncGetAllResponse per origin.
+ * Per each sync registration we change its state to firing, which should give
+ * a SyncOpResponse::TSyncChangeStateResponse response and continue with the
+ * firing process. If it goes well, we end up removing the sync registration
+ * from the sync storage, which should end up with a
+ * SyncOpResponse::TSyncRemoveResponse.
+ * If in between of any of these steps of the sync event firing process we
+ * go offline, we need to cancel the process and move the sync registration
+ * back to the pending state. Which also gives us a
+ * SyncOpResponse::TSyncChangeStateResponse.
+ *
+ * After handling any of these internal responses, we end up releasing the
+ * ChromeStorageManager in charge of the request if there are no more pending
+ * storage operations.
+ */
+void
+BackgroundSyncService::OnRequestComplete(const nsID& aRequestId,
+                                         const SyncOpResponse& aResponse)
+{
+  AssertIsOnBackgroundThread();
+
+  switch (aResponse.type()) {
+    case SyncOpResponse::TSyncRegisterResponse:
+      // If this is the first registration for this origin, we need to store
+      // it in the 'origins' db before we can release the StorageManager and
+      // progress the response to the DOM side.
+      if (aResponse.get_SyncRegisterResponse().mFirstRegistration()) {
+        AddChromeStorageRequest(aRequestId);
+        mChromeStorageManager->Register(aRequestId,
+            aResponse.get_SyncRegisterResponse().mRegistration());
+        break;
+      }
+      // If this is not the first registration for this origin, we can
+      // directly try to trigger the sync event.
+      MaybeTriggerSyncEvent(
+          aResponse.get_SyncRegisterResponse().mRegistration());
+      break;
+    case SyncOpResponse::TSyncRegisterOriginResponse:
+      // Once we have registered the origin for the sync request, we can try
+      // to send the sync event.
+      MaybeTriggerSyncEvent(
+          aResponse.get_SyncRegisterOriginResponse().mRegistration());
+      break;
+    case SyncOpResponse::TSyncRemoveResponse:
+      {
+        const nsString& origin = aResponse.get_SyncRemoveResponse().mOrigin();
+        // We only get the origin value when there are no more registrations for
+        // this origin. If that's the case, we need to remove that origin from
+        // the 'origins' DB before we can progress the response to the DOM side.
+        if (!origin.IsEmpty()) {
+          AddChromeStorageRequest(aRequestId);
+          mChromeStorageManager->Unregister(aRequestId, origin);
+        }
+      }
+      break;
+    case SyncOpResponse::TSyncGetAllOriginsResponse:
+      {
+        // If we went offline while getting the origins, we don't care about
+        // getting the sync registrations anymore, so we bail out here.
+        if (mOnlineState !=  OnlineStateObserver::eOnline) {
+          break;
+        }
+
+        // If we are still online, we need to get the list of sync registrations
+        // per origin. To do that we first need to get the corresponding
+        // StorageManager for each origin by jumping to the main thread.
+        // Once we have each appropriate StorageManager, the GetAll operation
+        // will be executed at OnStorageManagerIdCreated. That's why we pass here
+        // the SyncInteralOp with SyncGetAllArgs.
+        const nsTArray<nsString>& origins =
+          aResponse.get_SyncGetAllOriginsResponse().mOrigins();
+        RefPtr<GetStorageManagerRunnable> runnable =
+          new GetStorageManagerRunnable(this, origins,
+              SyncInternalOp(SyncGetAllArgs()));
+        nsresult rv = NS_DispatchToMainThread(runnable);
+        if (NS_FAILED(rv)) { NS_WARNING("NS_DispatchToMainThread failed"); }
+      }
+      break;
+    case SyncOpResponse::TSyncGetAllResponse:
+      {
+        // If we went offline while getting the sync registrations, it is
+        // useless to continue, as no sync event will be triggered for these
+        // registrations. So we just bail out here.
+        if (mOnlineState !=  OnlineStateObserver::eOnline) {
+          break;
+        }
+
+        // If we are still online, we try to trigger a sync event per each
+        // registration.
+        const nsTArray<Registration>& registrations =
+            aResponse.get_SyncGetAllResponse().mRegistrations();
+        for (uint32_t i = 0; i < registrations.Length(); i++) {
+          MaybeTriggerSyncEvent(registrations[i]);
+        }
+      }
+      break;
+    case SyncOpResponse::TSyncChangeStateResponse:
+      {
+        // For now we only care about a change of state to eFiring.
+        Registration registration =
+          aResponse.get_SyncChangeStateResponse().mRegistration();
+        if (registration.mState() != RegistrationState::eFiring) {
+          break;
+        }
+
+        // If we changed the state to eFiring, that means that we are trying to
+        // trigger a sync event for a specific registration.
+        // In that case, we need to check if we still are online and so we can
+        // continue with the process of firing the sync event. Otherwise, we
+        // need to get back to the ePending state and bail out here.
+        if (mOnlineState != OnlineStateObserver::eOnline) {
+          RefPtr<GetStorageManagerRunnable> runnable =
+            new GetStorageManagerRunnable(this, registration.mOrigin(),
+                SyncInternalOp(SyncChangeStateArgs(registration.mId(),
+                               RegistrationState::ePending)));
+          nsresult rv = NS_DispatchToMainThread(runnable);
+          if (NS_FAILED(rv)) { NS_WARNING("NS_DispatchToMainThread failed"); }
+          break;
+        }
+
+        ContinueTriggeringSyncEvent(registration);
+      }
+      break;
+    default:
+      break;
+  }
+
+  uint64_t actorId = ReleaseStorageManagerRef(aRequestId);
+  if (actorId) {
+    // If we have an actor ID, this is a DOM request which response needs to be
+    // reported back to the content process through the IPC actor.
+    Response(actorId, aRequestId, aResponse);
+  } else {
+    // Otherwise, this is a response to an internal request and we just need to
+    // remove the request from the pending request list.
+    RemoveChromeStorageRequest(aRequestId);
+  }
+}
+
+// --------------------------------------------------------------------------
+
+void
+BackgroundSyncService::MaybeTriggerSyncEvent(const Registration& aRegistration)
+{
+  AssertIsOnBackgroundThread();
+
+  if (mOnlineState !=  OnlineStateObserver::eOnline) {
+    return;
+  }
+
+  // First thing we need to do is to change the state of the registration to
+  // eFiring.
+
+  // We only can do that if the registration is in ePending state though.
+  if (NS_WARN_IF(aRegistration.mState() != RegistrationState::ePending)) {
+    return;
+  }
+
+  // We need to get the appropriate StorageManager for the registration origin,
+  // so we need to jump to the main thread for that.
+  RefPtr<GetStorageManagerRunnable> runnable =
+    new GetStorageManagerRunnable(this, aRegistration.mOrigin(), SyncInternalOp(
+      SyncChangeStateArgs(aRegistration.mId(),RegistrationState::eFiring)
+    ));
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) { NS_WARNING("NS_DispatchToMainThread failed"); }
+}
+
+void
+BackgroundSyncService::ContinueTriggeringSyncEvent(
+    const Registration& aRegistration)
+{
+  AssertIsOnBackgroundThread();
+
+  if (mOnlineState != OnlineStateObserver::eOnline) {
+    if (aRegistration.mState() == RegistrationState::eFiring) {
+      RefPtr<GetStorageManagerRunnable> runnable =
+        new GetStorageManagerRunnable(this, aRegistration.mOrigin(), SyncInternalOp(
+          SyncChangeStateArgs(aRegistration.mId(),RegistrationState::eFiring)
+        ));
+      nsresult rv = NS_DispatchToMainThread(runnable);
+      if (NS_FAILED(rv)) { NS_WARNING("NS_DispatchToMainThread failed"); }
+    }
+    return;
+  }
+
+  for (uint32_t i = 0, len = mServiceWorkerManagerActors.Length(); i < len; ++i) {
+    RefPtr<ServiceWorkerManagerParent> parent = mServiceWorkerManagerActors[i];
+    MOZ_ASSERT(parent);
+    Unused << parent->SendNotifyBackgroundSyncEvent(aRegistration.mOrigin(),
+                                                    aRegistration.mScope(),
+                                                    aRegistration.mTag(),
+                                                    aRegistration.mLastChance());
+  }
+
+  // XXX Bug 1260141. For now we simply remove the sync registration, but
+  // we need to implement the sync event handling logic.
+  //
+  RefPtr<GetStorageManagerRunnable> runnable =
+    new GetStorageManagerRunnable(this, aRegistration.mOrigin(),
+        SyncInternalOp(SyncRemoveArgs(aRegistration.mId())));
+  nsresult rv = NS_DispatchToMainThread(runnable);
+  if (NS_FAILED(rv)) { NS_WARNING("NS_DispatchToMainThread failed"); }
+}
+
+// --------------------------------------------------------------------------
+
+/**
+ * OnlineStateObserver::Listener implementation.
+ */
+
+void
+BackgroundSyncService::OnOnlineStateChanged(
+  OnlineStateObserver::OnlineState aState)
+{
+  AssertIsOnBackgroundThread();
+
+  mOnlineState = aState;
+
+  if (mOnlineState != OnlineStateObserver::eOnline) {
+    return;
+  }
+
+  // If we are online, we need to get the list of sync registrations and
+  // trigger the corresponding sync events.
+
+  nsID id;
+  nsresult rv = nsContentUtils::GenerateUUIDInPlace(id);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  AddChromeStorageRequest(id);
+  mChromeStorageManager->GetAll(id);
+}
+
+// --------------------------------------------------------------------------
+
+/**
+ * StorageManagerIdFactory::Listener implementation.
+ */
+void
+BackgroundSyncService::OnStorageManagerIdCreated(
+  StorageManagerId* aManagerId, StorageManagerIdFactory* aFactory,
+  const SyncInternalOp& aOp)
+{
+  MOZ_ASSERT(mStorageManagerIdFactories.Contains(aFactory));
+
+  aFactory->RemoveListener(this);
+  mStorageManagerIdFactories.RemoveEntry(aFactory);
+
+  RefPtr<StorageManager> manager;
+  nsresult rv = StorageManager::GetOrCreate(this,
+                                            aManagerId,
+                                            getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  nsCOMPtr<nsIUUIDGenerator> uuidGenerator =
+    do_GetService("@mozilla.org/uuid-generator;1", &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  nsID id;
+  rv = uuidGenerator->GenerateUUIDInPlace(&id);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return;
+  }
+
+  AddStorageManagerRef(id, 0 /* internal request */, manager);
+
+  manager->ExecuteRequest(id, aOp);
+}
+
+void
+BackgroundSyncService::AddStorageManagerIdFactory(
+    StorageManagerIdFactory* aFactory)
+{
+  mStorageManagerIdFactories.PutEntry(aFactory);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncService.h b/dom/backgroundsync/BackgroundSyncService.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncService.h
@@ -0,0 +1,129 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+* You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncService_h
+#define mozilla_dom_BackgroundSyncService_h
+
+#include "nsClassHashtable.h"
+#include "nsRefPtrHashtable.h"
+#include "OnlineStateObserver.h"
+#include "ServiceWorkerManagerParent.h"
+#include "StorageManagerId.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace workers {
+class ServiceWorkerManagerParent;
+} // namespace workers
+
+namespace backgroundsync {
+
+class BackgroundSyncParent;
+class ChromeStorageManager;
+class Registration;
+class StorageManager;
+class SyncOp;
+
+class BackgroundSyncService final : public OnlineStateObserver::Listener
+                                  , public StorageManagerIdFactory::Listener
+{
+  friend class ChromeStorageManager;
+  friend class StorageManager;
+  friend class GetStorageManagerRunnable;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(BackgroundSyncService)
+
+  static already_AddRefed<BackgroundSyncService> GetOrCreate();
+
+  void RegisterActor(BackgroundSyncParent* aParent);
+  void UnregisterActor(BackgroundSyncParent* aParent);
+
+  void RegisterActor(workers::ServiceWorkerManagerParent* aParent);
+  void UnregisterActor(workers::ServiceWorkerManagerParent* aParent);
+
+  bool
+  Request(const uint64_t aActorId, StorageManagerId* aManagerId,
+          const nsID& aRequestId, const SyncOp& aOp);
+
+private:
+  BackgroundSyncService();
+  ~BackgroundSyncService();
+
+  void Init();
+  void MaybeShutdown();
+
+  // --------------------------------------------------------------------------
+
+  bool
+  Response(const uint64_t aActorId, const nsID& aRequestId,
+           const SyncOpResponse& aResponse);
+
+  void OnRequestComplete(const nsID& aRequestId,
+                         const SyncOpResponse& aResponse);
+
+  // --------------------------------------------------------------------------
+
+  void MaybeTriggerSyncEvent(const Registration& aRegistration);
+  void ContinueTriggeringSyncEvent(const Registration& aRegistration);
+
+  // --------------------------------------------------------------------------
+
+  nsTArray<RefPtr<BackgroundSyncParent>> mBackgroundSyncActors;
+  nsTArray<RefPtr<workers::ServiceWorkerManagerParent>>
+    mServiceWorkerManagerActors;
+
+  // --------------------------------------------------------------------------
+  // StorageManager
+
+  void AddStorageManagerRef(const nsID& aRequestId,
+                            const uint64_t aActorId,
+                            StorageManager* aStorageManager);
+  uint64_t ReleaseStorageManagerRef(const nsID& aRequestId);
+  void ReleaseStorageManagerRef(const uint64_t aActorId);
+
+  // References to StorageManagers managing content principals.
+  // For each content origin, we will have a separated registrations DB
+  // where we will store the specific information of each registration.
+  class StorageManagerRef;
+  nsClassHashtable<nsIDHashKey, StorageManagerRef> mStorageManagers;
+
+  // --------------------------------------------------------------------------
+  // ChromeStorageManager
+
+  RefPtr<ChromeStorageManager> mChromeStorageManager;
+  nsTArray<nsID> mPendingChromeStorageRequest;
+
+  void AddChromeStorageRequest(const nsID& aRequestId);
+  void RemoveChromeStorageRequest(const nsID& aRequestId);
+
+  // --------------------------------------------------------------------------
+  // OnlineStateObserver::Listener method
+
+  virtual void
+  OnOnlineStateChanged(OnlineStateObserver::OnlineState aState) override;
+
+  RefPtr<OnlineStateObserver> mOnlineStateObserver;
+  OnlineStateObserver::OnlineState mOnlineState;
+
+  // --------------------------------------------------------------------------
+  // StorageManagerId
+
+  void AddStorageManagerIdFactory(StorageManagerIdFactory* aFactory);
+  void OnStorageManagerIdCreated(StorageManagerId* aManagerId,
+                                 StorageManagerIdFactory* aFactory,
+                                 const SyncInternalOp& aOp) override;
+
+  nsTHashtable<nsRefPtrHashKey<StorageManagerIdFactory>>
+    mStorageManagerIdFactories;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncService_h
diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
--- a/dom/backgroundsync/ChromeStorageManager.cpp
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -428,30 +428,33 @@ ChromeStorageManager::GetOrCreate()
   RefPtr<ChromeStorageManager> instance = csmInstance;
   if (!instance) {
     instance = new ChromeStorageManager();
   }
   return instance.forget();
 }
 
 ChromeStorageManager::ChromeStorageManager()
-  : mShuttingDown(false)
+  : mService(BackgroundSyncService::GetOrCreate())
+  , mShuttingDown(false)
 {
   AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mService);
 
   Init();
 }
 
 ChromeStorageManager::~ChromeStorageManager()
 {
   MOZ_ASSERT(!mShutdownObserver);
   MOZ_ASSERT(!mDBConn);
   MOZ_ASSERT(mPendingActions.IsEmpty());
 
   csmInstance = nullptr;
+  mService = nullptr;
 }
 
 void
 ChromeStorageManager::Init()
 {
   AssertIsOnBackgroundThread();
 
   // During the initialization process we create the IO thread and jump to
@@ -572,15 +575,16 @@ ChromeStorageManager::GetAll(const nsID&
   ExecuteStorageAction(action);
 }
 
 void
 ChromeStorageManager::OnRequestComplete(const nsID& aRequestId,
                                         const SyncOpResponse& aResponse)
 {
   AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mService);
 
-  // XXX Notify listener.
+  mService->OnRequestComplete(aRequestId, aResponse);
 }
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/ChromeStorageManager.h b/dom/backgroundsync/ChromeStorageManager.h
--- a/dom/backgroundsync/ChromeStorageManager.h
+++ b/dom/backgroundsync/ChromeStorageManager.h
@@ -26,16 +26,17 @@ namespace dom {
 namespace backgroundsync {
 
 class ChromeStorageAction;
 class Registration;
 class XPCOMShutdownObserver;
 
 class ChromeStorageManager final
 {
+  friend class BackgroundSyncService;
   friend class ContinueInitRunnable;
   friend class ContinueShutdownRunnable;
   friend class StorageActionRunnable;
   friend class XPCOMShutdownObserver;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageManager)
 
@@ -56,16 +57,18 @@ private:
   void Shutdown();
   void FinishShutdown();
 
   void ExecuteStorageAction(ChromeStorageAction* aAction);
 
   void OnRequestComplete(const nsID& aRequestId,
                          const SyncOpResponse& aResponse);
 
+  RefPtr<BackgroundSyncService> mService;
+
   RefPtr<XPCOMShutdownObserver> mShutdownObserver;
 
   nsCOMPtr<nsIThread> mIOThread;
   nsCOMPtr<mozIStorageConnection> mDBConn;
 
   nsTArray<RefPtr<ChromeStorageAction>> mPendingActions;
 
   bool mShuttingDown;
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -47,17 +47,18 @@ public:
 // Singleton class to track StorageManager instances and ensure there is only
 // one for each unique StorageManagerId.
 class StorageManager::Factory
 {
 public:
   friend class StaticAutoPtr<StorageManager::Factory>;
 
   static nsresult
-  GetOrCreate(StorageManagerId* aManagerId,
+  GetOrCreate(BackgroundSyncService* aService,
+              StorageManagerId* aManagerId,
               StorageManager** aManagerOut)
   {
     AssertIsOnBackgroundThread();
 
     // Ensure there is a factory instance. This forces the Get() call
     // below to use the same factory.
     nsresult rv = MaybeCreateInstance();
     if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -67,17 +68,17 @@ public:
     RefPtr<StorageManager> ref = Get(aManagerId);
     if (!ref) {
       nsCOMPtr<nsIThread> ioThread;
       rv = NS_NewNamedThread("BSyncIOThread", getter_AddRefs(ioThread));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
 
-      ref = new StorageManager(aManagerId, ioThread);
+      ref = new StorageManager(aService, aManagerId, ioThread);
 
       // There may be an old manager for this origin in the process of
       // cleaning up.  We need to tell the new manager about this so
       // that it won't actually start until the old manager is done.
       RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
       ref->Init(oldManager);
 
       MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
@@ -493,21 +494,22 @@ private:
   SyncChangeStateArgs mArgs;
   Registration mRegistration;
 };
 
 // ---------------------------------------------------------------------------
 
 // static
 nsresult
-StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+StorageManager::GetOrCreate(BackgroundSyncService* aService,
+                            StorageManagerId* aManagerId,
                             StorageManager** aManagerOut)
 {
   AssertIsOnBackgroundThread();
-  return Factory::GetOrCreate(aManagerId, aManagerOut);
+  return Factory::GetOrCreate(aService, aManagerId, aManagerOut);
 }
 
 // static
 void
 StorageManager::ShutdownAll()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
@@ -524,38 +526,43 @@ StorageManager::ShutdownAll()
 void
 StorageManager::Abort(const nsACString& aOrigin)
 {
  mozilla::ipc::AssertIsOnBackgroundThread();
 
  Factory::Abort(aOrigin);
 }
 
-StorageManager::StorageManager(StorageManagerId* aManagerId,
+StorageManager::StorageManager(BackgroundSyncService* aService,
+                               StorageManagerId* aManagerId,
                                nsIThread* aIOThread)
-  : mManagerId(aManagerId)
+  : mService(aService)
+  , mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
   , mShuttingDown(false)
   , mState(Open)
 {
+  MOZ_ASSERT(mService);
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
 }
 
 StorageManager::~StorageManager()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mState == Closing);
   MOZ_ASSERT(!mContext);
 
   nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));
+
+  mService = nullptr;
 }
 
 void
 StorageManager::Init(StorageManager* aOldManager)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
 
   RefPtr<ClientContext> oldContext;
@@ -667,39 +674,41 @@ StorageManager::MaybeAllowContextToClose
     // Mark the StorageManager as invalid so that it won't get used again.
     NoteClosing();
 
     context->AllowToClose();
   }
 }
 
 // Common to DOM and internal requests.
-void
+bool
 StorageManager::ExecuteRequest(const nsID& aRequestId, ClientAction* aAction)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
   MOZ_ASSERT(aAction);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
     OnRequestComplete(aRequestId,
                       SyncOpError(static_cast<uint32_t>(NS_ERROR_ABORT)));
-    return;
+    return false;
   }
 
   RefPtr<ClientContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   context->Dispatch(aAction);
+
+  return true;
 }
 
 // DOM request.
-void
+bool
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
 {
   RefPtr<ClientAction> action;
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       action = new RegisterAction(aRequestId, this,
@@ -713,17 +722,17 @@ StorageManager::ExecuteRequest(const nsI
       break;
     }
     default:
     {
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
 
-  ExecuteRequest(aRequestId, action);
+  return ExecuteRequest(aRequestId, action);
 }
 
 // Internal request.
 void
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp)
 {
   RefPtr<ClientAction> action;
 
@@ -761,20 +770,20 @@ StorageManager::OnRequestComplete(const 
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mPendingRequests.Contains(aRequestId));
 
   mPendingRequests.RemoveElement(aRequestId);
 
   MaybeAllowContextToClose();
 }
 
-template<typename T>
 void
-StorageManager::OnRequestComplete(const nsID& aRequestId, const T& aResponse)
+StorageManager::OnRequestComplete(const nsID& aRequestId,
+                                  const SyncOpResponse& aResponse)
 {
-  // XXX Notify listener
+  mService->OnRequestComplete(aRequestId, SyncOpResponse(aResponse));
 
   OnRequestComplete(aRequestId);
 }
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
--- a/dom/backgroundsync/StorageManager.h
+++ b/dom/backgroundsync/StorageManager.h
@@ -9,16 +9,17 @@
 
 #include "mozilla/dom/quota/shared/ClientContext.h"
 
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
 using quota::shared::ClientContext;
+using quota::shared::ClientAction;
 
 /**
  * The StorageManager class is responsible for managing the storage of sync
  * requests. The DOM objects and IPC actors are basically just plumbing to
  * get the request to the right StorageManager object running in the parent
  * process.
  *
  * There should be exactly one StorageManager object for each origin or app
@@ -28,20 +29,23 @@ using quota::shared::ClientContext;
  *
  * The StorageManager instances are kept alive by the BackgroundSyncService,
  * which keeps a reference to the StorageManager dealing with a storage request
  * until that request is completed or the actor requesting it is destroyed.
  */
 
 class StorageManager final : public ClientContext::Listener
 {
+  friend class BackgroundSyncService;
+
 public:
   NS_INLINE_DECL_REFCOUNTING(StorageManager, override)
 
-  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+  static nsresult GetOrCreate(BackgroundSyncService* aService,
+                              StorageManagerId* aManagerId,
                               StorageManager** aManagerOut);
 
   enum State
   {
     Open,
     Closing
   };
 
@@ -57,49 +61,52 @@ public:
   }
 
   // Synchronously shutdown.  This spins the event loop.
   static void ShutdownAll();
 
   // Cancel actions for given origin or all actions if passed string is null.
   static void Abort(const nsACString& aOrigin);
 
-  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+  bool ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
 
   // quota::ClientContext::Listener
   virtual void NoteClosing() override;
   virtual void RemoveClientContext(ClientContext* aContext) override;
   virtual already_AddRefed<nsIPrincipal> GetPrincipal() const override;
 
 private:
   class BaseAction;
   class ChangeStateAction;
   class Factory;
   class GetAllAction;
   class GetTagsAction;
   class RegisterAction;
   class RemoveAction;
 
-  StorageManager(StorageManagerId* aManagerId,
+  StorageManager(BackgroundSyncService* aService,
+                 StorageManagerId* aManagerId,
                  nsIThread* aIOThread);
   ~StorageManager();
 
   void Init(StorageManager* aOldManager);
   void Abort();
   void Shutdown();
 
   void MaybeAllowContextToClose();
 
   void OnRequestComplete(const nsID& aRequestId);
-  template<typename T>
-  void OnRequestComplete(const nsID& aRequestId, const T& aResponse);
+  void OnRequestComplete(const nsID& aRequestId,
+                         const SyncOpResponse& aResponse);
 
-  void ExecuteRequest(const nsID& aRequestId, ClientAction* aAction);
+  bool ExecuteRequest(const nsID& aRequestId, ClientAction* aAction);
   void ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp);
 
+  RefPtr<BackgroundSyncService> mService;
+
   RefPtr<StorageManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
   // Weak reference cleared by RemoveClientContext() in ClientContext
   // destructor.
   ClientContext* MOZ_NON_OWNING_REF mContext;
 
   bool mShuttingDown;
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
--- a/dom/backgroundsync/StorageManagerId.cpp
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -17,31 +17,43 @@ namespace backgroundsync {
  * StorageManagerIdFactory
  */
 
 // static
 already_AddRefed<StorageManagerIdFactory>
 StorageManagerIdFactory::Create(Listener* aListener,
                                 const PrincipalInfo& aPrincipalInfo)
 {
+  return StorageManagerIdFactory::Create(aListener, aPrincipalInfo,
+                                         SyncInternalOp(void_t()));
+}
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo,
+                                const SyncInternalOp& aOp)
+{
   AssertIsOnBackgroundThread();
 
   RefPtr<StorageManagerIdFactory> factory =
-    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+    new StorageManagerIdFactory(aListener, aPrincipalInfo, aOp);
 
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(NewRunnableMethod(factory,
                                               &StorageManagerIdFactory::Run)));
 
   return factory.forget();
 }
 
 StorageManagerIdFactory::StorageManagerIdFactory(
-    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo,
+    const SyncInternalOp& aOp)
   : mPrincipalInfo(aPrincipalInfo)
   , mInitiatingThread(NS_GetCurrentThread())
+  , mOp(aOp)
 {
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(mInitiatingThread);
   MOZ_ASSERT(aListener);
 
   mListenerList.AppendElement(aListener);
 }
 
@@ -60,17 +72,17 @@ StorageManagerIdFactory::Run()
   // Execute twice. First on the main thread and then back on the originating
   // thread.
 
   if (mManagerId) {
     AssertIsOnBackgroundThread();
 
     ListenerList::ForwardIterator iter(mListenerList);
     while (iter.HasMore()) {
-      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId, this, mOp);
     }
 
     // The listener must clear its reference in
     // OnStorageManagerIdCreated().
     MOZ_ASSERT(mListenerList.IsEmpty());
 
     return;
   }
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
--- a/dom/backgroundsync/StorageManagerId.h
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -2,16 +2,19 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_StorageManagerId_h
 #define mozilla_dom_StorageManagerId_h
 
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
+#include "nsTObserverArray.h"
+
 namespace mozilla {
 namespace dom {
 namespace backgroundsync {
 
 using mozilla::ipc::PrincipalInfo;
 
 class StorageManagerId final
 {
@@ -53,41 +56,49 @@ public:
   // An interface to be implemented by code wishing to use the
   // StorageManagerIdFactory.
   // Note, the Listener implementation is responsible for calling
   // RemoveListener() on the StorageManagerIdFactory to clear the weak
   // reference.
   class Listener
   {
   public:
-    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId,
+                                           StorageManagerIdFactory* aFactory,
+                                           const SyncInternalOp& aOp) = 0;
   };
 
   static already_AddRefed<StorageManagerIdFactory>
   Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
 
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo,
+         const SyncInternalOp& aOp);
+
   // The Listener must call RemoveListener() when
   // OnStorageManagerIdCreated is called or when
   // the Listener is destroyed.
   void RemoveListener(Listener* aListener);
 
   void Run();
 
 private:
   StorageManagerIdFactory(Listener* aListener,
-                          const PrincipalInfo& aPrincipalInfo);
+                          const PrincipalInfo& aPrincipalInfo,
+                          const SyncInternalOp& aOp);
   virtual ~StorageManagerIdFactory();
 
   // Weak reference cleared by RemoveListener().
   typedef nsTObserverArray<Listener*> ListenerList;
   ListenerList mListenerList;
 
   const PrincipalInfo mPrincipalInfo;
   RefPtr<nsIThread> mInitiatingThread;
   RefPtr<StorageManagerId> mManagerId;
+  const SyncInternalOp mOp;
 
 public:
   NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerIdFactory)
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -1,23 +1,25 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.backgroundsync += [
     'BackgroundSync.h',
+    'BackgroundSyncService.h',
     'BackgroundSyncTypes.h',
     'QuotaClient.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
     'BackgroundSyncParent.cpp',
+    'BackgroundSyncService.cpp',
     'ChromeDBSchema.cpp',
     'ChromeStorageManager.cpp',
     'DBAction.cpp',
     'DBSchema.cpp',
     'OnlineStateObserver.cpp',
     'QuotaClient.cpp',
     'StorageManager.cpp',
     'StorageManagerId.cpp'
diff --git a/dom/workers/PServiceWorkerManager.ipdl b/dom/workers/PServiceWorkerManager.ipdl
--- a/dom/workers/PServiceWorkerManager.ipdl
+++ b/dom/workers/PServiceWorkerManager.ipdl
@@ -32,17 +32,17 @@ parent:
   async Shutdown();
 
 child:
   async NotifyRegister(ServiceWorkerRegistrationData data);
   async NotifySoftUpdate(OriginAttributes originAttributes, nsString scope);
   async NotifyUnregister(PrincipalInfo principalInfo, nsString scope);
   async NotifyRemove(nsCString host);
   async NotifyRemoveAll();
-  async NotifyBackgroundSyncEvent(PrincipalInfo principalInfo,
+  async NotifyBackgroundSyncEvent(nsString origin,
                                   nsString scope,
                                   nsString tag,
                                   bool lastChance);
   async __delete__();
 };
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManager.cpp b/dom/workers/ServiceWorkerManager.cpp
--- a/dom/workers/ServiceWorkerManager.cpp
+++ b/dom/workers/ServiceWorkerManager.cpp
@@ -1110,17 +1110,17 @@ ServiceWorkerManager::SendNotificationCl
 NS_IMETHODIMP
 ServiceWorkerManager::SendBackgroundSyncEvent(const nsACString& aOrigin,
                                               const nsACString& aScope,
                                               const nsAString& aTag,
                                               const bool aLastChance)
 {
   nsAutoCString originNoSuffix;
   OriginAttributes attrs;
-  if (!attrs.PopulateFromOrigin(aOrigin, originNoSuffix)) {
+  if (NS_WARN_IF(!attrs.PopulateFromOrigin(aOrigin, originNoSuffix))) {
     return NS_ERROR_INVALID_ARG;
   }
 
   ServiceWorkerInfo* serviceWorker =
     GetActiveWorkerInfoForScope(attrs, aScope);
   if (NS_WARN_IF(!serviceWorker)) {
     return NS_ERROR_FAILURE;
   }
diff --git a/dom/workers/ServiceWorkerManagerChild.cpp b/dom/workers/ServiceWorkerManagerChild.cpp
--- a/dom/workers/ServiceWorkerManagerChild.cpp
+++ b/dom/workers/ServiceWorkerManagerChild.cpp
@@ -99,38 +99,27 @@ ServiceWorkerManagerChild::RecvNotifyRem
     swm->RemoveAll();
   }
 
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerChild::RecvNotifyBackgroundSyncEvent(
-    const PrincipalInfo& aPrincipalInfo, const nsString& aScope,
+    const nsString& aOrigin, const nsString& aScope,
     const nsString& aTag, const bool& aLastChance)
 {
   if (mShuttingDown) {
     return IPC_OK();
   }
 
-  nsCOMPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(aPrincipalInfo);
-  if (NS_WARN_IF(!principal)) {
-    return IPC_OK();
-  }
-
-  nsAutoCString originSuffix;
-  nsresult rv = principal->GetOriginSuffix(originSuffix);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return IPC_OK();
-  }
-
   RefPtr<ServiceWorkerManager> swm = ServiceWorkerManager::GetInstance();
   MOZ_ASSERT(swm);
 
-  swm->SendBackgroundSyncEvent(originSuffix,
+  swm->SendBackgroundSyncEvent(NS_ConvertUTF16toUTF8(aOrigin),
                                NS_ConvertUTF16toUTF8(aScope),
                                aTag, aLastChance);
   return IPC_OK();
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManagerChild.h b/dom/workers/ServiceWorkerManagerChild.h
--- a/dom/workers/ServiceWorkerManagerChild.h
+++ b/dom/workers/ServiceWorkerManagerChild.h
@@ -41,17 +41,17 @@ public:
 
   virtual mozilla::ipc::IPCResult RecvNotifyUnregister(const PrincipalInfo& aPrincipalInfo,
                                                        const nsString& aScope) override;
 
   virtual mozilla::ipc::IPCResult RecvNotifyRemove(const nsCString& aHost) override;
 
   virtual mozilla::ipc::IPCResult RecvNotifyRemoveAll() override;
 
-  virtual mozilla::ipc::IPCResult RecvNotifyBackgroundSyncEvent(const PrincipalInfo& aPrincipalInfo,
+  virtual mozilla::ipc::IPCResult RecvNotifyBackgroundSyncEvent(const nsString& aOrigin,
                                                                 const nsString& aScope,
                                                                 const nsString& aTag,
                                                                 const bool& aLastChance) override;
 
 private:
   ServiceWorkerManagerChild()
     : mShuttingDown(false)
   {}
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -1,14 +1,15 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "BackgroundSyncService.h"
 #include "ServiceWorkerManagerParent.h"
 #include "ServiceWorkerManagerService.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/Unused.h"
 #include "nsThreadUtils.h"
@@ -155,21 +156,23 @@ private:
   PrincipalInfo mPrincipalInfo;
   RefPtr<Runnable> mCallback;
   nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
 } // namespace
 
 ServiceWorkerManagerParent::ServiceWorkerManagerParent()
-  : mService(ServiceWorkerManagerService::GetOrCreate())
+  : mServiceWorkerService(ServiceWorkerManagerService::GetOrCreate())
+  , mBackgroundSyncService(backgroundsync::BackgroundSyncService::GetOrCreate())
   , mID(++sServiceWorkerManagerParentID)
 {
   AssertIsOnBackgroundThread();
-  mService->RegisterActor(this);
+  mServiceWorkerService->RegisterActor(this);
+  mBackgroundSyncService->RegisterActor(this);
 }
 
 ServiceWorkerManagerParent::~ServiceWorkerManagerParent()
 {
   AssertIsOnBackgroundThread();
 }
 
 mozilla::ipc::IPCResult
@@ -241,87 +244,96 @@ ServiceWorkerManagerParent::RecvUnregist
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerParent::RecvPropagateSoftUpdate(const OriginAttributes& aOriginAttributes,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
-  mService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
+  mServiceWorkerService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerParent::RecvPropagateUnregister(const PrincipalInfo& aPrincipalInfo,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
-  mService->PropagateUnregister(mID, aPrincipalInfo, aScope);
+  mServiceWorkerService->PropagateUnregister(mID, aPrincipalInfo, aScope);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerParent::RecvPropagateRemove(const nsCString& aHost)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
-  mService->PropagateRemove(mID, aHost);
+  mServiceWorkerService->PropagateRemove(mID, aHost);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerParent::RecvPropagateRemoveAll()
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
-  mService->PropagateRemoveAll(mID);
+  mServiceWorkerService->PropagateRemoveAll(mID);
   return IPC_OK();
 }
 
 mozilla::ipc::IPCResult
 ServiceWorkerManagerParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return IPC_FAIL_NO_REASON(this);
   }
 
-  mService->UnregisterActor(this);
-  mService = nullptr;
+  mServiceWorkerService->UnregisterActor(this);
+  mServiceWorkerService = nullptr;
+
+  if (mBackgroundSyncService) {
+    mBackgroundSyncService->UnregisterActor(this);
+    mBackgroundSyncService = nullptr;
+  }
 
   Unused << Send__delete__(this);
   return IPC_OK();
 }
 
 void
 ServiceWorkerManagerParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 
-  if (mService) {
-    // This object is about to be released and with it, also mService will be
-    // released too.
-    mService->UnregisterActor(this);
+  if (mServiceWorkerService) {
+    // This object is about to be released and with it, also
+    // mServiceWorkerService will be released too.
+    mServiceWorkerService->UnregisterActor(this);
+  }
+
+  if (mBackgroundSyncService) {
+    mBackgroundSyncService->UnregisterActor(this);
   }
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManagerParent.h b/dom/workers/ServiceWorkerManagerParent.h
--- a/dom/workers/ServiceWorkerManagerParent.h
+++ b/dom/workers/ServiceWorkerManagerParent.h
@@ -13,16 +13,21 @@ namespace mozilla {
 
 class OriginAttributes;
 
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
 
 namespace dom {
+
+namespace backgroundsync {
+class BackgroundSyncService;
+}
+
 namespace workers {
 
 class ServiceWorkerManagerService;
 
 class ServiceWorkerManagerParent final : public PServiceWorkerManagerParent
 {
   friend class mozilla::ipc::BackgroundParentImpl;
 
@@ -53,17 +58,18 @@ private:
   virtual mozilla::ipc::IPCResult RecvPropagateRemove(const nsCString& aHost) override;
 
   virtual mozilla::ipc::IPCResult RecvPropagateRemoveAll() override;
 
   virtual mozilla::ipc::IPCResult RecvShutdown() override;
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
-  RefPtr<ServiceWorkerManagerService> mService;
+  RefPtr<ServiceWorkerManagerService> mServiceWorkerService;
+  RefPtr<backgroundsync::BackgroundSyncService> mBackgroundSyncService;
 
   // We use this ID in the Service in order to avoid the sending of messages to
   // ourself.
   uint64_t mID;
 };
 
 } // namespace workers
 } // namespace dom
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -88,16 +88,17 @@ UNIFIED_SOURCES += [
 IPDL_SOURCES += [
     'PServiceWorkerManager.ipdl',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
+    '/dom/backgroundsync',
     '/dom/base',
     '/xpcom/build',
     '/xpcom/threads',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
