# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  b3dd7ca23f6319b797581b50d8c7e5f958c669a1
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: SyncService. r=baku

diff --git a/dom/sync/SyncIPCTypes.ipdlh b/dom/sync/SyncIPCTypes.ipdlh
--- a/dom/sync/SyncIPCTypes.ipdlh
+++ b/dom/sync/SyncIPCTypes.ipdlh
@@ -48,10 +48,8 @@ union SyncOpResponse
 {
   SyncRegisterResponse;
   SyncGetTagsResponse;
   SyncOpError;
 };
 
 } // namespace dom
 } // namespace mozilla
-
-
diff --git a/dom/sync/SyncManagerParent.cpp b/dom/sync/SyncManagerParent.cpp
--- a/dom/sync/SyncManagerParent.cpp
+++ b/dom/sync/SyncManagerParent.cpp
@@ -1,73 +1,82 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "SyncManagerParent.h"
+#include "SyncService.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
+namespace {
+  uint64_t sSyncManagerParentId = 0;
+}
+
 SyncManagerParent::SyncManagerParent()
+  : mService(SyncService::GetOrCreate())
+  , mId(++sSyncManagerParentId)
 {
   AssertIsOnBackgroundThread();
+  mService->RegisterActor(this);
 }
 
 SyncManagerParent::~SyncManagerParent()
 {
   AssertIsOnBackgroundThread();
 }
 
 void SyncManagerParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
+
+  if (mService) {
+    mService->UnregisterActor(this);
+  }
 }
 
 bool SyncManagerParent::RecvRequest(const nsID& aRequestId,
                                     const SyncOp& aOp)
 {
+  printf_stderr("RecvRequest");
+
   AssertIsOnBackgroundThread();
 
-  switch(aOp.mArgs().type()) {
-    case SyncOpArgs::TSyncRegisterArgs:
-    {
-      // XXX Do registration.
-      const SyncRegisterResponse response(true);
-      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    case SyncOpArgs::TSyncGetTagsArgs:
-    {
-      //XXX Do GetTags.
-      nsTArray<nsString> tags;
-      const SyncGetTagsResponse response(tags);
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    default:
-    {
-      MOZ_CRASH("Unknown BackgroundSync request");
-    }
+  if (NS_WARN_IF(!mService)) {
+    return false;
   }
+
+  mService->Request(mId, aRequestId, aOp);
+
   return true;
 }
 
 bool SyncManagerParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
+  if (NS_WARN_IF(!mService)) {
+    return false;
+  }
+
   Unused << Send__delete__(this);
 
   return true;
 }
 
+void SyncManagerParent::NotifyResponse(const nsID& aRequestId,
+                                       const SyncOpResponse& aResponse)
+{
+  printf_stderr("NotifyResponse\n");
+  Unused << SendResponse(aRequestId, aResponse);
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/sync/SyncManagerParent.h b/dom/sync/SyncManagerParent.h
--- a/dom/sync/SyncManagerParent.h
+++ b/dom/sync/SyncManagerParent.h
@@ -15,30 +15,47 @@
 namespace mozilla {
 
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
 
 namespace dom {
 
+class SyncService;
+
 class SyncManagerParent final : public PSyncManagerParent
 {
   friend class mozilla::ipc::BackgroundParentImpl;
 
 public:
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
+
+  void NotifyResponse(const nsID& aRequestId,
+                      const SyncOpResponse& aResponse);
+
+  uint64_t Id() const
+  {
+    return mId;
+  }
+
 private:
   SyncManagerParent();
   ~SyncManagerParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  RefPtr<SyncService> mService;
+
+  // The identifier will be used by the SyncService to know which request
+  // belongs to which parent actor.
+  uint64_t mId;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_SyncManagerParent_h
 
 
diff --git a/dom/sync/SyncService.cpp b/dom/sync/SyncService.cpp
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncService.cpp
@@ -0,0 +1,292 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISyncRegistry.h"
+#include "SyncService.h"
+#include "SyncManagerParent.h"
+
+namespace mozilla {
+
+namespace dom {
+
+namespace {
+  SyncService* sInstance = nullptr;
+} // namespace
+
+struct SyncRegistryRequest {
+  RefPtr<SyncService> mService;
+  uint64_t mActorId;
+  nsID mRequestId;
+  SyncOp mOp;
+
+  SyncRegistryRequest(SyncService* aService,
+                      const uint64_t aActorId,
+                      const nsID& aRequestId,
+                      const SyncOp& aOp)
+    : mService(aService)
+    , mActorId(aActorId)
+    , mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+};
+
+class SyncRegistryRequestRunnableCallback final : public nsRunnable
+{
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(SyncRegistryRequestRunnableCallback)
+
+  // XXX Use SyncRegistryResponse struct instead.
+  SyncRegistryRequestRunnableCallback(const SyncRegistryRequest aRequest)
+    : mRequest(aRequest)
+  {
+    AssertIsOnMainThread();
+  }
+
+  NS_IMETHODIMP Run() override
+  {
+    AssertIsOnBackgroundThread();
+
+    const SyncRegisterResponse response(true);
+    mRequest.mService->Response(mRequest.mActorId,
+                                mRequest.mRequestId,
+                                response);
+    return NS_OK;
+  }
+
+private:
+  ~SyncRegistryRequestRunnableCallback() {}
+
+  SyncRegistryRequest mRequest;
+};
+
+class SyncRegistryRequestRunnable final : public nsRunnable
+                                        , public nsISyncRegistryListener
+{
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  SyncRegistryRequestRunnable(SyncRegistryRequest aRequest)
+    : mRequest(aRequest)
+    , mBackgroundThread(NS_GetCurrentThread())
+  {
+    AssertIsOnBackgroundThread();
+  }
+
+  NS_IMETHODIMP
+  GetRequestId(nsID* aRequestId)
+  {
+    aRequestId = &(mRequest.mRequestId);
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  SetRequestId(const nsID aRequestId)
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  GetActorId(uint64_t* aActorId)
+  {
+    aActorId = &(mRequest.mActorId);
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  SetActorId(const uint64_t aActorId)
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  NotifyAddSuccess()
+  {
+    printf_stderr("SUCCESS\n");
+
+    RefPtr<SyncRegistryRequestRunnableCallback> callback =
+      new SyncRegistryRequestRunnableCallback(mRequest);
+    MOZ_ASSERT(callback);
+
+    mBackgroundThread->Dispatch(callback, NS_DISPATCH_NORMAL);
+
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  NotifyRemoveSuccess()
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  NotifyGetSuccess(nsISyncRegistration* registration)
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  NotifyGetAllSuccess(nsISyncRegistration** registrations, uint32_t count)
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  NotifyError(const nsAString& aError)
+  {
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    AssertIsOnMainThread();
+
+    nsCOMPtr<nsISyncRegistry> registry =
+      do_CreateInstance("@mozilla.org/dom/sync/registry;1");
+    MOZ_ASSERT(registry);
+
+    nsCOMPtr<nsIPrincipal> principal =
+      PrincipalInfoToPrincipal(mRequest.mOp.mPrincipal());
+    if (NS_WARN_IF(!principal)) {
+      return NS_OK;
+    }
+
+    nsAutoCString origin;
+    nsresult rv = principal->GetOriginSuffix(origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return NS_OK;
+    }
+
+    switch(mRequest.mOp.mArgs().type()) {
+      case SyncOpArgs::TSyncRegisterArgs:
+      {
+        nsCOMPtr<nsISyncRegistration> registration =
+          do_CreateInstance("@mozilla.org/dom/sync/registration;1");
+        MOZ_ASSERT(registration);
+
+        registration->SetOrigin(NS_ConvertUTF8toUTF16(origin));
+        registration->SetScope(mRequest.mOp.mArgs().get_SyncRegisterArgs().mScope());
+        registration->SetTag(mRequest.mOp.mArgs().get_SyncRegisterArgs().mTag());
+
+        registry->Add(registration, this);
+
+        break;
+      }
+      case SyncOpArgs::TSyncGetTagsArgs:
+      {
+        registry->GetAll(NS_ConvertUTF8toUTF16(origin), this);
+        break;
+      }
+      default:
+      {
+        MOZ_CRASH("Unknown BackgroundSync request");
+      }
+    }
+    return NS_OK;
+  }
+
+private:
+  ~SyncRegistryRequestRunnable() {}
+
+  SyncRegistryRequest mRequest;
+  nsCOMPtr<nsIThread> mBackgroundThread;
+};
+
+NS_IMPL_ISUPPORTS(SyncRegistryRequestRunnable, nsIRunnable, nsISyncRegistryListener);
+
+SyncService::SyncService()
+{
+  AssertIsOnBackgroundThread();
+
+  // sInstance is a raw SyncService*.
+  MOZ_ASSERT(!sInstance);
+  sInstance = this;
+}
+
+SyncService::~SyncService()
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(sInstance == this);
+  MOZ_ASSERT(mSyncManagerActors.Count() == 0);
+
+  sInstance = nullptr;
+}
+
+// static
+already_AddRefed<SyncService>
+SyncService::GetOrCreate()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<SyncService> instance = sInstance;
+  if (!instance) {
+    instance = new SyncService();
+  }
+  return instance.forget();
+}
+
+void
+SyncService::RegisterActor(SyncManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(!mSyncManagerActors.Contains(aParent));
+
+  mSyncManagerActors.PutEntry(aParent);
+}
+
+void
+SyncService::UnregisterActor(SyncManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(mSyncManagerActors.Contains(aParent));
+
+  mSyncManagerActors.RemoveEntry(aParent);
+}
+
+void
+SyncService::RegisterActor(workers::ServiceWorkerManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(!mServiceWorkerManagerActors.Contains(aParent));
+
+  mServiceWorkerManagerActors.PutEntry(aParent);
+}
+
+void
+SyncService::UnregisterActor(workers::ServiceWorkerManagerParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(mServiceWorkerManagerActors.Contains(aParent));
+
+  mServiceWorkerManagerActors.RemoveEntry(aParent);
+}
+
+void
+SyncService::Request(const uint64_t aActorId,
+                     const nsID& aRequestId,
+                     const SyncOp& aOp)
+{
+  RefPtr<SyncRegistryRequestRunnable> runnable =
+    new SyncRegistryRequestRunnable(SyncRegistryRequest(this, aActorId,
+                                    aRequestId, aOp));
+  NS_DispatchToMainThread(runnable);
+}
+
+void
+SyncService::Response(const uint64_t aActorId,
+                      const nsID& aRequestId,
+                      const SyncOpResponse& aResponse)
+{
+  printf_stderr("RESPONSE\n");
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/sync/SyncService.h b/dom/sync/SyncService.h
new file mode 100644
--- /dev/null
+++ b/dom/sync/SyncService.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_SyncService_h
+#define mozilla_dom_SyncService_h
+
+#include "mozilla/dom/SyncIPCTypes.h"
+#include "nsISupportsImpl.h"
+#include "nsHashKeys.h"
+#include "nsTHashtable.h"
+#include "ServiceWorkerManagerParent.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace workers {
+class ServiceWorkerManagerParent;
+} // namespace workers
+
+class SyncManagerParent;
+
+class SyncService final
+{
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(SyncService)
+
+  static already_AddRefed<SyncService> GetOrCreate();
+
+  void RegisterActor(SyncManagerParent* aParent);
+  void UnregisterActor(SyncManagerParent* aParent);
+
+  void RegisterActor(workers::ServiceWorkerManagerParent* aParent);
+  void UnregisterActor(workers::ServiceWorkerManagerParent* aParent);
+
+  void Request(const uint64_t aActorId,
+               const nsID& aRequestId,
+               const SyncOp& aOp);
+
+  void Response(const uint64_t aActorId,
+                const nsID& aRequestId,
+                const SyncOpResponse& aResponse);
+
+  SyncService();
+
+private:
+  ~SyncService();
+
+  nsTHashtable<nsPtrHashKey<SyncManagerParent>> mSyncManagerActors;
+  nsTHashtable<nsPtrHashKey<workers::ServiceWorkerManagerParent>>
+    mServiceWorkerManagerActors;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncService_h
diff --git a/dom/sync/moz.build b/dom/sync/moz.build
--- a/dom/sync/moz.build
+++ b/dom/sync/moz.build
@@ -5,17 +5,18 @@
 
 EXPORTS.mozilla.dom += [
     'SyncManager.h'
 ]
 
 UNIFIED_SOURCES += [
     'SyncManager.cpp',
     'SyncManagerChild.cpp',
-    'SyncManagerParent.cpp'
+    'SyncManagerParent.cpp',
+    'SyncService.cpp'
 ]
 
 IPDL_SOURCES += [
     'PSyncManager.ipdl',
     'SyncIPCTypes.ipdlh'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/dom/workers/ServiceWorkerManagerParent.cpp b/dom/workers/ServiceWorkerManagerParent.cpp
--- a/dom/workers/ServiceWorkerManagerParent.cpp
+++ b/dom/workers/ServiceWorkerManagerParent.cpp
@@ -1,16 +1,17 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "ServiceWorkerManagerParent.h"
 #include "ServiceWorkerManagerService.h"
+#include "SyncService.h"
 #include "mozilla/AppProcessChecker.h"
 #include "mozilla/dom/ContentParent.h"
 #include "mozilla/dom/ServiceWorkerRegistrar.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/unused.h"
 #include "nsThreadUtils.h"
 
@@ -143,22 +144,24 @@ private:
   PrincipalInfo mPrincipalInfo;
   RefPtr<nsRunnable> mCallback;
   nsCOMPtr<nsIThread> mBackgroundThread;
 };
 
 } // namespace
 
 ServiceWorkerManagerParent::ServiceWorkerManagerParent()
-  : mService(ServiceWorkerManagerService::GetOrCreate())
+  : mServiceWorkerService(ServiceWorkerManagerService::GetOrCreate())
+  , mSyncService(SyncService::GetOrCreate())
   , mID(++sServiceWorkerManagerParentID)
   , mActorDestroyed(false)
 {
   AssertIsOnBackgroundThread();
-  mService->RegisterActor(this);
+  mServiceWorkerService->RegisterActor(this);
+  mSyncService->RegisterActor(this);
 }
 
 ServiceWorkerManagerParent::~ServiceWorkerManagerParent()
 {
   AssertIsOnBackgroundThread();
 }
 
 already_AddRefed<ContentParent>
@@ -243,89 +246,89 @@ ServiceWorkerManagerParent::RecvUnregist
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateSoftUpdate(const PrincipalOriginAttributes& aOriginAttributes,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return false;
   }
 
-  mService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
+  mServiceWorkerService->PropagateSoftUpdate(mID, aOriginAttributes, aScope);
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateUnregister(const PrincipalInfo& aPrincipalInfo,
                                                     const nsString& aScope)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return false;
   }
 
-  mService->PropagateUnregister(mID, aPrincipalInfo, aScope);
+  mServiceWorkerService->PropagateUnregister(mID, aPrincipalInfo, aScope);
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateRemove(const nsCString& aHost)
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return false;
   }
 
-  mService->PropagateRemove(mID, aHost);
+  mServiceWorkerService->PropagateRemove(mID, aHost);
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvPropagateRemoveAll()
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return false;
   }
 
-  mService->PropagateRemoveAll(mID);
+  mServiceWorkerService->PropagateRemoveAll(mID);
   return true;
 }
 
 bool
 ServiceWorkerManagerParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
-  if (NS_WARN_IF(!mService)) {
+  if (NS_WARN_IF(!mServiceWorkerService)) {
     return false;
   }
 
-  mService->UnregisterActor(this);
-  mService = nullptr;
+  mServiceWorkerService->UnregisterActor(this);
+  mServiceWorkerService = nullptr;
 
   Unused << Send__delete__(this);
   return true;
 }
 
 void
 ServiceWorkerManagerParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 
   mActorDestroyed = true;
 
-  if (mService) {
-    // This object is about to be released and with it, also mService will be
+  if (mServiceWorkerService) {
+    // This object is about to be released and with it, also mServiceWorkerService will be
     // released too.
-    mService->UnregisterActor(this);
+    mServiceWorkerService->UnregisterActor(this);
   }
 }
 
 } // namespace workers
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/workers/ServiceWorkerManagerParent.h b/dom/workers/ServiceWorkerManagerParent.h
--- a/dom/workers/ServiceWorkerManagerParent.h
+++ b/dom/workers/ServiceWorkerManagerParent.h
@@ -13,16 +13,19 @@ namespace mozilla {
 
 class PrincipalOriginAttributes;
 
 namespace ipc {
 class BackgroundParentImpl;
 } // namespace ipc
 
 namespace dom {
+
+class SyncService;
+
 namespace workers {
 
 class ServiceWorkerManagerService;
 
 class ServiceWorkerManagerParent final : public PServiceWorkerManagerParent
 {
   friend class mozilla::ipc::BackgroundParentImpl;
 
@@ -59,17 +62,18 @@ private:
   virtual bool RecvPropagateRemove(const nsCString& aHost) override;
 
   virtual bool RecvPropagateRemoveAll() override;
 
   virtual bool RecvShutdown() override;
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
-  RefPtr<ServiceWorkerManagerService> mService;
+  RefPtr<ServiceWorkerManagerService> mServiceWorkerService;
+  RefPtr<SyncService> mSyncService;
 
   // We use this ID in the Service in order to avoid the sending of messages to
   // ourself.
   uint64_t mID;
 
   bool mActorDestroyed;
 };
 
diff --git a/dom/workers/moz.build b/dom/workers/moz.build
--- a/dom/workers/moz.build
+++ b/dom/workers/moz.build
@@ -92,16 +92,17 @@ IPDL_SOURCES += [
     'PServiceWorkerManager.ipdl',
     'ServiceWorkerRegistrarTypes.ipdlh',
 ]
 
 LOCAL_INCLUDES += [
     '../base',
     '../system',
     '/dom/base',
+    '/dom/sync',
     '/xpcom/build',
     '/xpcom/threads',
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
 
