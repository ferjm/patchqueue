# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  857fd5130433598ad21dedbaa24c6ea1fa9c0f3e
Bug 1217544 - Implement one-off BackgroundSync API. Part 7: BackgroundSyncService. r=baku

diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
--- a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -27,17 +27,16 @@ union SyncOpArgs
 struct SyncOp
 {
   PrincipalInfo mPrincipal;
   SyncOpArgs mArgs;
 };
 
 struct SyncRegisterResponse
 {
-  bool mSuccess;
 };
 
 struct SyncGetTagsResponse
 {
   nsString[] mTags;
 };
 
 struct SyncOpError
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -1,26 +1,31 @@
 /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSyncParent.h"
+#include "BackgroundSyncService.h"
 
 #include "mozilla/unused.h"
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 namespace backgroundsync {
 
+namespace {
+  uint64_t sBackgroundSyncManagerParentId = 1;
+}
+
 class BackgroundSyncParent::PendingRequest final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(PendingRequest)
 
   explicit PendingRequest(const nsID& aRequestId,
                           const SyncOp& aOp)
     : mRequestId(aRequestId)
@@ -39,88 +44,92 @@ public:
 private:
   ~PendingRequest() {}
 
   nsID mRequestId;
   SyncOp mOp;
 };
 
 BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
+  : mService(BackgroundSyncService::GetOrCreate())
+  , mId(++sBackgroundSyncManagerParentId)
+  , mActorDestroyed(false)
 {
   AssertIsOnBackgroundThread();
 
   mStorageManagerIdFactory =
     StorageManagerIdFactory::Create(this, aPrincipalInfo);
+
+  mService->RegisterActor(this);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
 void
 BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
+
+  mActorDestroyed = true;
+
+  if (mService) {
+    mService->UnregisterActor(this);
+  }
 }
 
-void
+bool
 BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
                                      const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
-  switch(aOp.mArgs().type()) {
-    case SyncOpArgs::TSyncRegisterArgs:
-    {
-      // XXX Do registration.
-      const SyncRegisterResponse response(true);
-      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    case SyncOpArgs::TSyncGetTagsArgs:
-    {
-      //XXX Do GetTags.
-      nsTArray<nsString> tags;
-      const SyncGetTagsResponse response(tags);
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    default:
-    {
-      MOZ_CRASH("Unknown BackgroundSync request");
-    }
+  if (NS_WARN_IF(!mService)) {
+    return false;
   }
+
+  mService->Request(mId, mStorageManagerId, aRequestId, aOp);
+
+  return true;
 }
 
 bool
 BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
                                   const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
   // If we haven't created a StorageManagerId for this parent yet, we
   // queue the request.
   if (!mStorageManagerId) {
     RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
     mPendingRequests.AppendElement(pendingRequest);
     return true;
   }
 
-  ExecuteRequest(aRequestId, aOp);
-  return true;
+  return ExecuteRequest(aRequestId, aOp);
 }
 
 bool
 BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
-  Unused << Send__delete__(this);
+  if (NS_WARN_IF(!mService)) {
+    return false;
+  }
+
+  mService->UnregisterActor(this);
+  mService = nullptr;
+
+  if (!mActorDestroyed) {
+    Unused << Send__delete__(this);
+  }
 
   return true;
 }
 
 void
 BackgroundSyncParent::OnStorageManagerIdCreated(
     StorageManagerId* aManagerId)
 {
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -19,16 +19,18 @@ namespace mozilla {
 namespace ipc {
   class BackgroundParentImpl;
   class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
+class BackgroundSyncService;
+
 class BackgroundSyncParent final : public PBackgroundSyncParent
                                  , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
   friend class CreateManagerIdRunnable;
 
 public:
   NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
@@ -36,28 +38,47 @@ public:
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 
   void NotifyResponse(const nsID& aRequestId,
                       const SyncOpResponse& aResponse);
 
+  uint64_t Id() const
+  {
+    return mId;
+  }
+
+  bool ActorDestroyed() const
+  {
+    return mActorDestroyed;
+  }
+
 private:
   BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
-  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+  bool ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
 
   // StorageManagerId method
   virtual void
   OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
 
+  // BackgroundSyncParent objects keep BackgroundSyncService alive.
+  RefPtr<BackgroundSyncService> mService;
+
+  // The identifier will be used by the BackgroundSyncService to know
+  // which request belongs to which parent actor.
+  uint64_t mId;
+
+  bool mActorDestroyed;
+
   RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
   // We use this Id to ensure that we have a single StorageManager
   // per principal.
   RefPtr<StorageManagerId> mStorageManagerId;
 
   class PendingRequest;
   nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
diff --git a/dom/backgroundsync/BackgroundSyncService.cpp b/dom/backgroundsync/BackgroundSyncService.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncService.cpp
@@ -0,0 +1,215 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+* file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * This singleton object is kept alive by the BackgroundSyncParent and
+ * ServiceWorkerManagerParent instances.
+ *
+ * It proxies storage requests such as sync registrations and get tags
+ * coming from the DOM objects through the IPC actors and makes sure that
+ * the storage context is ready for them.
+ *
+ * It also observes online/offline state changes and triggers the appropriate
+ * `sync` events whenever is needed.
+ */
+
+#include "BackgroundSyncService.h"
+#include "StorageManager.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+namespace {
+  BackgroundSyncService* sInstance = nullptr;
+} // namespace
+
+// ----------------------------------------------------------------------------
+
+struct BackgroundSyncService::StorageManagerRef final
+{
+  explicit StorageManagerRef(const uint64_t aActorId,
+                             StorageManager* aStorageManager)
+    : mActorId(aActorId)
+    , mStorageManager(aStorageManager)
+  {}
+
+  uint64_t mActorId;
+  RefPtr<StorageManager> mStorageManager;
+};
+
+void
+BackgroundSyncService::AddStorageManagerRef(const nsID& aRequestId,
+                                            const uint64_t aActorId,
+                                            StorageManager* aStorageManager)
+{
+  StorageManagerRef* ref = new StorageManagerRef(aActorId, aStorageManager);
+  mStorageManagers.Put(aRequestId, ref);
+}
+
+uint64_t
+BackgroundSyncService::ReleaseStorageManagerRef(const nsID& aRequestId)
+{
+  // It is possible that we call OnRequestComplete before AddStorageManagerRef
+  if (!mStorageManagers.Contains(aRequestId)) {
+    return 0;
+  }
+  nsAutoPtr<StorageManagerRef> doomed;
+  StorageManagerRef* ref;
+  mStorageManagers.Get(aRequestId, &ref);
+  uint64_t actorId = ref->mActorId;
+  mStorageManagers.RemoveAndForget(aRequestId, doomed);
+  return actorId;
+}
+
+void
+BackgroundSyncService::ReleaseStorageManagerRef(const uint64_t aActorId)
+{
+  for (auto iter = mStorageManagers.Iter(); !iter.Done(); iter.Next()) {
+    StorageManagerRef* ref;
+    mStorageManagers.Get(iter.Key(), &ref);
+    if (NS_WARN_IF(!ref)) {
+      continue;
+    }
+    if (ref->mActorId == aActorId) {
+      ref->mStorageManager = nullptr;
+      nsAutoPtr<StorageManagerRef> doomed;
+      mStorageManagers.RemoveAndForget(iter.Key(), doomed);
+    }
+  }
+}
+
+// ----------------------------------------------------------------------------
+
+BackgroundSyncService::BackgroundSyncService()
+  : mOnlineState(OnlineStateObserver::UNKNOWN)
+{
+  AssertIsOnBackgroundThread();
+
+  // sInstance is a raw BackgroundSyncService*.
+  MOZ_ASSERT(!sInstance);
+  sInstance = this;
+}
+
+BackgroundSyncService::~BackgroundSyncService()
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(sInstance == this);
+  MOZ_ASSERT(mBackgroundSyncActors.Count() == 0);
+
+  mOnlineStateObserver->Shutdown(this);
+
+  sInstance = nullptr;
+}
+
+// static
+already_AddRefed<BackgroundSyncService>
+BackgroundSyncService::GetOrCreate()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<BackgroundSyncService> instance = sInstance;
+  if (!instance) {
+    instance = new BackgroundSyncService();
+    instance->Init();
+  }
+  return instance.forget();
+}
+
+void
+BackgroundSyncService::Init()
+{
+  mOnlineStateObserver = OnlineStateObserver::Init(this);
+}
+
+void
+BackgroundSyncService::RegisterActor(BackgroundSyncParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(!mBackgroundSyncActors.Contains(aParent));
+
+  mBackgroundSyncActors.PutEntry(aParent);
+}
+
+void
+BackgroundSyncService::UnregisterActor(BackgroundSyncParent* aParent)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aParent);
+  MOZ_ASSERT(mBackgroundSyncActors.Contains(aParent));
+
+  ReleaseStorageManagerRef(aParent->Id());
+  mBackgroundSyncActors.RemoveEntry(aParent);
+}
+
+void
+BackgroundSyncService::Request(const uint64_t aActorId,
+                               StorageManagerId* aManagerId,
+                               const nsID& aRequestId,
+                               const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  printf_stderr("BackgroundSyncService::Request\n");
+
+  RefPtr<StorageManager> manager;
+  nsresult rv = StorageManager::GetOrCreate(this,
+                                            aManagerId,
+                                            getter_AddRefs(manager));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return Response(aActorId, aRequestId,
+                    SyncOpError(static_cast<uint32_t>(NS_ERROR_UNEXPECTED)));
+  }
+
+  AddStorageManagerRef(aRequestId, aActorId, manager);
+
+  manager->ExecuteRequest(aRequestId, aOp);
+}
+
+void
+BackgroundSyncService::Response(const uint64_t aActorId,
+                                const nsID& aRequestId,
+                                const SyncOpResponse& aResponse)
+{
+  for (auto iter = mBackgroundSyncActors.Iter(); !iter.Done(); iter.Next()) {
+    RefPtr<BackgroundSyncParent> parent = iter.Get()->GetKey();
+    MOZ_ASSERT(parent);
+    if (parent->Id() != aActorId || parent->ActorDestroyed()) {
+      continue;
+    }
+    parent->NotifyResponse(aRequestId, aResponse);
+  }
+}
+
+void
+BackgroundSyncService::OnRequestComplete(const nsID& aRequestId,
+                                         const SyncOpResponse& aResponse)
+{
+  Response(ReleaseStorageManagerRef(aRequestId), aRequestId, aResponse);
+}
+
+/**
+ * OnlineStateObserver::Listener implementation.
+ */
+
+void
+BackgroundSyncService::OnOnlineStateChanged(
+    OnlineStateObserver::OnlineState aState)
+{
+  mOnlineState = aState;
+
+  if (mOnlineState != OnlineStateObserver::ONLINE) {
+    return;
+  }
+
+  // XXX If we are online we need to get the list of registered sync requests
+  //     to trigger the corresponding 'sync' events.
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncService.h b/dom/backgroundsync/BackgroundSyncService.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncService.h
@@ -0,0 +1,71 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+* You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncService_h
+#define mozilla_dom_BackgroundSyncService_h
+
+#include "OnlineStateObserver.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class StorageManager;
+
+class BackgroundSyncService final : public OnlineStateObserver::Listener
+{
+  friend class StorageManager;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(BackgroundSyncService)
+
+  static already_AddRefed<BackgroundSyncService> GetOrCreate();
+
+  void RegisterActor(BackgroundSyncParent* aParent);
+  void UnregisterActor(BackgroundSyncParent* aParent);
+
+  void Request(const uint64_t aActorId,
+               StorageManagerId* aManagerId,
+               const nsID& aRequestId,
+               const SyncOp& aOp);
+
+private:
+  BackgroundSyncService();
+  ~BackgroundSyncService();
+
+  void Init();
+
+  void Response(const uint64_t aActorId,
+                const nsID& aRequestId,
+                const SyncOpResponse& aResponse);
+
+  void OnRequestComplete(const nsID& aRequestId,
+                         const SyncOpResponse& aResponse);
+
+  void AddStorageManagerRef(const nsID& aRequestId,
+                            const uint64_t aActorId,
+                            StorageManager* aStorageManager);
+  uint64_t ReleaseStorageManagerRef(const nsID& aRequestId);
+  void ReleaseStorageManagerRef(const uint64_t aActorId);
+
+  struct StorageManagerRef;
+  nsClassHashtable<nsIDHashKey, StorageManagerRef> mStorageManagers;
+
+  nsTHashtable<nsRefPtrHashKey<BackgroundSyncParent>> mBackgroundSyncActors;
+
+  // OnlineStateObserver::Listener method
+  virtual void
+  OnOnlineStateChanged(OnlineStateObserver::OnlineState aState) override;
+
+  RefPtr<OnlineStateObserver> mOnlineStateObserver;
+  OnlineStateObserver::OnlineState mOnlineState;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_SyncService_h
diff --git a/dom/backgroundsync/DBSchema.cpp b/dom/backgroundsync/DBSchema.cpp
--- a/dom/backgroundsync/DBSchema.cpp
+++ b/dom/backgroundsync/DBSchema.cpp
@@ -196,16 +196,84 @@ InitializeConnection(mozIStorageConnecti
 
   // integer value 2 is incremental mode
   if (NS_WARN_IF(mode != 2)) { return NS_ERROR_UNEXPECTED; }
 #endif
 
   return NS_OK;
 }
 
+void
+GetId(const nsAString& aScope, const nsAString& aTag, nsAString& aId)
+{
+  aId = aScope + NS_LITERAL_STRING("@") + aTag;
+}
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aRegisterArgs)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO registrations ("
+      "id, "
+      "originSuffix, "
+      "scope, "
+      "tag, "
+      "state, "
+      "lastChance "
+    ") VALUES ("
+      ":id, "
+      ":originSuffix, "
+      ":scope, "
+      ":tag, "
+      ":state, "
+      ":lastChance "
+    ");"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsString id;
+  GetId(aRegisterArgs.mScope(), aRegisterArgs.mTag(), id);
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), id);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // XXX
+  rv = state->BindUTF8StringByName(NS_LITERAL_CSTRING("originSuffix"),
+                                   NS_LITERAL_CSTRING("XXX"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("scope"),
+                               aRegisterArgs.mScope());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("tag"),
+                               aRegisterArgs.mTag());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // XXX enum
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("state"), 0);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // By default new registrations are not flagged as last chance.
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("lastChance"), 0);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn)
 {
   // Determine how much free space is in the database.
   nsCOMPtr<mozIStorageStatement> state;
   nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
     "PRAGMA freelist_count;"
   ), getter_AddRefs(state));
diff --git a/dom/backgroundsync/DBSchema.h b/dom/backgroundsync/DBSchema.h
--- a/dom/backgroundsync/DBSchema.h
+++ b/dom/backgroundsync/DBSchema.h
@@ -18,16 +18,20 @@ namespace db {
 // Note, this cannot be executed within a transaction.
 nsresult
 CreateOrMigrateSchema(mozIStorageConnection* aConn);
 
 // Note, this cannot be executed within a transaction.
 nsresult
 InitializeConnection(mozIStorageConnection* aConn);
 
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aRegisterArgs);
+
 // Note, this works best when its NOT executed within a transaction.
 nsresult
 IncrementalVacuum(mozIStorageConnection* aConn);
 
 // We will wipe out databases with a schema versions less than this.  Newer
 // versions will be migrated on open to the latest schema version.
 extern const int32_t kFirstShippedSchemaVersion;
 
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
--- a/dom/backgroundsync/StorageManager.cpp
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -47,17 +47,18 @@ public:
 // Singleton class to track StorageManager instances and ensure there is only
 // one for each unique StorageManagerId.
 class StorageManager::Factory
 {
 public:
   friend class StaticAutoPtr<StorageManager::Factory>;
 
   static nsresult
-  GetOrCreate(StorageManagerId* aManagerId,
+  GetOrCreate(BackgroundSyncService* aService,
+              StorageManagerId* aManagerId,
               StorageManager** aManagerOut)
   {
     AssertIsOnBackgroundThread();
 
     // Ensure there is a factory instance. This forces the Get() call
     // below to use the same factory.
     nsresult rv = MaybeCreateInstance();
     if (NS_WARN_IF(NS_FAILED(rv))) {
@@ -68,17 +69,17 @@ public:
     if (!ref) {
       nsCOMPtr<nsIThread> ioThread;
       rv = NS_NewNamedThread("BSyncIOThread",
                              getter_AddRefs(ioThread));
       if (NS_WARN_IF(NS_FAILED(rv))) {
         return rv;
       }
 
-      ref = new StorageManager(aManagerId, ioThread);
+      ref = new StorageManager(aService, aManagerId, ioThread);
 
       // There may be an old manager for this origin in the process of
       // cleaning up.  We need to tell the new manager about this so
       // that it won't actually start until the old manager is done.
       RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
       ref->Init(oldManager);
 
       MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
@@ -288,57 +289,68 @@ class StorageManager::BaseAction : publi
 {
 protected:
   BaseAction(const nsID& aRequestId, StorageManager* aManager)
     : SyncDBAction(DBAction::Existing)
     , mRequestId(aRequestId)
     , mManager(aManager)
   {}
 
-  // XXX We need to get a ErrorResult&& here.
   virtual void
-  Complete() = 0;
+  Complete(nsresult aRv) = 0;
 
   virtual void
   CompleteOnInitiatingThread(nsresult aRv) override
   {
     NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
 
-    Complete();
+    Complete(aRv);
 
     // Ensure we release the manager on the initiating thread.
     mManager = nullptr;
   }
 
   const nsID mRequestId;
   RefPtr<StorageManager> mManager;
 };
 
 // ---------------------------------------------------------------------------
 
 class StorageManager::RegisterAction final : public StorageManager::BaseAction
 {
 public:
-  RegisterAction(const nsID& aRequestId, StorageManager* aManager)
+  RegisterAction(const nsID& aRequestId,
+                 StorageManager* aManager,
+                 const SyncRegisterArgs& aRegisterArgs)
     : BaseAction(aRequestId, aManager)
+    , mArgs(aRegisterArgs)
   {}
 
   virtual nsresult
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
-    // XXX
-    return NS_OK;
+    nsresult rv = db::Register(aConn, mArgs);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
   }
 
   virtual void
-  Complete() override
+  Complete(nsresult aRv) override
   {
-    mManager->OnRequestComplete(mRequestId);
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete(mRequestId,
+                                  SyncOpError(static_cast<uint32_t>(aRv)));
+    } else {
+      mManager->OnRequestComplete(mRequestId, SyncRegisterResponse());
+    }
   }
+
+private:
+  SyncRegisterArgs mArgs;
 };
 
 // ---------------------------------------------------------------------------
 
 class StorageManager::GetTagsAction final : public StorageManager::BaseAction
 {
 public:
   GetTagsAction(const nsID& aRequestId, StorageManager* aManager)
@@ -349,31 +361,38 @@ public:
   RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
                   mozIStorageConnection* aConn) override
   {
     // XXX
     return NS_OK;
   }
 
   virtual void
-  Complete() override
+  Complete(nsresult aRv) override
   {
-    mManager->OnRequestComplete(mRequestId);
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete(mRequestId,
+                                  SyncOpError(static_cast<uint32_t>(aRv)));
+    } else {
+      // XXX s/SyncRegisterResponse/SyncGetTagsResponse
+      mManager->OnRequestComplete(mRequestId, SyncRegisterResponse());
+    }
   }
 };
 
 // ---------------------------------------------------------------------------
 
 // static
 nsresult
-StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+StorageManager::GetOrCreate(BackgroundSyncService* aService,
+                            StorageManagerId* aManagerId,
                             StorageManager** aManagerOut)
 {
   AssertIsOnBackgroundThread();
-  return Factory::GetOrCreate(aManagerId, aManagerOut);
+  return Factory::GetOrCreate(aService, aManagerId, aManagerOut);
 }
 
 // static
 void
 StorageManager::ShutdownAll()
 {
   mozilla::ipc::AssertIsOnBackgroundThread();
 
@@ -390,34 +409,39 @@ StorageManager::ShutdownAll()
 void
 StorageManager::Abort(const nsACString& aOrigin)
 {
  mozilla::ipc::AssertIsOnBackgroundThread();
 
  Factory::Abort(aOrigin);
 }
 
-StorageManager::StorageManager(StorageManagerId* aManagerId,
+StorageManager::StorageManager(BackgroundSyncService* aService,
+                               StorageManagerId* aManagerId,
                                nsIThread* aIOThread)
-  : mManagerId(aManagerId)
+  : mService(aService)
+  , mManagerId(aManagerId)
   , mIOThread(aIOThread)
   , mContext(nullptr)
   , mShuttingDown(false)
   , mState(Open)
 {
+  MOZ_ASSERT(mService);
   MOZ_ASSERT(mManagerId);
   MOZ_ASSERT(mIOThread);
 }
 
 StorageManager::~StorageManager()
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mState == Closing);
   MOZ_ASSERT(!mContext);
 
+  mService = nullptr;
+
 /*  nsCOMPtr<nsIThread> ioThread;
   mIOThread.swap(ioThread);
 
   // Don't spin the event loop in the destructor waiting for the thread to
   // shutdown. Defer this to the main thread, instead.
   MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
         NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
 }
@@ -533,29 +557,31 @@ void
 StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mContext);
 
   mPendingRequests.AppendElement(aRequestId);
 
   if (NS_WARN_IF(mState == Closing)) {
-    OnRequestComplete(aRequestId);
+    OnRequestComplete(aRequestId,
+                      SyncOpError(static_cast<uint32_t>(NS_ERROR_ABORT)));
     return;
   }
 
   RefPtr<StorageContext> context = mContext;
   MOZ_ASSERT(!context->IsCanceled());
 
   RefPtr<StorageAction> action;
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
-      action = new RegisterAction(aRequestId, this);
+      action = new RegisterAction(aRequestId, this,
+                                  aOp.mArgs().get_SyncRegisterArgs());
       break;
     }
     case SyncOpArgs::TSyncGetTagsArgs:
     {
       action = new GetTagsAction(aRequestId, this);
       break;
     }
     default:
@@ -563,23 +589,24 @@ StorageManager::ExecuteRequest(const nsI
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
 
   context->Dispatch(action);
 }
 
 void
-StorageManager::OnRequestComplete(const nsID& aRequestId)
+StorageManager::OnRequestComplete(const nsID& aRequestId,
+                                  const SyncOpResponse& aResponse)
 {
   NS_ASSERT_OWNINGTHREAD(StorageManager);
   MOZ_ASSERT(mPendingRequests.Contains(aRequestId));
 
   mPendingRequests.RemoveElement(aRequestId);
 
-  // XXX Notify listener
+  MaybeAllowContextToClose();
 
-  MaybeAllowContextToClose();
+  mService->OnRequestComplete(aRequestId, aResponse);
 }
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
--- a/dom/backgroundsync/StorageManager.h
+++ b/dom/backgroundsync/StorageManager.h
@@ -29,17 +29,18 @@ namespace backgroundsync {
  * until that request is completed or the actor requesting it is destroyed.
  */
 
 class StorageManager final
 {
 public:
   NS_INLINE_DECL_REFCOUNTING(StorageManager)
 
-  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+  static nsresult GetOrCreate(BackgroundSyncService* aService,
+                              StorageManagerId* aManagerId,
                               StorageManager** aManagerOut);
 
   enum State
   {
     Open,
     Closing
   };
 
@@ -71,27 +72,31 @@ public:
   void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
 
 private:
   class BaseAction;
   class Factory;
   class GetTagsAction;
   class RegisterAction;
 
-  StorageManager(StorageManagerId* aManagerId, nsIThread* aIOThread);
+  StorageManager(BackgroundSyncService* aService,
+                 StorageManagerId* aManagerId,
+                 nsIThread* aIOThread);
   ~StorageManager();
 
   void Init(StorageManager* aOldManager);
   void Abort();
   void Shutdown();
 
   void MaybeAllowContextToClose();
 
-  void OnRequestComplete(const nsID& aRequestId);
+  void OnRequestComplete(const nsID& aRequestId,
+                         const SyncOpResponse& aResponse);
 
+  RefPtr<BackgroundSyncService> mService;
   RefPtr<StorageManagerId> mManagerId;
   nsCOMPtr<nsIThread> mIOThread;
 
   // Weak reference cleared by RemoveStorageContext() in StorageContext
   // destructor.
   StorageContext* MOZ_NON_OWNING_REF mContext;
 
   bool mShuttingDown;
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -7,16 +7,17 @@ EXPORTS.mozilla.dom.backgroundsync += [
     'BackgroundSync.h',
     'QuotaClient.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
     'BackgroundSyncParent.cpp',
+    'BackgroundSyncService.cpp',
     'DBAction.cpp',
     'DBConnection.cpp',
     'DBSchema.cpp',
     'OnlineStateObserver.cpp',
     'QuotaClient.cpp',
     'StorageAction.cpp',
     'StorageContext.cpp',
     'StorageManager.cpp',
