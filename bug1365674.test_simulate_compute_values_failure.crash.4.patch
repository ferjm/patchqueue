# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Parent  e8da7192201e5786614ec49d557e64dffd114ff2

diff --git a/dom/animation/Keyframe.h b/dom/animation/Keyframe.h
--- a/dom/animation/Keyframe.h
+++ b/dom/animation/Keyframe.h
@@ -30,16 +30,18 @@ struct PropertyValuePair
   // property values, we store the specified property value as a token stream
   // (string).
   nsCSSValue mValue;
 
   // The specified value when using the Servo backend.
   RefPtr<RawServoDeclarationBlock> mServoDeclarationBlock;
 
   bool operator==(const PropertyValuePair&) const;
+
+  bool mSimulateComputeValuesFailure;
 };
 
 /**
  * A single keyframe.
  *
  * This is the canonical form in which keyframe effects are stored and
  * corresponds closely to the type of objects returned via the getKeyframes()
  * API.
diff --git a/dom/animation/KeyframeUtils.cpp b/dom/animation/KeyframeUtils.cpp
--- a/dom/animation/KeyframeUtils.cpp
+++ b/dom/animation/KeyframeUtils.cpp
@@ -622,31 +622,33 @@ KeyframeUtils::GetComputedKeyframeValues
     ComputedKeyframeValues* computedValues = result.AppendElement();
     for (const PropertyValuePair& pair :
            PropertyPriorityIterator(frame.mPropertyValues)) {
       MOZ_ASSERT(!pair.mServoDeclarationBlock,
                  "Animation values were parsed using Servo backend but target"
                  " element is not using Servo backend?");
 
       if (IsInvalidValuePair(pair, StyleBackendType::Gecko)) {
+        printf_stderr("IsInvalidValuePair YES\n");
         continue;
       }
 
       // Expand each value into the set of longhands and produce
       // a KeyframeValueEntry for each value.
       nsTArray<PropertyStyleAnimationValuePair> values;
 
       // For shorthands, we store the string as a token stream so we need to
       // extract that first.
       if (nsCSSProps::IsShorthand(pair.mProperty)) {
         nsCSSValueTokenStream* tokenStream = pair.mValue.GetTokenStreamValue();
         if (!StyleAnimationValue::ComputeValues(pair.mProperty,
               CSSEnabledState::eForAllContent, aElement, aStyleContext,
               tokenStream->mTokenStream, /* aUseSVGMode */ false, values) ||
             IsComputeValuesFailureKey(pair)) {
+          printf_stderr("IsComputeValuesFailureKey YES\n");
           continue;
         }
       } else if (pair.mValue.GetUnit() == eCSSUnit_Null) {
         // An uninitialized nsCSSValue represents the underlying value which
         // we represent as an uninitialized AnimationValue so we just leave
         // neutralPair->mValue as-is.
         PropertyStyleAnimationValuePair* neutralPair = values.AppendElement();
         neutralPair->mProperty = pair.mProperty;
@@ -1027,16 +1029,17 @@ AppendValueAsString(JSContext* aCx,
 static PropertyValuePair
 MakePropertyValuePair(nsCSSPropertyID aProperty, const nsAString& aStringValue,
                       nsCSSParser& aParser, nsIDocument* aDocument)
 {
   MOZ_ASSERT(aDocument);
   PropertyValuePair result;
 
   result.mProperty = aProperty;
+  result.mSimulateComputeValuesFailure = false;
 
   if (aDocument->GetStyleBackendType() == StyleBackendType::Servo) {
     RefPtr<RawServoDeclarationBlock> servoDeclarationBlock =
       KeyframeUtils::ParseProperty(aProperty, aStringValue, aDocument);
 
     if (servoDeclarationBlock) {
       result.mServoDeclarationBlock = servoDeclarationBlock.forget();
     }
@@ -1111,48 +1114,38 @@ HasValidOffsets(const nsTArray<Keyframe>
  * that value we should behave as if that function had failed.
  *
  * @param aPair The PropertyValuePair to modify. |aPair.mProperty| must be
  *              a shorthand property.
  */
 static void
 MarkAsComputeValuesFailureKey(PropertyValuePair& aPair)
 {
+  printf_stderr("MarkAsComputeValuesFailureKey\n");
   MOZ_ASSERT(nsCSSProps::IsShorthand(aPair.mProperty),
              "Only shorthand property values can be marked as failure values");
 
-  // We store shorthand values as nsCSSValueTokenStream objects whose mProperty
-  // and mShorthandPropertyID are eCSSProperty_UNKNOWN and whose mTokenStream
-  // member contains the shorthand property's value as a string.
-  //
-  // We need to leave mShorthandPropertyID as eCSSProperty_UNKNOWN so that
-  // nsCSSValue::AppendToString returns the mTokenStream value, but we can
-  // update mPropertyID to a special value to indicate that this is
-  // a special failure sentinel.
-  nsCSSValueTokenStream* tokenStream = aPair.mValue.GetTokenStreamValue();
-  MOZ_ASSERT(tokenStream->mPropertyID == eCSSProperty_UNKNOWN,
-             "Shorthand value should initially have an unknown property ID");
-  tokenStream->mPropertyID = eCSSPropertyExtra_no_properties;
+  aPair.mSimulateComputeValuesFailure = true;
 }
 
 /**
  * Returns true if |aPair| is a property-value pair on which we have
  * previously called MarkAsComputeValuesFailureKey (and hence we should
  * simulate failure when calling StyleAnimationValue::ComputeValues using its
  * value).
  *
  * @param aPair The property-value pair to test.
  * @return True if |aPair| represents a failure value.
  */
 static bool
 IsComputeValuesFailureKey(const PropertyValuePair& aPair)
 {
+  printf_stderr("IsComputeValuesFailureKey\n");
   return nsCSSProps::IsShorthand(aPair.mProperty) &&
-         aPair.mValue.GetTokenStreamValue()->mPropertyID ==
-           eCSSPropertyExtra_no_properties;
+         aPair.mSimulateComputeValuesFailure;
 }
 
 static void
 AppendInitialSegment(AnimationProperty* aAnimationProperty,
                      const KeyframeValueEntry& aFirstEntry)
 {
   AnimationPropertySegment* segment =
     aAnimationProperty->mSegments.AppendElement();
@@ -1551,16 +1544,17 @@ RequiresAdditiveAnimation(const nsTArray
                             ? 1.0
                             : i == 0 ? 0.0 : 0.5;
     double offsetToUse = frame.mOffset
                          ? frame.mOffset.value()
                          : computedOffset;
 
     for (const PropertyValuePair& pair : frame.mPropertyValues) {
       if (IsInvalidValuePair(pair, styleBackend)) {
+        printf_stderr("IsInvalidValuePair YES\n");
         continue;
       }
 
       if (nsCSSProps::IsShorthand(pair.mProperty)) {
         if (styleBackend == StyleBackendType::Gecko) {
           nsCSSValueTokenStream* tokenStream =
             pair.mValue.GetTokenStreamValue();
           nsCSSParser parser(aDocument->CSSLoader());
diff --git a/servo/ports/geckolib/glue.rs b/servo/ports/geckolib/glue.rs
--- a/servo/ports/geckolib/glue.rs
+++ b/servo/ports/geckolib/glue.rs
@@ -2377,22 +2377,34 @@ pub extern "C" fn Servo_GetComputedKeyfr
         // mServoDeclarationBlock is null in the case where we have an invalid css property.
         let iter = keyframe.mPropertyValues.iter()
                                            .filter(|&property| !property.mServoDeclarationBlock.mRawPtr.is_null());
         let mut property_index = 0;
         for property in iter {
             let declarations = unsafe { &*property.mServoDeclarationBlock.mRawPtr.clone() };
             let declarations = Locked::<PropertyDeclarationBlock>::as_arc(&declarations);
             let guard = declarations.read_with(&guard);
+            
+            let is_shorthand = PropertyId::from_nscsspropertyid(property.mProperty).ok().map_or(false, |p| {
+                p.as_shorthand().is_ok()
+            });
+
+            if is_shorthand && property.mSimulateComputeValuesFailure {
+                println!("SKIP {:?}", property.mProperty);
+                continue;
+            } else {
+                println!("NO SKIP {:?}", property.mProperty);
+            }
 
             let anim_iter = guard.declarations()
                             .iter()
                             .filter_map(|&(ref decl, imp)| {
                                 if imp == Importance::Normal {
                                     let property = TransitionProperty::from_declaration(decl);
+
                                     let animation = AnimationValue::from_declaration(decl, &mut context,
                                                                                      default_values);
                                     debug_assert!(property.is_none() == animation.is_none(),
                                                   "The failure condition of TransitionProperty::from_declaration \
                                                    and AnimationValue::from_declaration should be the same");
                                     // Skip the property if either ::from_declaration fails.
                                     if property.is_none() || animation.is_none() {
                                         None
