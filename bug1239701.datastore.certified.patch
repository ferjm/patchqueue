# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  9bb1872a676cfc39fd9419fb5d7310bd80258d56
Bug 1239701 - Datastore should allow us to define stores accessible just by certified apps. r=baku

diff --git a/dom/apps/Webapps.jsm b/dom/apps/Webapps.jsm
--- a/dom/apps/Webapps.jsm
+++ b/dom/apps/Webapps.jsm
@@ -855,18 +855,22 @@ this.DOMApplicationRegistry = {
     }
 
     if ('datastores-owned' in aManifest) {
       for (let name in aManifest['datastores-owned']) {
         let readonly = "access" in aManifest['datastores-owned'][name]
                          ? aManifest['datastores-owned'][name].access == 'readonly'
                          : false;
 
+        let certifiedOnly = "certified-only" in aManifest["datastores-owned"][name]
+                            ? aManifest["datastores-owned"][name]["certified-only"]
+                            : true;
+
         dataStoreService.installDataStore(aId, name, aOrigin, aManifestURL,
-                                          readonly);
+                                          readonly, certifiedOnly);
       }
     }
 
     if ('datastores-access' in aManifest) {
       for (let name in aManifest['datastores-access']) {
         let readonly = ("readonly" in aManifest['datastores-access'][name]) &&
                        !aManifest['datastores-access'][name].readonly
                          ? false : true;
diff --git a/dom/datastore/DataStoreService.cpp b/dom/datastore/DataStoreService.cpp
--- a/dom/datastore/DataStoreService.cpp
+++ b/dom/datastore/DataStoreService.cpp
@@ -66,63 +66,71 @@ namespace dom {
 using namespace indexedDB;
 
 // This class contains all the information about a DataStore.
 class DataStoreInfo
 {
 public:
   DataStoreInfo()
     : mReadOnly(true)
+    , mCertifiedOnly(true)
     , mEnabled(false)
   {}
 
   DataStoreInfo(const nsAString& aName,
                 const nsAString& aOriginURL,
                 const nsAString& aManifestURL,
                 bool aReadOnly,
+                bool aCertifiedOnly,
                 bool aEnabled)
     : mReadOnly(true)
     , mEnabled(false)
   {
-    Init(aName, aOriginURL, aManifestURL, aReadOnly, aEnabled);
+    Init(aName, aOriginURL, aManifestURL, aReadOnly, aCertifiedOnly,
+         aEnabled);
   }
 
   void Init(const nsAString& aName,
             const nsAString& aOriginURL,
             const nsAString& aManifestURL,
             bool aReadOnly,
+            bool aCertifiedOnly,
             bool aEnabled)
   {
     mName = aName;
     mOriginURL = aOriginURL;
     mManifestURL = aManifestURL;
     mReadOnly = aReadOnly;
+    mCertifiedOnly = aCertifiedOnly;
     mEnabled = aEnabled;
   }
 
   void Update(const nsAString& aName,
               const nsAString& aOriginURL,
               const nsAString& aManifestURL,
-              bool aReadOnly)
+              bool aReadOnly,
+              bool aCertifiedOnly)
   {
     mName = aName;
     mOriginURL = aOriginURL;
     mManifestURL = aManifestURL;
     mReadOnly = aReadOnly;
+    mCertifiedOnly = aCertifiedOnly;
   }
 
   void Enable()
   {
     mEnabled = true;
   }
 
   nsString mName;
   nsString mOriginURL;
   nsString mManifestURL;
   bool mReadOnly;
+  bool mCertifiedOnly;
 
   // A DataStore is enabled when it has its first revision.
   bool mEnabled;
 };
 
 namespace {
 
 // Singleton for DataStoreService.
@@ -730,33 +738,35 @@ DataStoreService::Init()
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DataStoreService::InstallDataStore(uint32_t aAppId,
                                    const nsAString& aName,
                                    const nsAString& aOriginURL,
                                    const nsAString& aManifestURL,
-                                   bool aReadOnly)
+                                   bool aReadOnly,
+                                   bool aCertifiedOnly)
 {
   ASSERT_PARENT_PROCESS()
   MOZ_ASSERT(NS_IsMainThread());
 
   HashApp* apps = nullptr;
   if (!mStores.Get(aName, &apps)) {
     apps = new HashApp();
     mStores.Put(aName, apps);
   }
 
   DataStoreInfo* info = nullptr;
   if (!apps->Get(aAppId, &info)) {
-    info = new DataStoreInfo(aName, aOriginURL, aManifestURL, aReadOnly, false);
+    info = new DataStoreInfo(aName, aOriginURL, aManifestURL, aReadOnly,
+                             aCertifiedOnly, false /* enabled */);
     apps->Put(aAppId, info);
   } else {
-    info->Update(aName, aOriginURL, aManifestURL, aReadOnly);
+    info->Update(aName, aOriginURL, aManifestURL, aReadOnly, aCertifiedOnly);
   }
 
   nsresult rv = AddPermissions(aAppId, aName, aOriginURL, aManifestURL,
                                aReadOnly);
   if (NS_WARN_IF(NS_FAILED(rv))) {
     return rv;
   }
 
@@ -775,22 +785,27 @@ DataStoreService::InstallAccessDataStore
   MOZ_ASSERT(NS_IsMainThread());
 
   HashApp* apps = nullptr;
   if (!mAccessStores.Get(aName, &apps)) {
     apps = new HashApp();
     mAccessStores.Put(aName, apps);
   }
 
+  // For access datastores we don't care about the certified only flag. We
+  // just default to true.
+
   DataStoreInfo* info = nullptr;
   if (!apps->Get(aAppId, &info)) {
-    info = new DataStoreInfo(aName, aOriginURL, aManifestURL, aReadOnly, false);
+    info = new DataStoreInfo(aName, aOriginURL, aManifestURL, aReadOnly,
+                             true /* certified only */, false /* enabled */);
     apps->Put(aAppId, info);
   } else {
-    info->Update(aName, aOriginURL, aManifestURL, aReadOnly);
+    info->Update(aName, aOriginURL, aManifestURL, aReadOnly,
+                 true /* certified only */);
   }
 
   return AddAccessPermissions(aAppId, aName, aOriginURL, aManifestURL,
                               aReadOnly);
 }
 
 NS_IMETHODIMP
 DataStoreService::GetDataStores(nsIDOMWindow* aWindow,
@@ -852,17 +867,17 @@ DataStoreService::GetDataStores(nsIDOMWi
       promise.forget(aDataStores);
       return NS_OK;
     }
 
     for (uint32_t i = 0; i < array.Length(); ++i) {
       DataStoreInfo* info = stores.AppendElement();
       info->Init(array[i].name(), array[i].originURL(),
                  array[i].manifestURL(), array[i].readOnly(),
-                 array[i].enabled());
+                 array[i].certifiedOnly(), array[i].enabled());
     }
   }
 
   GetDataStoresCreate(window, promise, stores);
   promise.forget(aDataStores);
   return NS_OK;
 }
 
@@ -944,17 +959,17 @@ DataStoreService::GetDataStoresResolve(n
       return;
     }
 
     nsCOMPtr<nsIGlobalObject> global = do_QueryInterface(aWindow);
     MOZ_ASSERT(global);
 
     JSAutoCompartment ac(cx, dataStoreJS);
     RefPtr<DataStoreImpl> dataStoreObj = new DataStoreImpl(dataStoreJS,
-                                                             global);
+                                                           global);
 
     RefPtr<DataStore> exposedStore = new DataStore(aWindow);
 
     ErrorResult error;
     exposedStore->SetDataStoreImpl(*dataStoreObj, error);
     if (error.Failed()) {
       return;
     }
@@ -1009,17 +1024,18 @@ DataStoreService::GetDataStoreInfos(cons
     return NS_OK;
   }
 
   DataStoreInfo* appsInfo = nullptr;
   if (apps->Get(aAppId, &appsInfo) &&
       (aOwner.IsEmpty() || aOwner.Equals(appsInfo->mManifestURL))) {
     DataStoreInfo* owned = aStores.AppendElement();
     owned->Init(appsInfo->mName, appsInfo->mOriginURL, appsInfo->mManifestURL,
-                false, appsInfo->mEnabled);
+                false /* read only */, appsInfo->mCertifiedOnly,
+                appsInfo->mEnabled);
   }
 
   for (auto iter = apps->ConstIter(); !iter.Done(); iter.Next()) {
     if (iter.Key() == aAppId) {
       continue;
     }
 
     DataStoreInfo* appInfo = iter.UserData();
@@ -1035,21 +1051,32 @@ DataStoreService::GetDataStoreInfos(cons
       continue;
     }
 
     DataStoreInfo* accessInfo = nullptr;
     if (!accessApp->Get(aAppId, &accessInfo)) {
       continue;
     }
 
+    if (appInfo->mCertifiedOnly) {
+      uint16_t status;
+      if (NS_FAILED(aPrincipal->GetAppStatus(&status))) {
+        return NS_ERROR_FAILURE;
+      }
+
+      if (status != nsIPrincipal::APP_STATUS_CERTIFIED) {
+        continue;
+      }
+    }
+
     bool readOnly = appInfo->mReadOnly || accessInfo->mReadOnly;
     DataStoreInfo* accessStore = aStores.AppendElement();
     accessStore->Init(aName, appInfo->mOriginURL,
                       appInfo->mManifestURL, readOnly,
-                      appInfo->mEnabled);
+                      appInfo->mCertifiedOnly, appInfo->mEnabled);
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 DataStoreService::GetAppManifestURLsForDataStore(const nsAString& aName,
                                                  nsIArray** aManifestURLs)
@@ -1405,16 +1432,17 @@ DataStoreService::GetDataStoresFromIPC(c
   }
 
   for (uint32_t i = 0; i < stores.Length(); ++i) {
     DataStoreSetting* data = aValue->AppendElement();
     data->name() = stores[i].mName;
     data->originURL() = stores[i].mOriginURL;
     data->manifestURL() = stores[i].mManifestURL;
     data->readOnly() = stores[i].mReadOnly;
+    data->certifiedOnly() = stores[i].mCertifiedOnly;
     data->enabled() = stores[i].mEnabled;
   }
 
   return NS_OK;
 }
 
 nsresult
 DataStoreService::GenerateUUID(nsAString& aID)
diff --git a/dom/datastore/nsIDataStoreService.idl b/dom/datastore/nsIDataStoreService.idl
--- a/dom/datastore/nsIDataStoreService.idl
+++ b/dom/datastore/nsIDataStoreService.idl
@@ -4,24 +4,25 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 
 interface nsIDOMWindow;
 interface nsIPrincipal;
 interface nsIArray;
 
-[scriptable, uuid(79944b1c-187d-11e4-abb6-74d02b97e723)]
+[scriptable, uuid(96073cb5-1ba7-4bda-a037-03b7d9f915c9)]
 interface nsIDataStoreService : nsISupports
 {
   void installDataStore(in unsigned long appId,
                         in DOMString name,
                         in DOMString originURL,
                         in DOMString manifestURL,
-                        in boolean readOnly);
+                        in boolean readOnly,
+                        in boolean certifiedOnly);
 
   void installAccessDataStore(in unsigned long appId,
                               in DOMString name,
                               in DOMString originURL,
                               in DOMString manifestURL,
                               in boolean readOnly);
 
   nsISupports getDataStores(in nsIDOMWindow window,
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -351,16 +351,17 @@ struct DataStorageItem {
   DataStorageType type;
 };
 
 struct DataStoreSetting {
   nsString name;
   nsString originURL;
   nsString manifestURL;
   bool readOnly;
+  bool certifiedOnly;
   bool enabled;
 };
 
 // Note: Any changes to this structure should also be changed in
 // FileSystemUpdate below.
 struct VolumeInfo {
   nsString name;
   nsString mountPoint;
