# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  c36fd61a75404329fa682d3abaa334edf1e4f308
Bug 1217544 - Implement one-off BackgroundSync API. Part 6: Online state observer. r=baku

diff --git a/dom/backgroundsync/OnlineStateObserver.cpp b/dom/backgroundsync/OnlineStateObserver.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/OnlineStateObserver.cpp
@@ -0,0 +1,149 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "OnlineStateObserver.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsIOService.h"
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * OnlineStateChangeNotification
+ */
+class OnlineStateChangeNotification final : public Runnable
+{
+public:
+  OnlineStateChangeNotification(OnlineStateObserver::Listener* aListener,
+                                const OnlineStateObserver::OnlineState aState)
+    : mListener(aListener)
+    , mState(aState)
+  {
+    MOZ_ASSERT(mListener);
+  }
+
+  NS_IMETHOD
+  Run() override
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(mListener);
+
+    mListener->OnOnlineStateChanged(mState);
+
+    return NS_OK;
+  }
+
+private:
+  ~OnlineStateChangeNotification() {}
+
+  OnlineStateObserver::Listener* mListener;
+  OnlineStateObserver::OnlineState mState;
+};
+
+/**
+ * OnlineStateObserver
+ */
+
+// static
+already_AddRefed<OnlineStateObserver>
+OnlineStateObserver::Create(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<OnlineStateObserver> observer = new OnlineStateObserver(aListener);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(observer));
+
+  return observer.forget();
+}
+
+OnlineStateObserver::OnlineStateObserver(Listener* aListener)
+  : mListener(aListener)
+  , mInitiatingThread(NS_GetCurrentThread())
+  , mShuttingDown(false)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(mListener);
+}
+
+void
+OnlineStateObserver::RemoveListener(Listener* aListener)
+{
+  MOZ_ASSERT(aListener == mListener);
+  mListener = nullptr;
+}
+
+NS_IMETHODIMP
+OnlineStateObserver::Observe(nsISupports* aSubject, const char* aTopic,
+                             const char16_t* aData)
+{
+  AssertIsOnMainThread();
+  MOZ_ASSERT(!strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC) ||
+             !strcmp(aTopic, "xpcom-shutdown"));
+
+  // During xpcom-shutdown we do a nsIOService:SetOffline that
+  // triggers a notification that we should ignore cause the
+  // listener might already be gone.
+  if (!strcmp(aTopic, "xpcom-shutdown")) {
+    mShuttingDown = true;
+  }
+
+  if (mShuttingDown) {
+    return NS_OK;
+  }
+
+  OnlineState state = OFFLINE;
+  if (nsDependentString(aData).EqualsLiteral(NS_IOSERVICE_ONLINE)) {
+    state = ONLINE;
+  }
+
+  mInitiatingThread->Dispatch(
+      new OnlineStateChangeNotification(mListener, state), NS_DISPATCH_NORMAL);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+OnlineStateObserver::Run()
+{
+  AssertIsOnMainThread();
+
+  nsCOMPtr<nsIObserverService> os = services::GetObserverService();
+  NS_ENSURE_STATE(os);
+
+  // The observer service holds us alive.
+  nsresult rv = os->AddObserver(this, NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
+                                /* holdsWeak */ false);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // The observer service holds us alive.
+  rv = os->AddObserver(this, "xpcom-shutdown", /* holdsWeak */ false);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  bool offline = true;
+  nsCOMPtr<nsIIOService> ioService = services::GetIOService();
+  NS_ENSURE_STATE(ioService);
+  NS_WARN_IF(NS_FAILED(ioService->GetOffline(&offline)));
+
+  OnlineState state = UNKNOWN;
+  if (offline) {
+    state = OFFLINE;
+  } else {
+    state = ONLINE;
+  }
+
+  mInitiatingThread->Dispatch(
+      new OnlineStateChangeNotification(mListener, state), NS_DISPATCH_NORMAL);
+
+  return NS_OK;
+}
+
+NS_IMPL_ISUPPORTS(OnlineStateObserver, nsIRunnable, nsIObserver)
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/OnlineStateObserver.h b/dom/backgroundsync/OnlineStateObserver.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/OnlineStateObserver.h
@@ -0,0 +1,64 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_OnlineStateObserver_h
+#define mozilla_dom_OnlineStateObserver_h
+
+namespace mozilla {
+namespace dom {
+
+class OnlineStateObserver final : public nsIRunnable
+                                , public nsIObserver
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+  NS_DECL_NSIOBSERVER
+
+  typedef enum {
+    ONLINE,
+    OFFLINE,
+    UNKNOWN
+  } OnlineState;
+
+  // An interface to be implemented by code wishing to use the
+  // OnlineStateObserver.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the OnlineStateObserver to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnOnlineStateChanged(OnlineState aState) = 0;
+  };
+
+  static already_AddRefed<OnlineStateObserver>
+  Create(Listener* aListener);
+
+  // The Listener must call RemoveListener() when it no
+  // longer need to receive online state change notifications.
+  void RemoveListener(Listener* aListener);
+
+private:
+  OnlineStateObserver(Listener* aListener);
+  ~OnlineStateObserver() {};
+
+  // Weak reference cleared by RemoveListener().
+  Listener* mListener;
+  RefPtr<nsIThread> mInitiatingThread;
+
+  // On xpcom-shutdown we do a nsIOService:SetOffline that
+  // triggers a notification that we should ignore cause the
+  // listener might already be gone.
+  bool mShuttingDown;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_OnlineStateObserver_h
+
+
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -6,23 +6,25 @@
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
     'BackgroundSyncParent.cpp',
+    'OnlineStateObserver.cpp',
     'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
-    '/dom/workers'
+    '/dom/workers',
+    '/netwerk/base'
 ]
 
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
