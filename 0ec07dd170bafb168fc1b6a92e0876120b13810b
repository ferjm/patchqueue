
# HG changeset patch
# User Fernando Jimenez Moreno <ferjmoreno@gmail.com>
# Date 1492534783 -7200
# Node ID 0ec07dd170bafb168fc1b6a92e0876120b13810b
# Parent  a477e80f03b61be9961bc61770a2b55cce139b91
Bug 1355408 - Part 1: Support @-moz-document rule in stylo. r?xidorn

diff --git a/layout/style/ServoBindings.cpp b/layout/style/ServoBindings.cpp
--- a/layout/style/ServoBindings.cpp
+++ b/layout/style/ServoBindings.cpp
@@ -22,16 +22,17 @@
 #include "nsIDOMNode.h"
 #include "nsIDocument.h"
 #include "nsIDocumentInlines.h"
 #include "nsIFrame.h"
 #include "nsINode.h"
 #include "nsIPresShell.h"
 #include "nsIPresShellInlines.h"
 #include "nsIPrincipal.h"
+#include "nsIURI.h"
 #include "nsFontMetrics.h"
 #include "nsMappedAttributes.h"
 #include "nsMediaFeatures.h"
 #include "nsNameSpaceManager.h"
 #include "nsNetUtil.h"
 #include "nsRuleNode.h"
 #include "nsString.h"
 #include "nsStyleStruct.h"
@@ -1935,16 +1936,36 @@ Gecko_RegisterProfilerThread(const char*
 }
 
 void
 Gecko_UnregisterProfilerThread()
 {
   profiler_unregister_thread();
 }
 
+bool
+Gecko_DocumentRule_UseForPresentation(RawGeckoPresContextBorrowed aPresContext,
+                                      const nsACString* aPattern,
+                                      css::URLMatchingFunction aURLMatchingFunction)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsIDocument *doc = aPresContext->Document();
+  nsIURI *docURI = doc->GetDocumentURI();
+  nsAutoCString docURISpec;
+  if (docURI) {
+    // If GetSpec fails (due to OOM) just skip these URI-specific CSS rules.
+    nsresult rv = docURI->GetSpec(docURISpec);
+    NS_ENSURE_SUCCESS(rv, false);
+  }
+
+  return css::DocumentRule::UseForPresentation(doc, docURI, docURISpec,
+                                               *aPattern, aURLMatchingFunction);
+}
+
 #include "nsStyleStructList.h"
 
 #undef STYLE_STRUCT
 
 #ifndef MOZ_STYLO
 #define SERVO_BINDING_FUNC(name_, return_, ...)                               \
   return_ name_(__VA_ARGS__) {                                                \
     MOZ_CRASH("stylo: shouldn't be calling " #name_ "in a non-stylo build");  \
diff --git a/layout/style/ServoBindings.h b/layout/style/ServoBindings.h
--- a/layout/style/ServoBindings.h
+++ b/layout/style/ServoBindings.h
@@ -8,16 +8,17 @@
 #define mozilla_ServoBindings_h
 
 #include <stdint.h>
 
 #include "mozilla/ServoTypes.h"
 #include "mozilla/ServoBindingTypes.h"
 #include "mozilla/ServoElementSnapshot.h"
 #include "mozilla/css/SheetParsingMode.h"
+#include "mozilla/css/URLMatchingFunction.h"
 #include "mozilla/EffectCompositor.h"
 #include "mozilla/ComputedTimingFunction.h"
 #include "nsChangeHint.h"
 #include "nsCSSPseudoClasses.h"
 #include "nsStyleStruct.h"
 
 /*
  * API for Servo to access Gecko data structures. This file must compile as valid
@@ -481,15 +482,19 @@ bool Gecko_MatchStringArgPseudo(RawGecko
 #include "nsStyleStructList.h"
 #undef STYLE_STRUCT
 
 void Gecko_Construct_nsStyleVariables(nsStyleVariables* ptr);
 
 void Gecko_RegisterProfilerThread(const char* name);
 void Gecko_UnregisterProfilerThread();
 
+bool Gecko_DocumentRule_UseForPresentation(RawGeckoPresContextBorrowed,
+                                           const nsACString* aPattern,
+                                           mozilla::css::URLMatchingFunction aURLMatchingFunction);
+
 #define SERVO_BINDING_FUNC(name_, return_, ...) return_ name_(__VA_ARGS__);
 #include "mozilla/ServoBindingList.h"
 #undef SERVO_BINDING_FUNC
 
 } // extern "C"
 
 #endif // mozilla_ServoBindings_h
diff --git a/layout/style/URLMatchingFunction.h b/layout/style/URLMatchingFunction.h
new file mode 100644
--- /dev/null
+++ b/layout/style/URLMatchingFunction.h
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_css_URLMatchingFunction_h
+#define mozilla_css_URLMatchingFunction_h
+
+namespace mozilla {
+namespace css {
+
+/**
+ * Enum defining the type of URL matching function for a @-moz-document rule
+ * condition.
+ */
+enum URLMatchingFunction {
+  eURL = 0,
+  eURLPrefix,
+  eDomain,
+  eRegExp,
+};
+
+} // namespace css
+} // namespace mozilla
+
+#endif // mozilla_css_URLMatchingFunction_h
diff --git a/layout/style/moz.build b/layout/style/moz.build
--- a/layout/style/moz.build
+++ b/layout/style/moz.build
@@ -148,16 +148,17 @@ EXPORTS.mozilla.css += [
     'GroupRule.h',
     'ImageLoader.h',
     'ImportRule.h',
     'Loader.h',
     'NameSpaceRule.h',
     'Rule.h',
     'SheetParsingMode.h',
     'StyleRule.h',
+    'URLMatchingFunction.h',
 ]
 
 UNIFIED_SOURCES += [
     'AnimationCollection.cpp',
     'BindingStyleRule.cpp',
     'CounterStyleManager.cpp',
     'CSS.cpp',
     'CSSLexer.cpp',
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -23,16 +23,17 @@
 #include "nsAlgorithm.h"
 #include "nsCSSProps.h"
 #include "nsCSSKeywords.h"
 #include "nsCSSScanner.h"
 #include "mozilla/css/ErrorReporter.h"
 #include "mozilla/css/Loader.h"
 #include "mozilla/css/StyleRule.h"
 #include "mozilla/css/ImportRule.h"
+#include "mozilla/css/URLMatchingFunction.h"
 #include "nsCSSRules.h"
 #include "nsCSSFontFaceRule.h"
 #include "mozilla/css/NameSpaceRule.h"
 #include "nsTArray.h"
 #include "mozilla/StyleSheetInlines.h"
 #include "mozilla/css/Declaration.h"
 #include "nsStyleConsts.h"
 #include "nsNetUtil.h"
@@ -3900,38 +3901,38 @@ CSSParserImpl::ParseMozDocumentRule(Rule
       REPORT_UNEXPECTED_TOKEN(PEMozDocRuleBadFunc2);
       UngetToken();
       delete urls;
       return false;
     }
     css::DocumentRule::URL *cur = *next = new css::DocumentRule::URL;
     next = &cur->next;
     if (mToken.mType == eCSSToken_URL) {
-      cur->func = css::DocumentRule::eURL;
+      cur->func = URLMatchingFunction::eURL;
       CopyUTF16toUTF8(mToken.mIdent, cur->url);
     } else if (mToken.mIdent.LowerCaseEqualsLiteral("regexp")) {
       // regexp() is different from url-prefix() and domain() (but
       // probably the way they *should* have been* in that it requires a
       // string argument, and doesn't try to behave like url().
-      cur->func = css::DocumentRule::eRegExp;
+      cur->func = URLMatchingFunction::eRegExp;
       GetToken(true);
       // copy before we know it's valid (but before ExpectSymbol changes
       // mToken.mIdent)
       CopyUTF16toUTF8(mToken.mIdent, cur->url);
       if (eCSSToken_String != mToken.mType || !ExpectSymbol(')', true)) {
         REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotString);
         SkipUntil(')');
         delete urls;
         return false;
       }
     } else {
       if (mToken.mIdent.LowerCaseEqualsLiteral("url-prefix")) {
-        cur->func = css::DocumentRule::eURLPrefix;
+        cur->func = URLMatchingFunction::eURLPrefix;
       } else if (mToken.mIdent.LowerCaseEqualsLiteral("domain")) {
-        cur->func = css::DocumentRule::eDomain;
+        cur->func = URLMatchingFunction::eDomain;
       }
 
       NS_ASSERTION(!mHavePushBack, "mustn't have pushback at this point");
       mScanner->NextURL(mToken);
       if (mToken.mType != eCSSToken_URL) {
         REPORT_UNEXPECTED_TOKEN(PEMozDocRuleNotURI);
         SkipUntil(')');
         delete urls;
diff --git a/layout/style/nsCSSRules.cpp b/layout/style/nsCSSRules.cpp
--- a/layout/style/nsCSSRules.cpp
+++ b/layout/style/nsCSSRules.cpp
@@ -676,47 +676,61 @@ DocumentRule::UseForPresentation(nsPresC
   nsAutoCString docURISpec;
   if (docURI) {
     // If GetSpec fails (due to OOM) just skip these URI-specific CSS rules.
     nsresult rv = docURI->GetSpec(docURISpec);
     NS_ENSURE_SUCCESS(rv, false);
   }
 
   for (URL *url = mURLs; url; url = url->next) {
-    switch (url->func) {
-      case eURL: {
-        if (docURISpec == url->url)
-          return true;
-      } break;
-      case eURLPrefix: {
-        if (StringBeginsWith(docURISpec, url->url))
+    if (UseForPresentation(doc, docURI, docURISpec, url->url, url->func)) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool
+DocumentRule::UseForPresentation(nsIDocument* aDoc,
+                                 nsIURI* aDocURI,
+                                 const nsACString& aDocURISpec,
+                                 const nsACString& aPattern,
+                                 URLMatchingFunction aUrlMatchingFunction)
+{
+  switch (aUrlMatchingFunction) {
+    case eURL: {
+      if (aDocURISpec == aPattern)
+        return true;
+    } break;
+    case eURLPrefix: {
+      if (StringBeginsWith(aDocURISpec, aPattern))
+        return true;
+    } break;
+    case eDomain: {
+      nsAutoCString host;
+      if (aDocURI)
+        aDocURI->GetHost(host);
+      int32_t lenDiff = host.Length() - aPattern.Length();
+      if (lenDiff == 0) {
+        if (host == aPattern)
           return true;
-      } break;
-      case eDomain: {
-        nsAutoCString host;
-        if (docURI)
-          docURI->GetHost(host);
-        int32_t lenDiff = host.Length() - url->url.Length();
-        if (lenDiff == 0) {
-          if (host == url->url)
-            return true;
-        } else {
-          if (StringEndsWith(host, url->url) &&
-              host.CharAt(lenDiff - 1) == '.')
-            return true;
-        }
-      } break;
-      case eRegExp: {
-        NS_ConvertUTF8toUTF16 spec(docURISpec);
-        NS_ConvertUTF8toUTF16 regex(url->url);
-        if (nsContentUtils::IsPatternMatching(spec, regex, doc)) {
+      } else {
+        if (StringEndsWith(host, aPattern) &&
+            host.CharAt(lenDiff - 1) == '.')
           return true;
-        }
-      } break;
-    }
+      }
+    } break;
+    case eRegExp: {
+      NS_ConvertUTF8toUTF16 spec(aDocURISpec);
+      NS_ConvertUTF8toUTF16 regex(aPattern);
+      if (nsContentUtils::IsPatternMatching(spec, regex, aDoc)) {
+        return true;
+      }
+    } break;
   }
 
   return false;
 }
 
 DocumentRule::URL::~URL()
 {
   NS_CSS_DELETE_LIST_MEMBER(DocumentRule::URL, this, next);
@@ -1162,17 +1176,17 @@ nsCSSFontFaceStyleDecl::GetParentObject(
 JSObject*
 nsCSSFontFaceStyleDecl::WrapObject(JSContext *cx, JS::Handle<JSObject*> aGivenProto)
 {
   return mozilla::dom::CSSStyleDeclarationBinding::Wrap(cx, this, aGivenProto);
 }
 
 // -------------------------------------------
 // nsCSSFontFaceRule
-// 
+//
 
 /* virtual */ already_AddRefed<css::Rule>
 nsCSSFontFaceRule::Clone() const
 {
   RefPtr<css::Rule> clone = new nsCSSFontFaceRule(*this);
   return clone.forget();
 }
 
diff --git a/layout/style/nsCSSRules.h b/layout/style/nsCSSRules.h
--- a/layout/style/nsCSSRules.h
+++ b/layout/style/nsCSSRules.h
@@ -12,16 +12,17 @@
 #include "Declaration.h"
 #include "StyleRule.h"
 #include "gfxFontFeatures.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/MemoryReporting.h"
 #include "mozilla/Move.h"
 #include "mozilla/SheetType.h"
 #include "mozilla/css/GroupRule.h"
+#include "mozilla/css/URLMatchingFunction.h"
 #include "mozilla/dom/CSSMediaRule.h"
 #include "mozilla/dom/CSSPageRule.h"
 #include "nsAutoPtr.h"
 #include "nsCSSPropertyID.h"
 #include "nsCSSValue.h"
 #include "nsDOMCSSDeclaration.h"
 #include "nsIDOMCSSConditionRule.h"
 #include "nsIDOMCSSCounterStyleRule.h"
@@ -118,29 +119,28 @@ public:
   // nsIDOMCSSConditionRule interface
   NS_DECL_NSIDOMCSSCONDITIONRULE
 
   // nsIDOMCSSMozDocumentRule interface
   NS_DECL_NSIDOMCSSMOZDOCUMENTRULE
 
   // rest of GroupRule
   virtual bool UseForPresentation(nsPresContext* aPresContext,
-                                    nsMediaQueryResultCacheKey& aKey) override;
+                                  nsMediaQueryResultCacheKey& aKey) override;
 
   bool UseForPresentation(nsPresContext* aPresContext);
 
-  enum Function {
-    eURL,
-    eURLPrefix,
-    eDomain,
-    eRegExp
-  };
+  static bool UseForPresentation(nsIDocument* aDoc,
+                                 nsIURI* aDocURI,
+                                 const nsACString& aDocURISpec,
+                                 const nsACString& aPattern,
+                                 URLMatchingFunction aUrlMatchingFunction);
 
   struct URL {
-    Function func;
+    URLMatchingFunction func;
     nsCString url;
     URL *next;
 
     URL() : next(nullptr) {}
     URL(const URL& aOther)
       : func(aOther.func)
       , url(aOther.url)
       , next(aOther.next ? new URL(*aOther.next) : nullptr)
diff --git a/servo/Cargo.lock b/servo/Cargo.lock
--- a/servo/Cargo.lock
+++ b/servo/Cargo.lock
@@ -936,16 +936,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.21 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
  "stylo_tests 0.0.1",
 ]
 
 [[package]]
diff --git a/servo/components/script/dom/cssrule.rs b/servo/components/script/dom/cssrule.rs
--- a/servo/components/script/dom/cssrule.rs
+++ b/servo/components/script/dom/cssrule.rs
@@ -79,16 +79,17 @@ impl CSSRule {
             StyleCssRule::Style(s) => Root::upcast(CSSStyleRule::new(window, parent_stylesheet, s)),
             StyleCssRule::FontFace(s) => Root::upcast(CSSFontFaceRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Keyframes(s) => Root::upcast(CSSKeyframesRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Media(s) => Root::upcast(CSSMediaRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Namespace(s) => Root::upcast(CSSNamespaceRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Viewport(s) => Root::upcast(CSSViewportRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Supports(s) => Root::upcast(CSSSupportsRule::new(window, parent_stylesheet, s)),
             StyleCssRule::Page(_) => unreachable!(),
+            StyleCssRule::Document(_) => unimplemented!(), // TODO
         }
     }
 
     /// Sets owner sheet/rule to null
     pub fn detach(&self) {
         self.deparent();
         // should set parent rule to None when we add parent rule support
     }
diff --git a/servo/components/style/Cargo.toml b/servo/components/style/Cargo.toml
--- a/servo/components/style/Cargo.toml
+++ b/servo/components/style/Cargo.toml
@@ -60,11 +60,11 @@ time = "0.1"
 unicode-segmentation = "1.0"
 
 [target.'cfg(windows)'.dependencies]
 kernel32-sys = "0.2"
 
 [build-dependencies]
 lazy_static = "0.2"
 log = "0.3"
-bindgen = { version = "0.22", optional = true }
+bindgen = {version = "0.22", optional = true}
 regex = {version = "0.2", optional = true}
 walkdir = "1.0"
diff --git a/servo/components/style/build_gecko.rs b/servo/components/style/build_gecko.rs
--- a/servo/components/style/build_gecko.rs
+++ b/servo/components/style/build_gecko.rs
@@ -298,16 +298,17 @@ mod bindings {
             .include(add_include("mozilla/ServoElementSnapshot.h"))
             .include(add_include("mozilla/dom/Element.h"))
             .include(add_include("mozilla/dom/NameSpaceConstants.h"))
             .include(add_include("mozilla/LookAndFeel.h"))
             .include(add_include("mozilla/ServoBindings.h"))
             .include(add_include("nsCSSFontFaceRule.h"))
             .include(add_include("nsMediaFeatures.h"))
             .include(add_include("nsMediaList.h"))
+            .include(add_include("mozilla/css/Loader.h"))
             // FIXME(emilio): Incrementally remove these "pub use"s. Probably
             // mozilla::css and mozilla::dom are easier.
             .raw_line("pub use self::root::*;")
             .raw_line("pub use self::root::mozilla::*;")
             .raw_line("pub use self::root::mozilla::css::*;")
             .raw_line("pub use self::root::mozilla::dom::*;")
             .raw_line("use atomic_refcell::AtomicRefCell;")
             .raw_line("use data::ElementData;")
@@ -335,16 +336,17 @@ mod bindings {
             "mozilla::AnimationPropertySegment",
             "mozilla::ComputedTiming",
             "mozilla::ComputedTimingFunction",
             "mozilla::ComputedTimingFunction::BeforeFlag",
             "mozilla::ServoStyleSheet",
             "mozilla::ServoElementSnapshot.*",
             "mozilla::CSSPseudoClassType",
             "mozilla::css::SheetParsingMode",
+            "mozilla::css::URLMatchingFunction",
             "mozilla::HalfCorner",
             "mozilla::PropertyStyleAnimationValuePair",
             "mozilla::TraversalRestyleBehavior",
             "mozilla::TraversalRootBehavior",
             "mozilla::StyleShapeRadius",
             "mozilla::StyleGrid.*",
             "mozilla::UpdateAnimationsTasks",
             "mozilla::LookAndFeel",
@@ -719,16 +721,17 @@ mod bindings {
             "nscolor",
             "nscoord",
             "nsresult",
             "Loader",
             "ServoStyleSheet",
             "EffectCompositor_CascadeLevel",
             "UpdateAnimationsTasks",
             "LengthParsingMode",
+            "URLMatchingFunction",
         ];
         struct ArrayType {
             cpp_type: &'static str,
             rust_type: &'static str
         }
         let array_types = [
             ArrayType { cpp_type: "uintptr_t", rust_type: "usize" },
         ];
diff --git a/servo/components/style/document.rs b/servo/components/style/document.rs
new file mode 100644
--- /dev/null
+++ b/servo/components/style/document.rs
@@ -0,0 +1,206 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+//! [@document rules](https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#at-document)
+//! initially in CSS Conditional Rules Module Level 3, @document has been postponed to the level 4.
+//! We implement the prefixed `@-moz-document`.
+
+use cssparser::{Parser, Token};
+
+#[cfg(feature = "gecko")]
+use gecko_bindings::bindings::Gecko_DocumentRule_UseForPresentation;
+#[cfg(feature = "gecko")]
+use gecko_bindings::structs::URLMatchingFunction as GeckoUrlMatchingFunction;
+use media_queries::Device;
+#[cfg(feature = "gecko")]
+use nsstring::nsCString;
+use parser::{Parse, ParserContext};
+use std::fmt;
+use style_traits::ToCss;
+use values::specified::url::SpecifiedUrl;
+
+/// A URL matching function for a `@document` rule's condition.
+#[derive(Debug)]
+pub enum UrlMatchingFunction {
+    /// Exact url matching function.
+    Url(SpecifiedUrl),
+    /// Url prefix matching function.
+    UrlPrefix(String),
+    /// Domain matching function.
+    Domain(String),
+    /// Regular expression matching function.
+    RegExp(String),
+}
+
+impl UrlMatchingFunction {
+    /// Parse a URL matching function for a`@document` rule's condition.
+    pub fn parse(context: &ParserContext, input: &mut Parser)
+        -> Result<UrlMatchingFunction, ()> {
+        if input.try(|input| input.expect_function_matching("url-prefix")).is_ok() {
+            input.parse_nested_block(|input| {
+                let start = input.position();
+                loop {
+                    match input.next() {
+                        Ok(Token::QuotedString(value)) => {
+                            return Ok(UrlMatchingFunction::UrlPrefix(value.into_owned()));
+                        },
+                        Ok(_) => {},
+                        Err(_) => { break; }
+                    };
+                }
+                Ok(UrlMatchingFunction::UrlPrefix(input.slice_from(start).to_string()))
+            })
+        } else if input.try(|input| input.expect_function_matching("domain")).is_ok() {
+            input.parse_nested_block(|input| {
+                let start = input.position();
+                loop {
+                    match input.next() {
+                        Ok(Token::QuotedString(value)) => {
+                            return Ok(UrlMatchingFunction::Domain(value.into_owned()));
+                        },
+                        Ok(_) => {},
+                        Err(_) => { break; }
+                    };
+                }
+                Ok(UrlMatchingFunction::Domain(input.slice_from(start).to_string()))
+            })
+        } else if input.try(|input| input.expect_function_matching("regexp")).is_ok() {
+            input.parse_nested_block(|input| {
+                Ok(UrlMatchingFunction::RegExp(input.expect_string()?.into_owned()))
+            })
+        } else if let Ok(url) = input.try(|input| SpecifiedUrl::parse(context, input)) {
+            Ok(UrlMatchingFunction::Url(url))
+        } else {
+            Err(())
+        }
+    }
+
+    #[cfg(feature = "gecko")]
+    /// Evaluate a URL matching function.
+    pub fn evaluate(&self, device: &Device) -> bool {
+        match *self {
+            /// Exact URL matching function. It evaluates to true whenever the
+            /// URL of the document being styled is exactly the URL given.
+            UrlMatchingFunction::Url(ref url) => {
+                unsafe {
+                    let url = nsCString::from(url.as_str());
+                    Gecko_DocumentRule_UseForPresentation(&*device.pres_context,
+                                                          &*url,
+                                                          GeckoUrlMatchingFunction::eURL)
+                }
+            },
+            /// URL prefix matching function. It evaluates to true whenever the
+            /// URL of the document being styled has the argument to the
+            /// function as an initial substring (which is true when the two
+            /// strings are equal). When the argument is the empty string,
+            /// it evaluates to true for all documents.
+            UrlMatchingFunction::UrlPrefix(ref url_prefix) => {
+                unsafe {
+                    let url_prefix = nsCString::from(url_prefix);
+                    Gecko_DocumentRule_UseForPresentation(&*device.pres_context,
+                                                          &*url_prefix,
+                                                          GeckoUrlMatchingFunction::eURLPrefix)
+                }
+            },
+            /// Domain matching function. It evaluates to true whenever the URL
+            /// of the document being styled has a host subcomponent and that
+            /// host subcomponent is exactly the argument to the ‘domain()’
+            /// function or a final substring of the host component is a
+            /// period (U+002E) immediately followed by the argument to the
+            /// ‘domain()’ function.
+            UrlMatchingFunction::Domain(ref domain) => {
+                unsafe {
+                    let domain = nsCString::from(domain);
+                    Gecko_DocumentRule_UseForPresentation(&*device.pres_context,
+                                                          &*domain,
+                                                          GeckoUrlMatchingFunction::eDomain)
+                }
+            },
+            /// Regular expression matching function. It evaluates to true
+            /// whenever the regular expression matches the entirety of the URL
+            /// of the document being styled.
+            UrlMatchingFunction::RegExp(ref pattern) => {
+                unsafe {
+                    let pattern = nsCString::from(pattern);
+                    Gecko_DocumentRule_UseForPresentation(&*device.pres_context,
+                                                          &*pattern,
+                                                          GeckoUrlMatchingFunction::eRegExp)
+                }
+            },
+        }
+    }
+
+    #[cfg(not(feature = "gecko"))]
+    /// Evaluate a URL matching function.
+    pub fn evaluate(&self, _: &Device) -> bool {
+        false
+    }
+}
+
+impl ToCss for UrlMatchingFunction {
+    fn to_css<W>(&self, dest: &mut W) -> fmt::Result
+        where W: fmt::Write {
+        match *self {
+            UrlMatchingFunction::Url(ref url) => {
+                url.to_css(dest)
+            },
+            UrlMatchingFunction::UrlPrefix(ref url_prefix) => {
+                dest.write_str("url-prefix(")?;
+                dest.write_str(url_prefix)?;
+                dest.write_str(")")
+            },
+            UrlMatchingFunction::Domain(ref domain) => {
+                dest.write_str("domain(")?;
+                dest.write_str(domain)?;
+                dest.write_str(")")
+            },
+            UrlMatchingFunction::RegExp(ref regex) => {
+                dest.write_str("regexp(")?;
+                dest.write_str(regex)?;
+                dest.write_str(")")
+            },
+        }
+    }
+}
+
+/// A `@document` rule's condition.
+///
+/// https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#at-document
+///
+/// The `@document` rule's condition is written as a comma-separated list of
+/// URL matching functions, and the condition evaluates to true whenever any
+/// one of those functions evaluates to true.
+#[derive(Debug)]
+pub struct DocumentCondition(Vec<UrlMatchingFunction>);
+
+impl DocumentCondition {
+    /// Parse a document condition.
+    pub fn parse(context: &ParserContext, input: &mut Parser)
+        -> Result<Self, ()> {
+        input.parse_comma_separated(|input| UrlMatchingFunction::parse(context, input))
+             .map(DocumentCondition)
+    }
+
+    /// Evaluate a document condition.
+    pub fn evaluate(&self, device: &Device) -> bool {
+        self.0.iter().any(|ref url_matching_function|
+            url_matching_function.evaluate(device)
+        )
+    }
+}
+
+impl ToCss for DocumentCondition {
+    fn to_css<W>(&self, dest: &mut W) -> fmt::Result
+        where W: fmt::Write {
+        let mut iter = self.0.iter();
+        let first = iter.next()
+            .expect("Empty DocumentCondition, should contain at least one URL matching function");
+        first.to_css(dest)?;
+        for url_matching_function in iter {
+            dest.write_str(", ")?;
+            url_matching_function.to_css(dest)?;
+        }
+        Ok(())
+    }
+}
diff --git a/servo/components/style/lib.rs b/servo/components/style/lib.rs
--- a/servo/components/style/lib.rs
+++ b/servo/components/style/lib.rs
@@ -86,16 +86,17 @@ pub mod animation;
 #[cfg(feature = "servo")] pub mod attr;
 pub mod bezier;
 pub mod bloom;
 pub mod cache;
 pub mod cascade_info;
 pub mod context;
 pub mod custom_properties;
 pub mod data;
+pub mod document;
 pub mod dom;
 pub mod element_state;
 #[cfg(feature = "servo")] mod encoding_support;
 pub mod error_reporting;
 pub mod font_face;
 pub mod font_metrics;
 #[cfg(feature = "gecko")] #[allow(unsafe_code)] pub mod gecko;
 #[cfg(feature = "gecko")] #[allow(unsafe_code)] pub mod gecko_bindings;
diff --git a/servo/components/style/stylesheets.rs b/servo/components/style/stylesheets.rs
--- a/servo/components/style/stylesheets.rs
+++ b/servo/components/style/stylesheets.rs
@@ -5,16 +5,17 @@
 //! Style sheets and their CSS rules.
 
 #![deny(missing_docs)]
 
 use {Atom, Prefix, Namespace};
 use cssparser::{AtRuleParser, Parser, QualifiedRuleParser};
 use cssparser::{AtRuleType, RuleListParser, Token, parse_one_rule};
 use cssparser::ToCss as ParserToCss;
+use document::DocumentCondition;
 use error_reporting::{ParseErrorReporter, NullReporter};
 #[cfg(feature = "servo")]
 use font_face::FontFaceRuleData;
 use font_face::parse_font_face_block;
 #[cfg(feature = "gecko")]
 pub use gecko::rules::FontFaceRule;
 #[cfg(feature = "gecko")]
 use gecko_bindings::structs::URLExtraData;
@@ -38,17 +39,16 @@ use std::sync::Arc;
 use std::sync::atomic::{AtomicBool, Ordering};
 use str::starts_with_ignore_ascii_case;
 use style_traits::ToCss;
 use stylist::FnvHashMap;
 use supports::SupportsCondition;
 use values::specified::url::SpecifiedUrl;
 use viewport::ViewportRule;
 
-
 /// Extra data that the backend may need to resolve url values.
 #[cfg(not(feature = "gecko"))]
 pub type UrlExtraData = ServoUrl;
 
 /// Extra data that the backend may need to resolve url values.
 #[cfg(feature = "gecko")]
 pub type UrlExtraData = RefPtr<URLExtraData>;
 
@@ -288,16 +288,17 @@ pub enum CssRule {
     Import(Arc<Locked<ImportRule>>),
     Style(Arc<Locked<StyleRule>>),
     Media(Arc<Locked<MediaRule>>),
     FontFace(Arc<Locked<FontFaceRule>>),
     Viewport(Arc<Locked<ViewportRule>>),
     Keyframes(Arc<Locked<KeyframesRule>>),
     Supports(Arc<Locked<SupportsRule>>),
     Page(Arc<Locked<PageRule>>),
+    Document(Arc<Locked<DocumentRule>>),
 }
 
 #[allow(missing_docs)]
 #[derive(PartialEq, Eq, Copy, Clone)]
 pub enum CssRuleType {
     // https://drafts.csswg.org/cssom/#the-cssrule-interface
     Style               = 1,
     Charset             = 2,
@@ -310,16 +311,18 @@ pub enum CssRuleType {
     Keyframe            = 8,
     // https://drafts.csswg.org/cssom/#the-cssrule-interface
     Margin              = 9,
     Namespace           = 10,
     // https://drafts.csswg.org/css-counter-styles-3/#extentions-to-cssrule-interface
     CounterStyle        = 11,
     // https://drafts.csswg.org/css-conditional-3/#extentions-to-cssrule-interface
     Supports            = 12,
+    // https://www.w3.org/TR/2012/WD-css3-conditional-20120911/#extentions-to-cssrule-interface
+    Document            = 13,
     // https://drafts.csswg.org/css-fonts-3/#om-fontfeaturevalues
     FontFeatureValues   = 14,
     // https://drafts.csswg.org/css-device-adapt/#css-rule-interface
     Viewport            = 15,
 }
 
 #[allow(missing_docs)]
 pub enum SingleRuleParseError {
@@ -335,16 +338,17 @@ impl CssRule {
             CssRule::Import(_)    => CssRuleType::Import,
             CssRule::Media(_)     => CssRuleType::Media,
             CssRule::FontFace(_)  => CssRuleType::FontFace,
             CssRule::Keyframes(_) => CssRuleType::Keyframes,
             CssRule::Namespace(_) => CssRuleType::Namespace,
             CssRule::Viewport(_)  => CssRuleType::Viewport,
             CssRule::Supports(_)  => CssRuleType::Supports,
             CssRule::Page(_)      => CssRuleType::Page,
+            CssRule::Document(_)  => CssRuleType::Document,
         }
     }
 
     fn rule_state(&self) -> State {
         match *self {
             // CssRule::Charset(..) => State::Start,
             CssRule::Import(..) => State::Imports,
             CssRule::Namespace(..) => State::Namespaces,
@@ -353,49 +357,58 @@ impl CssRule {
     }
 
     /// Call `f` with the slice of rules directly contained inside this rule.
     ///
     /// Note that only some types of rules can contain rules. An empty slice is
     /// used for others.
     ///
     /// This will not recurse down unsupported @supports rules
-    pub fn with_nested_rules_and_mq<F, R>(&self, guard: &SharedRwLockReadGuard, mut f: F) -> R
-    where F: FnMut(&[CssRule], Option<&MediaList>) -> R {
+    pub fn with_nested_rules_mq_and_doc_rule<F, R>(&self, guard: &SharedRwLockReadGuard, mut f: F) -> R
+    where F: FnMut(&[CssRule], Option<&MediaList>, Option<&DocumentRule>) -> R {
         match *self {
             CssRule::Import(ref lock) => {
                 let rule = lock.read_with(guard);
                 let media = rule.stylesheet.media.read_with(guard);
                 let rules = rule.stylesheet.rules.read_with(guard);
                 // FIXME(emilio): Include the nested rules if the stylesheet is
                 // loaded.
-                f(&rules.0, Some(&media))
+                f(&rules.0, Some(&media), None)
             }
             CssRule::Namespace(_) |
             CssRule::Style(_) |
             CssRule::FontFace(_) |
             CssRule::Viewport(_) |
             CssRule::Keyframes(_) |
             CssRule::Page(_) => {
-                f(&[], None)
+                f(&[], None, None)
             }
             CssRule::Media(ref lock) => {
                 let media_rule = lock.read_with(guard);
                 let mq = media_rule.media_queries.read_with(guard);
                 let rules = &media_rule.rules.read_with(guard).0;
-                f(rules, Some(&mq))
+                f(rules, Some(&mq), None)
             }
             CssRule::Supports(ref lock) => {
                 let supports_rule = lock.read_with(guard);
                 let enabled = supports_rule.enabled;
                 if enabled {
                     let rules = &supports_rule.rules.read_with(guard).0;
-                    f(rules, None)
+                    f(rules, None, None)
                 } else {
-                    f(&[], None)
+                    f(&[], None, None)
+                }
+            }
+            CssRule::Document(ref lock) => {
+                if cfg!(feature = "gecko") {
+                    let document_rule = lock.read_with(guard);
+                    let rules = &document_rule.rules.read_with(guard).0;
+                    f(rules, None, Some(&document_rule))
+                } else {
+                    unimplemented!()
                 }
             }
         }
     }
 
     // input state is None for a nested rule
     // Returns a parsed CSS rule and the final state of the parser
     #[allow(missing_docs)]
@@ -445,16 +458,17 @@ impl ToCssWithGuard for CssRule {
             CssRule::Import(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Style(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::FontFace(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Viewport(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Keyframes(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Media(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Supports(ref lock) => lock.read_with(guard).to_css(guard, dest),
             CssRule::Page(ref lock) => lock.read_with(guard).to_css(guard, dest),
+            CssRule::Document(ref lock) => lock.read_with(guard).to_css(guard, dest),
         }
     }
 }
 
 #[derive(Debug, PartialEq)]
 #[allow(missing_docs)]
 pub struct NamespaceRule {
     /// `None` for the default Namespace
@@ -639,16 +653,39 @@ impl ToCssWithGuard for StyleRule {
         Ok(())
     }
 }
 
 /// A @font-face rule
 #[cfg(feature = "servo")]
 pub type FontFaceRule = FontFaceRuleData;
 
+#[derive(Debug)]
+/// A @-moz-document rule
+pub struct DocumentRule {
+    /// The parsed condition
+    pub condition: DocumentCondition,
+    /// Child rules
+    pub rules: Arc<Locked<CssRules>>,
+}
+
+impl ToCssWithGuard for DocumentRule {
+    fn to_css<W>(&self, guard: &SharedRwLockReadGuard, dest: &mut W) -> fmt::Result
+    where W: fmt::Write {
+        try!(dest.write_str("@-moz-document "));
+        try!(self.condition.to_css(dest));
+        try!(dest.write_str(" {"));
+        for rule in self.rules.read_with(guard).0.iter() {
+            try!(dest.write_str(" "));
+            try!(rule.to_css(guard, dest));
+        }
+        dest.write_str(" }")
+    }
+}
+
 impl Stylesheet {
     /// Updates an empty stylesheet from a given string of text.
     pub fn update_from_str(existing: &Stylesheet,
                            css: &str,
                            url_data: &UrlExtraData,
                            stylesheet_loader: Option<&StylesheetLoader>,
                            error_reporter: &ParseErrorReporter) {
         let mut namespaces = Namespaces::default();
@@ -795,22 +832,29 @@ impl Stylesheet {
         self.disabled.swap(disabled, Ordering::SeqCst) != disabled
     }
 }
 
 fn effective_rules<F>(rules: &[CssRule], device: &Device, guard: &SharedRwLockReadGuard, f: &mut F)
 where F: FnMut(&CssRule) {
     for rule in rules {
         f(rule);
-        rule.with_nested_rules_and_mq(guard, |rules, mq| {
+        rule.with_nested_rules_mq_and_doc_rule(guard, |rules, mq, doc_rule| {
             if let Some(media_queries) = mq {
                 if !media_queries.evaluate(device) {
                     return
                 }
             }
+
+            if let Some(doc_rule) = doc_rule {
+                if !doc_rule.condition.evaluate(device) {
+                    return
+                }
+            }
+
             effective_rules(rules, device, guard, f)
         })
     }
 }
 
 macro_rules! rule_filter {
     ($( $method: ident($variant:ident => $rule_type: ident), )+) => {
         impl Stylesheet {
@@ -833,16 +877,17 @@ macro_rules! rule_filter {
 rule_filter! {
     effective_style_rules(Style => StyleRule),
     effective_media_rules(Media => MediaRule),
     effective_font_face_rules(FontFace => FontFaceRule),
     effective_viewport_rules(Viewport => ViewportRule),
     effective_keyframes_rules(Keyframes => KeyframesRule),
     effective_supports_rules(Supports => SupportsRule),
     effective_page_rules(Page => PageRule),
+    effective_document_rules(Document => DocumentRule),
 }
 
 /// The stylesheet loader is the abstraction used to trigger network requests
 /// for `@import` rules.
 pub trait StylesheetLoader {
     /// Request a stylesheet after parsing a given `@import` rule.
     ///
     /// The called code is responsible to update the `stylesheet` rules field
@@ -920,16 +965,18 @@ enum AtRulePrelude {
     /// An @supports rule, with its conditional
     Supports(SupportsCondition),
     /// A @viewport rule prelude.
     Viewport,
     /// A @keyframes rule, with its animation name and vendor prefix if exists.
     Keyframes(Atom, Option<VendorPrefix>),
     /// A @page rule prelude.
     Page,
+    /// A @document rule, with its conditional.
+    Document(DocumentCondition),
 }
 
 
 impl<'a> AtRuleParser for TopLevelRuleParser<'a> {
     type Prelude = AtRulePrelude;
     type AtRule = CssRule;
 
     fn parse_prelude(&mut self, name: &str, input: &mut Parser)
@@ -1132,16 +1179,24 @@ impl<'a, 'b> AtRuleParser for NestedRule
             },
             "page" => {
                 if cfg!(feature = "gecko") {
                     Ok(AtRuleType::WithBlock(AtRulePrelude::Page))
                 } else {
                     Err(())
                 }
             },
+            "-moz-document" => {
+                if cfg!(feature = "gecko") {
+                    let cond = DocumentCondition::parse(self.context, input)?;
+                    Ok(AtRuleType::WithBlock(AtRulePrelude::Document(cond)))
+                } else {
+                    unimplemented!()
+                }
+            },
             _ => Err(())
         }
     }
 
     fn parse_block(&mut self, prelude: AtRulePrelude, input: &mut Parser) -> Result<CssRule, ()> {
         match prelude {
             AtRulePrelude::FontFace => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::FontFace));
@@ -1177,16 +1232,26 @@ impl<'a, 'b> AtRuleParser for NestedRule
             }
             AtRulePrelude::Page => {
                 let context = ParserContext::new_with_rule_type(self.context, Some(CssRuleType::Page));
                 let declarations = parse_property_declaration_list(&context, input);
                 Ok(CssRule::Page(Arc::new(self.shared_lock.wrap(PageRule(
                     Arc::new(self.shared_lock.wrap(declarations))
                 )))))
             }
+            AtRulePrelude::Document(cond) => {
+                if cfg!(feature = "gecko") {
+                    Ok(CssRule::Document(Arc::new(self.shared_lock.wrap(DocumentRule {
+                        condition: cond,
+                        rules: self.parse_nested_rules(input, CssRuleType::Document),
+                    }))))
+                } else {
+                    unimplemented!()
+                }
+            }
         }
     }
 }
 
 impl<'a, 'b> QualifiedRuleParser for NestedRuleParser<'a, 'b> {
     type Prelude = SelectorList<SelectorImpl>;
     type QualifiedRule = CssRule;
 
diff --git a/servo/components/style/stylist.rs b/servo/components/style/stylist.rs
--- a/servo/components/style/stylist.rs
+++ b/servo/components/style/stylist.rs
@@ -572,17 +572,18 @@ impl Stylist {
 
         if let Some(ref constraints) = self.viewport_constraints {
             device.account_for_viewport_rule(constraints);
         }
 
         fn mq_eval_changed(guard: &SharedRwLockReadGuard, rules: &[CssRule],
                            before: &Device, after: &Device) -> bool {
             for rule in rules {
-                let changed = rule.with_nested_rules_and_mq(guard, |rules, mq| {
+                let changed = rule.with_nested_rules_mq_and_doc_rule(guard,
+                                                                     |rules, mq, _| {
                     if let Some(mq) = mq {
                         if mq.evaluate(before) != mq.evaluate(after) {
                             return true
                         }
                     }
                     mq_eval_changed(guard, rules, before, after)
                 });
                 if changed {
diff --git a/servo/ports/geckolib/Cargo.toml b/servo/ports/geckolib/Cargo.toml
--- a/servo/ports/geckolib/Cargo.toml
+++ b/servo/ports/geckolib/Cargo.toml
@@ -15,15 +15,16 @@ testing = ["style/testing"]
 gecko_debug = ["style/gecko_debug"]
 
 [dependencies]
 atomic_refcell = "0.1"
 cssparser = "0.13"
 env_logger = {version = "0.4", default-features = false} # disable `regex` to reduce code size
 libc = "0.2"
 log = {version = "0.3.5", features = ["release_max_level_info"]}
+nsstring_vendor = {path = "../../components/style/gecko_bindings/nsstring_vendor"}
 parking_lot = "0.3"
 selectors = {path = "../../components/selectors"}
 style = {path = "../../components/style", features = ["gecko"]}
 style_traits = {path = "../../components/style_traits"}
 
 [dev-dependencies]
 stylo_tests = {path = "../../tests/unit/stylo"}
diff --git a/toolkit/library/gtest/rust/Cargo.lock b/toolkit/library/gtest/rust/Cargo.lock
--- a/toolkit/library/gtest/rust/Cargo.lock
+++ b/toolkit/library/gtest/rust/Cargo.lock
@@ -301,16 +301,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
 ]
 
 [[package]]
 name = "gkrust-shared"
diff --git a/toolkit/library/rust/Cargo.lock b/toolkit/library/rust/Cargo.lock
--- a/toolkit/library/rust/Cargo.lock
+++ b/toolkit/library/rust/Cargo.lock
@@ -299,16 +299,17 @@ dependencies = [
 name = "geckoservo"
 version = "0.0.1"
 dependencies = [
  "atomic_refcell 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
  "cssparser 0.13.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "env_logger 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)",
  "libc 0.2.20 (registry+https://github.com/rust-lang/crates.io-index)",
  "log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "nsstring_vendor 0.1.0",
  "parking_lot 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "selectors 0.18.0",
  "style 0.0.1",
  "style_traits 0.0.1",
 ]
 
 [[package]]
 name = "gkrust-shared"
