# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  53ec980e00e03d6609707c8413b71deca4125745
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: StorageManager and StorageContext. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -334,17 +334,18 @@ BackgroundSync::ActorCreated(PBackground
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
   if (mShuttingDown) {
     return;
   }
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -12,17 +12,17 @@
 #include "mozilla/dom/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
 {
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -10,33 +10,65 @@
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class BackgroundSyncParent::PendingRequest final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(PendingRequest)
+
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID RequestId()
+  {
+    return mRequestId;
+  }
+
+  SyncOp Op()
+  {
+    return mOp;
+  }
+private:
+  ~PendingRequest() {}
+
+  nsID mRequestId;
+  SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  mStorageManagerIdFactory =
+    StorageManagerIdFactory::Create(this, aPrincipalInfo);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       // XXX Do registration.
       const SyncRegisterResponse response(true);
@@ -52,22 +84,60 @@ bool BackgroundSyncParent::RecvRequest(c
       Unused << SendResponse(aRequestId, response);
       break;
     }
     default:
     {
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a StorageManagerId for this parent yet, we
+  // queue the request.
+  if (!mStorageManagerId) {
+    RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
+    mPendingRequests.AppendElement(pendingRequest);
+    return true;
+  }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
+void
+BackgroundSyncParent::OnStorageManagerIdCreated(
+    StorageManagerId* aManagerId)
+{
+  MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(!mStorageManagerId);
+
+  mStorageManagerId = aManagerId;
+  mStorageManagerIdFactory->RemoveListener(this);
+  mStorageManagerIdFactory = nullptr;
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+    MOZ_ASSERT(mPendingRequests[i]);
+    ExecuteRequest(mPendingRequests[i]->RequestId(),
+                   mPendingRequests[i]->Op());
+  }
+  mPendingRequests.Clear();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,43 +2,62 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
+#include "StorageManagerId.h"
+
 #include "mozilla/dom/PBackgroundSyncParent.h"
 #include "mozilla/dom/BackgroundSyncIPCTypes.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundParentImpl;
+  class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
+                                 , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 private:
-  BackgroundSyncParent();
+  BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // StorageManagerId method
+  virtual void
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+
+  RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
+  // We use this Id to ensure that we have a single StorageManager
+  // per principal.
+  RefPtr<StorageManagerId> mStorageManagerId;
+
+  class PendingRequest;
+  nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
-
-
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -0,0 +1,309 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManager.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/StaticMutex.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+// ---------------------------------------------------------------------------
+
+// Singleton class to track Manager instances and ensure there is only
+// one for each unique StorageManagerId.
+class StorageManager::Factory
+{
+public:
+  friend class StaticAutoPtr<StorageManager::Factory>;
+
+  static nsresult
+  GetOrCreate(StorageManagerId* aManagerId,
+              StorageManager** aManagerOut)
+  {
+    AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance. This forces the Get() call
+    // below to use the same factory.
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    RefPtr<StorageManager> ref = Get(aManagerId);
+    if (!ref) {
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("BSyncIOThread",
+                             getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      ref = new StorageManager(aManagerId, ioThread);
+
+      // There may be an old manager for this origin in the process of
+      // cleaning up.  We need to tell the new manager about this so
+      // that it won't actually start until the old manager is done.
+      RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
+      ref->Init(oldManager);
+
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<StorageManager>
+  Get(StorageManagerId* aManagerId, State aState = Open)
+  {
+    AssertIsOnBackgroundThread();
+
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    // Iterate in reverse to find the most recent, matching Manager. This
+    // is important when looking for a Closing Manager.  If a new Manager
+    // chains to an old Manager we want it to be the most recent one.
+    ManagerList::BackwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      RefPtr<StorageManager> manager = iter.GetNext();
+      if (aState == manager->GetState() && *manager->mManagerId == *aManagerId) {
+        return manager.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void
+  Remove(StorageManager* aManager)
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(sFactory);
+
+    MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
+
+    // Clean up the factory singleton if there are no more managers.
+    MaybeDestroyInstance();
+  }
+
+  static void
+  Abort(const nsACString& aOrigin)
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        if (aOrigin.IsVoid() ||
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
+          manager->Abort();
+        }
+      }
+    }
+  }
+
+  static void
+  ShutdownAll()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      // Note that we are synchronously calling shutdown code here. If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
+    }
+
+    MaybeDestroyInstance();
+  }
+
+  static bool
+  IsShutdownAllComplete()
+  {
+    AssertIsOnBackgroundThread();
+    return !sFactory;
+  }
+
+private:
+  Factory()
+    : mInSyncShutdown(false)
+  {
+    MOZ_COUNT_CTOR(StorageManager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(StorageManager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
+  }
+
+  static nsresult
+  MaybeCreateInstance()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // Be clear about what we are locking. sFactory is bg thread only, so
+      // we don't need to lock it here. Just protect sFactoryShutdown and
+      // sBackgroundThread.
+      {
+        StaticMutexAutoLock lock(sMutex);
+
+        if (sFactoryShutdown) {
+          return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+        }
+      }
+
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread. Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+
+    return NS_OK;
+  }
+
+  static void
+  MaybeDestroyInstance()
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(sFactory);
+
+    // If the factory is still in use then we cannot delete yet. This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down. We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
+    sFactory = nullptr;
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove(). PBackground thread only.
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Protects following static attribute.
+  static StaticMutex sMutex;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sMutex to access.
+  static bool sFactoryShutdown;
+
+  // Weak references as we don't want to keep StorageManager objects alive
+  // forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
+  typedef nsTObserverArray<StorageManager*> ManagerList;
+  ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
+};
+
+// static
+StaticAutoPtr<StorageManager::Factory> StorageManager::Factory::sFactory;
+
+// static
+StaticMutex StorageManager::Factory::sMutex;
+
+// static
+bool StorageManager::Factory::sFactoryShutdown = false;
+
+// ---------------------------------------------------------------------------
+
+// static
+nsresult
+StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+                            StorageManager** aManagerOut)
+{
+  AssertIsOnBackgroundThread();
+  return NS_OK;
+}
+
+StorageManager::StorageManager(StorageManagerId* aManagerId,
+                               nsIThread* aIOThread)
+  : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
+  , mState(Open)
+{
+  MOZ_ASSERT(mManagerId);
+  MOZ_ASSERT(mIOThread);
+}
+
+StorageManager::~StorageManager()
+{
+  MOZ_ASSERT(mState == Closing);
+/* XXX
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+
+  // Don't spin the event loop in the destructor waiting for the thread to
+  // shutdown. Defer this to the main thread, instead.
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
+}
+
+void
+StorageManager::Init(StorageManager* aOldManager)
+{
+  // XXX
+}
+
+void
+StorageManager::Abort()
+{
+  // XXX
+}
+
+void
+StorageManager::Shutdown()
+{
+  // XXX
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManager_h
+#define mozilla_dom_StorageManager_h
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * The StorageManager class is responsible for managing the storage of sync
+ * requests. The DOM objects and IPC actors are basically just plumbing to
+ * get the request to the right StorageManager object running in the parent
+ * process.
+ *
+ * There should be exactly one StorageManager object for each origin or app
+ * using the BackgroundSync API. This uniqueness is defined by the
+ * StorageManagerId equality operator. The uniqueness is enforced by the
+ * Manager GetOrCreate() factory method.
+ */
+
+class StorageManager final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageManager)
+
+  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+                              StorageManager** aManagerOut);
+
+  enum State
+  {
+    Open,
+    Closing
+  };
+
+  State GetState() const
+  {
+    return mState;
+  }
+
+private:
+  class Factory;
+
+  StorageManager(StorageManagerId* aManagerId, nsIThread* aIOThread);
+  ~StorageManager();
+
+  void Init(StorageManager* aOldManager);
+  void Abort();
+  void Shutdown();
+
+  RefPtr<StorageManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+  State mState;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManager_h
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -0,0 +1,173 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManagerId.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * StorageManagerIdFactory
+ */
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManagerIdFactory> factory =
+    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(factory));
+
+  return factory.forget();
+}
+
+StorageManagerIdFactory::StorageManagerIdFactory(
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+  : mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(aListener);
+
+  mListenerList.AppendElement(aListener);
+}
+
+StorageManagerIdFactory::~StorageManagerIdFactory()
+{
+  // Since this is a Runnable that executes on multiple threads, its a race
+  // to see which thread de-refs us last. Therefore we cannot guarantee which
+  // thread we destruct on.
+
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+NS_IMETHODIMP
+StorageManagerIdFactory::Run()
+{
+  // Execute twice. First on the main thread and the back on the originating
+  // thread.
+
+  if (mManagerId) {
+    AssertIsOnBackgroundThread();
+
+    ListenerList::ForwardIterator iter(mListenerList);
+    while (iter.HasMore()) {
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+    }
+
+    // The listener must clear its reference in
+    // OnStorageManagerIdCreated().
+    MOZ_ASSERT(mListenerList.IsEmpty());
+
+    return NS_OK;
+  }
+
+  AssertIsOnMainThread();
+
+  nsresult rv;
+  RefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                            &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  rv = StorageManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(this, NS_DISPATCH_NORMAL));
+
+  return NS_OK;
+}
+
+void
+StorageManagerIdFactory::AddListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+}
+
+void
+StorageManagerIdFactory::RemoveListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+
+  MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
+}
+
+/**
+ * StorageManagerId
+ */
+
+// static
+nsresult
+StorageManagerId::Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<StorageManagerId> ref =
+    new StorageManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+StorageManagerId::StorageManagerId(nsIPrincipal* aPrincipal,
+                                   const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+StorageManagerId::~StorageManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManagerId_h
+#define mozilla_dom_StorageManagerId_h
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::PrincipalInfo;
+
+class StorageManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const StorageManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  StorageManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~StorageManagerId();
+
+  StorageManagerId(const StorageManagerId&) = delete;
+  StorageManagerId& operator=(const StorageManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerId)
+};
+
+class StorageManagerIdFactory : public Runnable
+{
+public:
+  // An interface to be implemented by code wishing to use the
+  // StorageManagerIdFactory.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the StorageManagerIdFactory to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+  };
+
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
+
+  void AddListener(Listener* aListener);
+  // The Listener must call RemoveListener() when
+  // OnStorageManagerIdCreated is called or when
+  // the Listener is destroyed.
+  void RemoveListener(Listener* aListener);
+
+private:
+  StorageManagerIdFactory(Listener* aListener,
+                          const PrincipalInfo& aPrincipalInfo);
+  virtual ~StorageManagerIdFactory();
+
+  // Weak reference cleared by RemoveListener().
+  typedef nsTObserverArray<Listener*> ListenerList;
+  ListenerList mListenerList;
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<StorageManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManagerId_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -5,17 +5,19 @@
 
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
-    'BackgroundSyncParent.cpp'
+    'BackgroundSyncParent.cpp',
+    'StorageManager.cpp',
+    'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -470,17 +470,18 @@ BackgroundChildImpl::DeallocPFileSystemR
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
 dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+BackgroundChildImpl::AllocPBackgroundSyncChild(
+    const PrincipalInfo& aPrincipalInfo)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -161,17 +161,17 @@ protected:
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -889,32 +889,38 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
 mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  RefPtr<BackgroundSyncParent> agent =
+    new BackgroundSyncParent(aPrincipalInfo);
+  return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundSyncParent*>(aActor);
+  RefPtr<BackgroundSyncParent> parent =
+    dont_AddRef(static_cast<BackgroundSyncParent*>(aActor));
+  MOZ_ASSERT(parent);
+
   return true;
 }
 
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -193,17 +193,17 @@ protected:
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -97,17 +97,17 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
