# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  d3e6e958b9575c6e60025ae8cf7fcf176b2e4a83
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: Storage. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -4,17 +4,16 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "BackgroundSync.h"
 #include "BackgroundSyncChild.h"
 
 #include "mozilla/dom/Promise.h"
 #include "mozilla/dom/PromiseWorkerProxy.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BackgroundSyncBinding.h"
 #include "mozilla/ipc/BackgroundChild.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/ipc/PBackgroundChild.h"
 #include "mozilla/unused.h"
 #include "mozilla/Preferences.h"
 #include "nsISupportsPrimitives.h"
 #include "nsIGlobalObject.h"
@@ -336,17 +335,18 @@ BackgroundSync::ActorCreated(PBackground
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
   if (mShuttingDown) {
     return;
   }
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
@@ -422,17 +422,30 @@ BackgroundSync::ExecuteOp(const SyncOpAr
 
 // WebIDL interface methods.
 
 already_AddRefed<Promise>
 BackgroundSync::Register(const nsAString& aTag, ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
-  const SyncRegisterArgs args(mScope, (nsString(aTag)));
+  nsresult rv;
+  nsCOMPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(*mPrincipalInfo, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    // XXX create and reject promise
+  }
+  nsAutoCString origin;
+  rv = principal->GetOrigin(origin);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    // XXX create and reject promise
+  }
+
+  const SyncRegisterArgs args(NS_ConvertUTF8toUTF16(origin),
+                              mScope, (nsString(aTag)));
   return ExecuteOp(SyncOpArgs(args), aRv);
 }
 
 already_AddRefed<Promise>
 BackgroundSync::GetTags(ErrorResult& aRv)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
 
diff --git a/dom/backgroundsync/BackgroundSync.h b/dom/backgroundsync/BackgroundSync.h
--- a/dom/backgroundsync/BackgroundSync.h
+++ b/dom/backgroundsync/BackgroundSync.h
@@ -5,17 +5,17 @@
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSync_h
 #define mozilla_dom_BackgroundSync_h
 
 #include "jsapi.h"
 #include "mozilla/AlreadyAddRefed.h"
 #include "mozilla/ErrorResult.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
 #include "mozilla/dom/BindingDeclarations.h"
 #include "nsCOMPtr.h"
 #include "nsIIPCBackgroundChildCreateCallback.h"
 #include "nsIObserver.h"
 #include "nsWrapperCache.h"
 
 class nsIGlobalObject;
 class nsIPrincipal;
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -4,25 +4,25 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncChild_h
 #define mozilla_dom_BackgroundSyncChild_h
 
 #include "BackgroundSync.h"
 
-#include "mozilla/dom/PBackgroundSyncChild.h"
+#include "mozilla/dom/backgroundsync/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
diff --git a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
--- a/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
+++ b/dom/backgroundsync/BackgroundSyncIPCTypes.ipdlh
@@ -1,55 +1,106 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 include PBackgroundSharedTypes;
 
+using RegistrationState from "ipc/IPCMessageUtils.h";
+using mozilla::void_t from "ipc/IPCMessageUtils.h";
+
 namespace mozilla {
 namespace dom {
+namespace backgroundsync {
 
 struct SyncRegisterArgs
 {
+  nsString mOrigin;
   nsString mScope;
   nsString mTag;
 };
 
 struct SyncGetTagsArgs
 {
+  nsString mScope;
 };
 
 union SyncOpArgs
 {
   SyncRegisterArgs;
   SyncGetTagsArgs;
 };
 
 struct SyncOp
 {
   PrincipalInfo mPrincipal;
   SyncOpArgs mArgs;
 };
 
 struct SyncRegisterResponse
 {
-  bool mSuccess;
+  nsString mOrigin;
 };
 
 struct SyncGetTagsResponse
 {
   nsString[] mTags;
 };
 
+struct Registration
+{
+  nsString mId;
+  nsString mOrigin;
+  nsString mScope;
+  nsString mTag;
+  RegistrationState mState;
+  bool mLastChance;
+};
+
+struct SyncGetAllResponse
+{
+  Registration[] mRegistrations;
+};
+
 struct SyncOpError
 {
   uint32_t mCode;
 };
 
 union SyncOpResponse
 {
+  void_t;
   SyncRegisterResponse;
   SyncGetTagsResponse;
+  SyncGetAllResponse;
   SyncOpError;
 };
 
+struct SyncGetAllArgs
+{};
+
+struct SyncChangeStateArgs
+{
+  nsString mId;
+  uint16_t mState;
+};
+
+struct SyncRemoveArgs
+{
+  nsString mId;
+  nsString mOrigin;
+};
+
+union SyncInternalOpArgs
+{
+  SyncGetAllArgs;
+  SyncChangeStateArgs;
+  SyncRemoveArgs;
+};
+
+struct SyncInternalOp
+{
+  SyncInternalOpArgs mArgs;
+};
+
+} // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -11,71 +11,120 @@
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 namespace backgroundsync {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class BackgroundSyncParent::PendingRequest final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(PendingRequest)
+
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID RequestId()
+  {
+    return mRequestId;
+  }
+
+  SyncOp Op()
+  {
+    return mOp;
+  }
+private:
+  ~PendingRequest() {}
+
+  nsID mRequestId;
+  SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  mStorageManagerIdFactory =
+    StorageManagerIdFactory::Create(this, aPrincipalInfo);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
-  switch(aOp.mArgs().type()) {
-    case SyncOpArgs::TSyncRegisterArgs:
-    {
-      // XXX Do registration.
-      const SyncRegisterResponse response(true);
-      //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    case SyncOpArgs::TSyncGetTagsArgs:
-    {
-      //XXX Do GetTags.
-      nsTArray<nsString> tags;
-      const SyncGetTagsResponse response(tags);
-      Unused << SendResponse(aRequestId, response);
-      break;
-    }
-    default:
-    {
-      MOZ_CRASH("Unknown BackgroundSync request");
-    }
+  // XXX
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a StorageManagerId for this parent yet, we
+  // queue the request.
+  if (!mStorageManagerId) {
+    RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
+    mPendingRequests.AppendElement(pendingRequest);
+    return true;
   }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
 void
+BackgroundSyncParent::OnStorageManagerIdCreated(
+    StorageManagerId* aManagerId)
+{
+  MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(!mStorageManagerId);
+
+  mStorageManagerId = aManagerId;
+  mStorageManagerIdFactory->RemoveListener(this);
+  mStorageManagerIdFactory = nullptr;
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+    MOZ_ASSERT(mPendingRequests[i]);
+    ExecuteRequest(mPendingRequests[i]->RequestId(),
+                   mPendingRequests[i]->Op());
+  }
+  mPendingRequests.Clear();
+}
+
+void
 BackgroundSyncParent::NotifyResponse(const nsID& aRequestId,
                                      const SyncOpResponse& aResponse)
 {
   AssertIsOnBackgroundThread();
 
   Unused << SendResponse(aRequestId, aResponse);
 }
 
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,49 +2,68 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
-#include "mozilla/dom/PBackgroundSyncParent.h"
-#include "mozilla/dom/BackgroundSyncIPCTypes.h"
+#include "mozilla/dom/backgroundsync/PBackgroundSyncParent.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncIPCTypes.h"
+
+#include "StorageManagerId.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundParentImpl;
+  class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 namespace backgroundsync {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
+                                 , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 
   void NotifyResponse(const nsID& aRequestId,
                       const SyncOpResponse& aResponse);
 
 private:
-  BackgroundSyncParent();
+  BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // StorageManagerId method
+  virtual void
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+
+  RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
+  // We use this Id to ensure that we have a single StorageManager
+  // per principal.
+  RefPtr<StorageManagerId> mStorageManagerId;
+
+  class PendingRequest;
+  nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
 
 } // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
-
-
diff --git a/dom/backgroundsync/BackgroundSyncTypes.h b/dom/backgroundsync/BackgroundSyncTypes.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncTypes.h
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncTypes_h
+#define mozilla_dom_BackgroundSyncTypes_h
+
+#include <stdint.h>
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+};
+
+enum RegistrationState
+{
+  PENDING = 1,
+  WAITING,
+  FIRING,
+  REREGISTERING_WHILE_FIRING
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncTypes_h
diff --git a/dom/backgroundsync/ChromeDBSchema.cpp b/dom/backgroundsync/ChromeDBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeDBSchema.cpp
@@ -0,0 +1,132 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ChromeDBSchema.h"
+#include "DBSchemaUtils.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace chromedb {
+
+const int32_t kFirstShippedSchemaVersion = 1;
+
+namespace {
+
+// Update this whenever the DB schema is changed.
+const int32_t kLatestSchemaVersion = 1;
+
+// ---------
+const char* const kTableRegistrations =
+  "CREATE TABLE origins ("
+    "origin TEXT NOT NULL PRIMARY KEY"
+  ")";
+// ---------
+// End schema definition
+// ---------
+
+} // namespace
+
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn)
+{
+  return dbutils::CreateOrMigrateSchema(aConn, kLatestSchemaVersion,
+                                        kTableRegistrations,
+                                        "origins");
+}
+
+nsresult
+InitializeConnection(mozIStorageConnection* aConn)
+{
+  return dbutils::InitializeConnection(aConn);
+}
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const nsAString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO origins ("
+      "origin "
+    ") VALUES ("
+      ":origin "
+    ");"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsString origin;
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"), aOrigin);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+Unregister(mozIStorageConnection* aConn,
+           const nsAString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM origins WHERE origin=:origin;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<nsString>& aOrigins)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT * FROM origins;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString origin;
+    rv = state->GetString(0, origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    aOrigins.AppendElement(origin);
+  }
+
+  return rv;
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return dbutils::IncrementalVacuum(aConn);
+}
+
+} // namespace chromedb
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/ChromeDBSchema.h b/dom/backgroundsync/ChromeDBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeDBSchema.h
@@ -0,0 +1,51 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ChromeDBSchema_h
+#define mozilla_dom_ChromeDBSchema_h
+
+class mozIStorageConnection;
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace chromedb {
+
+// Note, this cannot be executed within a transaction.
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn);
+
+// Note, this cannot be executed within a transaction.
+nsresult
+InitializeConnection(mozIStorageConnection* aConn);
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const nsAString& aOrigin);
+
+nsresult
+Unregister(mozIStorageConnection* aConn,
+           const nsAString& aOrigin);
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<nsString>& aOrigins);
+
+// Note, this works best when its NOT executed within a transaction.
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn);
+
+// We will wipe out databases with schema versions less than this. Newer
+// versions will be migrated on open to the latest schema version.
+extern const int32_t kFirstShippedSchemaVersion;
+
+} // namespace chromedb
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ChromeDBSchema_h
diff --git a/dom/backgroundsync/ChromeStorageManager.cpp b/dom/backgroundsync/ChromeStorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeStorageManager.cpp
@@ -0,0 +1,288 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "ChromeDBSchema.h"
+#include "ChromeStorageManager.h"
+
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+namespace {
+  ChromeStorageManager* csmInstance = nullptr;
+} // namespace
+
+//-----------------------------------------------------------------------------
+
+class ChromeStorageAction
+{
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageAction)
+
+  enum Type {
+    Register = 0,
+    Unregister,
+    GetAll
+  };
+
+  ChromeStorageAction(Type aType)
+    : mType(aType)
+  {}
+
+  ChromeStorageAction(Type aType, const nsAString& aOrigin)
+    : mType(aType)
+    , mOrigin(aOrigin)
+  {}
+
+  Type Type()
+  {
+    return mType;
+  }
+
+  nsString& Origin()
+  {
+    return mOrigin;
+  }
+
+private:
+  ~ChromeStorageAction() {}
+
+  enum Type mType;
+  nsString mOrigin;
+};
+
+//-----------------------------------------------------------------------------
+// IO thread
+
+class InitRunnable final : public nsIRunnable,
+                           public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  InitRunnable(ChromeStorageManager* aManager)
+    : mManager(aManager)
+    , mInitiatingThread(do_GetCurrentThread())
+  {
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    if (mInitiatingThread == nsCOMPtr<nsIThread>(do_GetCurrentThread())) {
+      MOZ_ASSERT(mDBConn);
+      mManager->OnInitialized(mDBConn);
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIFile> dbFile;
+    nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
+                                         getter_AddRefs(dbFile));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dbFile->AppendNative(NS_LITERAL_CSTRING("backgroundsync.sqlite"));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<mozIStorageService> storage =
+      do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+    if (NS_WARN_IF(!storage)) { return rv; }
+
+    rv = storage->OpenDatabase(dbFile, getter_AddRefs(mDBConn));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    MOZ_ASSERT(mDBConn);
+
+    chromedb::CreateOrMigrateSchema(mDBConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+
+    return rv;
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~InitRunnable() {};
+
+  nsCOMPtr<mozIStorageConnection> mDBConn;
+  RefPtr<ChromeStorageManager> mManager;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+};
+
+NS_IMPL_ISUPPORTS(InitRunnable, nsICancelableRunnable, nsIRunnable)
+
+class StorageActionRunnable : public nsIRunnable,
+                              public nsICancelableRunnable
+{
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  StorageActionRunnable(mozIStorageConnection* aConn,
+                        ChromeStorageAction* aAction)
+    : mConn(aConn)
+    , mAction(aAction)
+  {
+    MOZ_ASSERT(aConn);
+    MOZ_ASSERT(aAction);
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    switch (mAction->Type()) {
+      case ChromeStorageAction::Type::Register:
+        chromedb::Register(mConn, mAction->Origin());
+      break;
+      case ChromeStorageAction::Type::Unregister:
+        chromedb::Unregister(mConn, mAction->Origin());
+      break;
+      case ChromeStorageAction::Type::GetAll:
+        // XXX
+      break;
+      default:
+        MOZ_CRASH("BackgroundSync: Unexpected ChromeStorageAction");
+    }
+
+    return NS_OK;
+  }
+
+  NS_IMETHODIMP
+  Cancel() override
+  {
+    return NS_OK;
+  }
+
+private:
+  ~StorageActionRunnable() {}
+
+  nsCOMPtr<mozIStorageConnection> mConn;
+  RefPtr<ChromeStorageAction> mAction;
+};
+
+NS_IMPL_ISUPPORTS(StorageActionRunnable, nsICancelableRunnable, nsIRunnable)
+
+//-----------------------------------------------------------------------------
+// PBackground thread
+
+ChromeStorageManager::ChromeStorageManager()
+{
+  AssertIsOnBackgroundThread();
+
+  Init();
+}
+
+ChromeStorageManager::~ChromeStorageManager()
+{
+  AssertIsOnBackgroundThread();
+
+  MOZ_ALWAYS_SUCCEEDS(mDBConn->Close());
+  mDBConn = nullptr;
+
+  mPendingActions.Clear();
+
+  /*
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
+}
+
+// static
+already_AddRefed<ChromeStorageManager>
+ChromeStorageManager::GetOrCreate()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<ChromeStorageManager> instance = csmInstance;
+  if (!instance) {
+    instance = new ChromeStorageManager();
+  }
+  return instance.forget();
+}
+
+void
+ChromeStorageManager::Init()
+{
+  AssertIsOnBackgroundThread();
+
+  nsresult rv = NS_NewNamedThread("BSyncChIOThread", getter_AddRefs(mIOThread));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return; }
+
+  RefPtr<InitRunnable> runnable = new InitRunnable(this);
+  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+}
+
+void
+ChromeStorageManager::OnInitialized(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(aConn);
+
+  mDBConn = aConn;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    switch (mPendingActions[i]->Type()) {
+      case ChromeStorageAction::Type::Register:
+        Register(mPendingActions[i]->Origin());
+        break;
+      case ChromeStorageAction::Type::Unregister:
+        Unregister(mPendingActions[i]->Origin());
+        break;
+      case ChromeStorageAction::Type::GetAll:
+        break;
+    }
+  }
+  mPendingActions.Clear();
+}
+
+void
+ChromeStorageManager::ExecuteStorageAction(ChromeStorageAction* aAction)
+{
+  if (!mDBConn) {
+    mPendingActions.AppendElement(aAction);
+    return;
+  }
+
+  RefPtr<StorageActionRunnable> runnable = new StorageActionRunnable(mDBConn,
+                                                                     aAction);
+  mIOThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL);
+}
+
+void
+ChromeStorageManager::Register(const nsAString& aOrigin)
+{
+  RefPtr<ChromeStorageAction> action =
+    new ChromeStorageAction(ChromeStorageAction::Type::Register, aOrigin);
+  ExecuteStorageAction(action);
+}
+
+void
+ChromeStorageManager::Unregister(const nsAString& aOrigin)
+{
+  RefPtr<ChromeStorageAction> action =
+    new ChromeStorageAction(ChromeStorageAction::Type::Unregister, aOrigin);
+  ExecuteStorageAction(action);
+}
+
+void
+ChromeStorageManager::GetAll(nsTArray<nsString>& aOrigins)
+{
+  // XXX
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/ChromeStorageManager.h b/dom/backgroundsync/ChromeStorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/ChromeStorageManager.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_ChromeStorageManager_h
+#define mozilla_dom_ChromeStorageManager_h
+
+/**
+ * This singleton object is kept alive by the BackgroundSyncService. While a
+ * content related storage request is on going, this object should be kept
+ * alive. If no pending storage requests are in place, this object can be
+ * released.
+ **
+ * It manages the chrome database that stores the origins that have pending
+ * sync registrations.
+ */
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/storage.h"
+#include "nsISupportsImpl.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class ChromeStorageAction;
+
+class ChromeStorageManager final
+{
+  friend class InitRunnable;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ChromeStorageManager)
+
+  static already_AddRefed<ChromeStorageManager> GetOrCreate();
+
+  void Register(const nsAString& aOrigin);
+  void Unregister(const nsAString& aOrigin);
+  void GetAll(nsTArray<nsString>& aOrigins);
+
+private:
+  ChromeStorageManager();
+  ~ChromeStorageManager();
+
+  void Init();
+  void OnInitialized(mozIStorageConnection* aConn);
+
+  void ExecuteStorageAction(ChromeStorageAction* aAction);
+
+  nsCOMPtr<nsIThread> mIOThread;
+  nsCOMPtr<mozIStorageConnection> mDBConn;
+
+  nsTArray<RefPtr<ChromeStorageAction>> mPendingActions;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_ChromeStorageManager_h
diff --git a/dom/backgroundsync/DBAction.cpp b/dom/backgroundsync/DBAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBAction.cpp
@@ -0,0 +1,227 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBAction.h"
+#include "DBConnection.h"
+#include "DBSchema.h"
+
+#include "mozilla/dom/quota/PersistenceType.h"
+#include "mozilla/net/nsFileProtocolHandler.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageService.h"
+#include "mozStorageCID.h"
+#include "nsIFile.h"
+#include "nsIURI.h"
+#include "nsIFileURL.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+DBAction::DBAction(Mode aMode)
+  : mMode(aMode)
+{
+}
+
+DBAction::~DBAction()
+{
+}
+
+void
+DBAction::RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                      Data* aOptionalData)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aQuotaInfo.mDir);
+
+  if (IsCanceled()) {
+    aResolver->Resolve(NS_ERROR_ABORT);
+    return;
+  }
+
+  nsCOMPtr<nsIFile> dbDir;
+  nsresult rv = aQuotaInfo.mDir->Clone(getter_AddRefs(dbDir));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  rv = dbDir->Append(NS_LITERAL_STRING("backgroundsync"));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    aResolver->Resolve(rv);
+    return;
+  }
+
+  nsCOMPtr<mozIStorageConnection> conn;
+
+  // Attempt to reuse the connection opened by a previous Action.
+  if (aOptionalData) {
+    conn = aOptionalData->GetConnection();
+  }
+
+  // If there is no previous StorageAction, then we must open one.
+  if (!conn) {
+    rv = OpenConnection(aQuotaInfo, dbDir, getter_AddRefs(conn));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      aResolver->Resolve(rv);
+      return;
+    }
+    MOZ_ASSERT(conn);
+
+    // Save this connection in the shared Data object so later StorageActions
+    // can use it.  This avoids opening a new connection for every
+    // StorageAction.
+    if (aOptionalData) {
+      // Since we know this connection will be around for as long as the
+      // storage is open, use our special wrapped connection class.  This
+      // will let us perform certain operations once the storage origin
+      // is closed.
+      nsCOMPtr<mozIStorageConnection> wrapped = new DBConnection(conn);
+      aOptionalData->SetConnection(wrapped);
+    }
+  }
+
+  RunWithDBOnTarget(aResolver, aQuotaInfo, dbDir, conn);
+}
+
+nsresult
+DBAction::OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                         mozIStorageConnection** aConnOut)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConnOut);
+
+  nsCOMPtr<mozIStorageConnection> conn;
+
+  bool exists;
+  nsresult rv = aDBDir->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (!exists) {
+    if (NS_WARN_IF(mMode != Create)) {  return NS_ERROR_FILE_NOT_FOUND; }
+    rv = aDBDir->Create(nsIFile::DIRECTORY_TYPE, 0755);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = aDBDir->Clone(getter_AddRefs(dbFile));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Append(NS_LITERAL_STRING("backgroundsync.sqlite"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = dbFile->Exists(&exists);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Use our default file:// protocol handler directly to construct the database
+  // URL. This avoids any problems if a plugin registers a custom file://
+  // handler. If such a custom handler used javascript, then we would have a
+  // bad time running off the main thread here.
+  RefPtr<nsFileProtocolHandler> handler = new nsFileProtocolHandler();
+  rv = handler->Init();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIURI> uri;
+  rv = handler->NewFileURI(dbFile, getter_AddRefs(uri));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<nsIFileURL> dbFileUrl = do_QueryInterface(uri);
+  if (NS_WARN_IF(!dbFileUrl)) { return NS_ERROR_UNEXPECTED; }
+
+  nsAutoCString type;
+  PersistenceTypeToText(PERSISTENCE_TYPE_DEFAULT, type);
+
+  rv = dbFileUrl->SetQuery(
+    NS_LITERAL_CSTRING("persistenceType=") + type +
+    NS_LITERAL_CSTRING("&group=") + aQuotaInfo.mGroup +
+    NS_LITERAL_CSTRING("&origin=") + aQuotaInfo.mOrigin +
+    NS_LITERAL_CSTRING("&cache=private"));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageService> ss =
+    do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  if (NS_WARN_IF(!ss)) { return NS_ERROR_UNEXPECTED; }
+
+  rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+  if (rv == NS_ERROR_FILE_CORRUPTED) {
+    NS_WARNING("BackgroundSync database corrupted. Recreating empty database.");
+
+    conn = nullptr;
+
+    // There is nothing else we can do to recover.  Also, this data can
+    // be deleted by QuotaManager at any time anyways.
+    rv = WipeDatabase(dbFile, aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Check the schema to make sure it is not too old.
+  int32_t schemaVersion = 0;
+  rv = conn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  if (schemaVersion > 0 && schemaVersion < db::kFirstShippedSchemaVersion) {
+    conn = nullptr;
+    rv = WipeDatabase(dbFile, aDBDir);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = ss->OpenDatabaseWithFileURL(dbFileUrl, getter_AddRefs(conn));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = db::InitializeConnection(conn);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  conn.forget(aConnOut);
+
+  return rv;
+}
+
+nsresult
+DBAction::WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir)
+{
+  nsresult rv = aDBFile->Remove(false);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Note, the -wal journal file will be automatically deleted by sqlite when
+  // the new database is created.  No need to explicitly delete it here.
+
+  return rv;
+}
+
+SyncDBAction::SyncDBAction(Mode aMode)
+  : DBAction(aMode)
+{
+}
+
+SyncDBAction::~SyncDBAction()
+{
+}
+
+void
+SyncDBAction::RunWithDBOnTarget(Resolver* aResolver,
+                                const QuotaInfo& aQuotaInfo, nsIFile* aDBDir,
+                                mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aResolver);
+  MOZ_ASSERT(aDBDir);
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = RunSyncOnTarget(aQuotaInfo, aConn);
+  aResolver->Resolve(rv);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBAction.h b/dom/backgroundsync/DBAction.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBAction.h
@@ -0,0 +1,80 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DBAction_h
+#define mozilla_dom_DBAction_h
+
+#include "StorageAction.h"
+
+#include "mozilla/RefPtr.h"
+#include "nsString.h"
+
+class mozIStorageConnection;
+class nsIFile;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class DBAction : public StorageAction
+{
+protected:
+  // The mode specifies whether the database should already exist or if its
+  // ok to create a new database.
+  enum Mode
+  {
+    Existing,
+    Create
+  };
+
+  explicit DBAction(Mode aMode);
+
+  // StorageAction objects are deleted through their base pointer
+  virtual ~DBAction();
+
+  // Just as the resolver must be ref'd until resolve, you may also
+  // ref the DB connection. The connection can only be referenced from the
+  // target thread and must be released upon resolve.
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) = 0;
+
+private:
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+              Data* aOptionalData) override;
+
+  nsresult OpenConnection(const QuotaInfo& aQuotaInfo, nsIFile* aQuotaDir,
+                          mozIStorageConnection** aConnOut);
+
+  nsresult WipeDatabase(nsIFile* aDBFile, nsIFile* aDBDir);
+
+  const Mode mMode;
+};
+
+class SyncDBAction : public DBAction
+{
+protected:
+  explicit SyncDBAction(Mode aMode);
+
+  // Action objects are deleted through their base pointer
+  virtual ~SyncDBAction();
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) = 0;
+
+private:
+  virtual void
+  RunWithDBOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                    nsIFile* aDBDir, mozIStorageConnection* aConn) override;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DBAction_h
diff --git a/dom/backgroundsync/DBConnection.cpp b/dom/backgroundsync/DBConnection.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBConnection.cpp
@@ -0,0 +1,287 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBConnection.h"
+#include "DBSchema.h"
+
+#include "mozStorageHelper.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using quota::QuotaObject;
+
+NS_IMPL_ISUPPORTS(DBConnection, mozIStorageAsyncConnection,
+                  mozIStorageConnection);
+
+DBConnection::DBConnection(mozIStorageConnection* aBase)
+  : mBase(aBase)
+  , mClosed(false)
+{
+  MOZ_ASSERT(mBase);
+}
+
+DBConnection::~DBConnection()
+{
+  NS_ASSERT_OWNINGTHREAD(DBConnection);
+  MOZ_ALWAYS_SUCCEEDS(Close());
+}
+
+NS_IMETHODIMP
+DBConnection::Close()
+{
+  NS_ASSERT_OWNINGTHREAD(DBConnection);
+
+  if (mClosed) {
+    return NS_OK;
+  }
+  mClosed = true;
+
+  // If we are closing here, then we must not have a transaction
+  // open anywhere else. This should be guaranteed to succeed.
+  MOZ_ALWAYS_SUCCEEDS(dbutils::IncrementalVacuum(this));
+
+  return mBase->Close();
+}
+
+// The following methods are all boilerplate that either forward to the
+// base connection or block the method. All the async execution methods
+// are blocked because we do not use them and they would require more
+// work to wrap properly.
+
+// mozIStorageAsyncConnection methods
+
+NS_IMETHODIMP
+DBConnection::AsyncClose(mozIStorageCompletionCallback*)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::AsyncClone(bool, mozIStorageCompletionCallback*)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::GetDatabaseFile(nsIFile** aFileOut)
+{
+  return mBase->GetDatabaseFile(aFileOut);
+}
+
+NS_IMETHODIMP
+DBConnection::CreateAsyncStatement(const nsACString&, mozIStorageAsyncStatement**)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::ExecuteAsync(mozIStorageBaseStatement**, uint32_t,
+                           mozIStorageStatementCallback*,
+                           mozIStoragePendingStatement**)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::ExecuteSimpleSQLAsync(const nsACString&,
+                                    mozIStorageStatementCallback*,
+                                    mozIStoragePendingStatement**)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::CreateFunction(const nsACString& aFunctionName,
+                             int32_t aNumArguments,
+                             mozIStorageFunction* aFunction)
+{
+  // async methods are not supported.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+DBConnection::CreateAggregateFunction(const nsACString& aFunctionName,
+                                      int32_t aNumArguments,
+                                      mozIStorageAggregateFunction* aFunction)
+{
+  return mBase->CreateAggregateFunction(aFunctionName, aNumArguments,
+                                        aFunction);
+}
+
+NS_IMETHODIMP
+DBConnection::RemoveFunction(const nsACString& aFunctionName)
+{
+  return mBase->RemoveFunction(aFunctionName);
+}
+
+NS_IMETHODIMP
+DBConnection::SetProgressHandler(int32_t aGranularity,
+                                 mozIStorageProgressHandler* aHandler,
+                                 mozIStorageProgressHandler** aHandlerOut)
+{
+  return mBase->SetProgressHandler(aGranularity, aHandler, aHandlerOut);
+}
+
+NS_IMETHODIMP
+DBConnection::RemoveProgressHandler(mozIStorageProgressHandler** aHandlerOut)
+{
+  return mBase->RemoveProgressHandler(aHandlerOut);
+}
+
+// mozIStorageConnection methods
+
+NS_IMETHODIMP
+DBConnection::Clone(bool aReadOnly, mozIStorageConnection** aConnectionOut)
+{
+  nsCOMPtr<mozIStorageConnection> conn;
+  nsresult rv = mBase->Clone(aReadOnly, getter_AddRefs(conn));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsCOMPtr<mozIStorageConnection> wrapped = new DBConnection(conn);
+  wrapped.forget(aConnectionOut);
+
+  return rv;
+}
+
+NS_IMETHODIMP
+DBConnection::GetDefaultPageSize(int32_t* aSizeOut)
+{
+  return mBase->GetDefaultPageSize(aSizeOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetConnectionReady(bool* aReadyOut)
+{
+  return mBase->GetConnectionReady(aReadyOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetLastInsertRowID(int64_t* aRowIdOut)
+{
+  return mBase->GetLastInsertRowID(aRowIdOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetAffectedRows(int32_t* aCountOut)
+{
+  return mBase->GetAffectedRows(aCountOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetLastError(int32_t* aErrorOut)
+{
+  return mBase->GetLastError(aErrorOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetLastErrorString(nsACString& aErrorOut)
+{
+  return mBase->GetLastErrorString(aErrorOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetSchemaVersion(int32_t* aVersionOut)
+{
+  return mBase->GetSchemaVersion(aVersionOut);
+}
+
+NS_IMETHODIMP
+DBConnection::SetSchemaVersion(int32_t aVersion)
+{
+  return mBase->SetSchemaVersion(aVersion);
+}
+
+NS_IMETHODIMP
+DBConnection::CreateStatement(const nsACString& aQuery,
+                              mozIStorageStatement** aStatementOut)
+{
+  return mBase->CreateStatement(aQuery, aStatementOut);
+}
+
+NS_IMETHODIMP
+DBConnection::ExecuteSimpleSQL(const nsACString& aQuery)
+{
+  return mBase->ExecuteSimpleSQL(aQuery);
+}
+
+NS_IMETHODIMP
+DBConnection::TableExists(const nsACString& aTableName, bool* aExistsOut)
+{
+  return mBase->TableExists(aTableName, aExistsOut);
+}
+
+NS_IMETHODIMP
+DBConnection::IndexExists(const nsACString& aIndexName, bool* aExistsOut)
+{
+  return mBase->IndexExists(aIndexName, aExistsOut);
+}
+
+NS_IMETHODIMP
+DBConnection::GetTransactionInProgress(bool* aResultOut)
+{
+  return mBase->GetTransactionInProgress(aResultOut);
+}
+
+NS_IMETHODIMP
+DBConnection::BeginTransaction()
+{
+  return mBase->BeginTransaction();
+}
+
+NS_IMETHODIMP
+DBConnection::BeginTransactionAs(int32_t aType)
+{
+  return mBase->BeginTransactionAs(aType);
+}
+
+NS_IMETHODIMP
+DBConnection::CommitTransaction()
+{
+  return mBase->CommitTransaction();
+}
+
+NS_IMETHODIMP
+DBConnection::RollbackTransaction()
+{
+  return mBase->RollbackTransaction();
+}
+
+NS_IMETHODIMP
+DBConnection::CreateTable(const char* aTable, const char* aSchema)
+{
+  return mBase->CreateTable(aTable, aSchema);
+}
+
+NS_IMETHODIMP
+DBConnection::SetGrowthIncrement(int32_t aIncrement,
+                                 const nsACString& aDatabase)
+{
+  return mBase->SetGrowthIncrement(aIncrement, aDatabase);
+}
+
+NS_IMETHODIMP
+DBConnection::EnableModule(const nsACString& aModule)
+{
+  return mBase->EnableModule(aModule);
+}
+
+NS_IMETHODIMP
+DBConnection::GetQuotaObjects(QuotaObject** aDatabaseQuotaObject,
+                              QuotaObject** aJournalQuotaObject)
+{
+  return mBase->GetQuotaObjects(aDatabaseQuotaObject, aJournalQuotaObject);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBConnection.h b/dom/backgroundsync/DBConnection.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBConnection.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_Connection_h
+#define mozilla_dom_Connection_h
+
+#include "mozIStorageConnection.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class DBConnection final : public mozIStorageConnection
+{
+public:
+  explicit DBConnection(mozIStorageConnection* aBase);
+
+private:
+  ~DBConnection();
+
+  nsCOMPtr<mozIStorageConnection> mBase;
+  bool mClosed;
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_MOZISTORAGEASYNCCONNECTION
+  NS_DECL_MOZISTORAGECONNECTION
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_Connection_h
diff --git a/dom/backgroundsync/DBSchema.cpp b/dom/backgroundsync/DBSchema.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchema.cpp
@@ -0,0 +1,283 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBSchema.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace db {
+
+const int32_t kFirstShippedSchemaVersion = 1;
+
+namespace {
+
+// Update this whenever the DB schema is changed.
+const int32_t kLatestSchemaVersion = 1;
+
+// ---------
+const char* const kTableRegistrations =
+  "CREATE TABLE registrations ("
+    "id TEXT NOT NULL PRIMARY KEY, " // Concatenation of scope + tag
+    "origin TEXT NOT NULL, "
+    "scope TEXT NOT NULL, "
+    "tag TEXT NOT NULL, "
+    "state INTEGER NOT NULL, "
+    "lastChance INTEGER NOT NULL"
+  ")";
+// ---------
+// End schema definition
+// ---------
+
+} // namespace
+
+
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn)
+{
+  return dbutils::CreateOrMigrateSchema(aConn, kLatestSchemaVersion,
+                                        kTableRegistrations,
+                                        "registrations");
+}
+
+nsresult
+InitializeConnection(mozIStorageConnection* aConn)
+{
+  return dbutils::InitializeConnection(aConn);
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  return dbutils::IncrementalVacuum(aConn);
+}
+
+void
+GetId(const nsAString& aScope, const nsAString& aTag, nsAString& aId)
+{
+  aId = aScope + NS_LITERAL_STRING("@") + aTag;
+}
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aArgs)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsresult rv = NS_OK;
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "INSERT INTO registrations ("
+      "id, "
+      "origin, "
+      "scope, "
+      "tag, "
+      "state, "
+      "lastChance "
+    ") VALUES ("
+      ":id, "
+      ":origin, "
+      ":scope, "
+      ":tag, "
+      ":state, "
+      ":lastChance "
+    ");"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  nsString id;
+  GetId(aArgs.mScope(), aArgs.mTag(), id);
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), id);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("origin"),
+                               aArgs.mOrigin());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("scope"),
+                               aArgs.mScope());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("tag"),
+                               aArgs.mTag());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("state"),
+                              RegistrationState::PENDING);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // By default new registrations are not flagged as last chance.
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("lastChance"), 0);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+GetTags(mozIStorageConnection* aConn,
+        const SyncGetTagsArgs& aArgs,
+        nsTArray<nsString>& aTags)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT tag FROM registrations;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString tag;
+    rv = state->GetString(0, tag);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+    aTags.AppendElement(tag);
+  }
+
+  return rv;
+}
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<Registration>& aRegistrations)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT * FROM registrations;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsString id;
+    rv = state->GetString(0, id);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString origin;
+    rv = state->GetString(1, origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString scope;
+    rv = state->GetString(2, scope);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsString tag;
+    rv = state->GetString(3, tag);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t registrationState;
+    rv = state->GetInt32(4, &registrationState);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    int32_t lastChance;
+    rv = state->GetInt32(5, &lastChance);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    Registration registration(id, origin, scope, tag,
+      static_cast<RegistrationState>(registrationState),
+      lastChance);
+    aRegistrations.AppendElement(registration);
+  }
+
+  return rv;
+}
+
+nsresult
+Remove(mozIStorageConnection* aConn,
+       const SyncRemoveArgs& aArgs,
+       bool aRemoveOrigin,
+       nsAString& aOrigin)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  // Get the origin value before removing the entry from the 'registrations'
+  // DB so we can remove the entry from the 'origins' DB in case that there are
+  // no more sync registrations for that origin.
+  nsCOMPtr<mozIStorageStatement> getOriginState;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT origin FROM registrations WHERE id=:id;"
+  ), getter_AddRefs(getOriginState));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = getOriginState->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(getOriginState->ExecuteStep(&hasMoreData))
+         && hasMoreData) {
+    // We only get the origin if there's one registration. If there are
+    // more than one, we just bail out.
+    if (hasMoreData) {
+      hasMoreData = false;
+      continue;
+    }
+
+    nsString origin;
+    rv = getOriginState->GetString(0, origin);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "DELETE FROM registrations WHERE id=:id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+nsresult
+ChangeState(mozIStorageConnection* aConn,
+            const SyncChangeStateArgs& aArgs)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "UPDATE state SET state=:regstate WHERE id=:id;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindInt32ByName(NS_LITERAL_CSTRING("regstate"),
+                              static_cast<int32_t>(aArgs.mState()));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->BindStringByName(NS_LITERAL_CSTRING("id"), aArgs.mId());
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = state->Execute();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  return rv;
+}
+
+} // namespace db
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBSchema.h b/dom/backgroundsync/DBSchema.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchema.h
@@ -0,0 +1,65 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DBSchema_h
+#define mozilla_dom_DBSchema_h
+
+class mozIStorageConnection;
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace db {
+
+struct Expect;
+
+// Note, this cannot be executed within a transaction.
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn,
+                      int32_t aLatestSchemaVersion,
+                      const nsDependentCString aSql,
+                      Expect aExpect);
+
+// Note, this cannot be executed within a transaction.
+nsresult
+InitializeConnection(mozIStorageConnection* aConn);
+
+nsresult
+Register(mozIStorageConnection* aConn,
+         const SyncRegisterArgs& aArgs);
+
+nsresult
+GetTags(mozIStorageConnection* aConn,
+        const SyncGetTagsArgs& aArgs,
+        nsTArray<nsString>& aTags);
+
+nsresult
+GetAll(mozIStorageConnection* aConn,
+       nsTArray<Registration>& aRegistrations);
+
+nsresult
+Remove(mozIStorageConnection* aConn,
+       const SyncRemoveArgs& aArgs);
+
+nsresult
+ChangeState(mozIStorageConnection* aConn,
+            const SyncChangeStateArgs& aArgs);
+
+// Note, this works best when its NOT executed within a transaction.
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn);
+
+// We will wipe out databases with schema versions less than this. Newer
+// versions will be migrated on open to the latest schema version.
+extern const int32_t kFirstShippedSchemaVersion;
+
+} // namespace db
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DBSchema_h
diff --git a/dom/backgroundsync/DBSchemaUtils.cpp b/dom/backgroundsync/DBSchemaUtils.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchemaUtils.cpp
@@ -0,0 +1,368 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBSchemaUtils.h"
+
+#include "ipc/IPCMessageUtils.h"
+#include "mozIStorageConnection.h"
+#include "mozIStorageStatement.h"
+#include "mozStorageHelper.h"
+#include "nsPrintfCString.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace dbutils {
+
+namespace {
+
+const int32_t kMaxEntriesPerStatement = 255;
+
+const uint32_t kPageSize = 4 * 1024;
+
+// Grow the database in chunks to reduce fragmentation
+const uint32_t kGrowthSize = 32 * 1024;
+const uint32_t kGrowthPages = kGrowthSize / kPageSize;
+static_assert(kGrowthSize % kPageSize == 0,
+              "Growth size must be multiple of page size");
+
+// Only release free pages when we have more than this limit
+const int32_t kMaxFreePages = kGrowthPages;
+
+// Limit WAL journal to a reasonable size
+const uint32_t kWalAutoCheckpointSize = 512 * 1024;
+const uint32_t kWalAutoCheckpointPages = kWalAutoCheckpointSize / kPageSize;
+static_assert(kWalAutoCheckpointSize % kPageSize == 0,
+              "WAL checkpoint size must be multiple of page size");
+
+nsresult Validate(mozIStorageConnection* aConn,
+                  int32_t aLatestSchemaVersion,
+                  const char* aTableSql,
+                  const char* aExpectedTableName);
+nsresult Migrate(mozIStorageConnection* aConn);
+
+} // namespace
+
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn,
+                      int32_t aLatestSchemaVersion,
+                      const char* aTableSql,
+                      const char* aExpectedTableName)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  int32_t schemaVersion;
+  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (schemaVersion == aLatestSchemaVersion) {
+    // We already have the correct schema version. Validate it matches
+    // our expected schema and then proceed.
+    rv = Validate(aConn, aLatestSchemaVersion, aTableSql, aExpectedTableName);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+
+  mozStorageTransaction trans(aConn, false,
+                              mozIStorageConnection::TRANSACTION_IMMEDIATE);
+  bool needVacuum = false;
+
+  if (schemaVersion) {
+    // A schema exists, but its not the current version. Attempt to
+    // migrate it to our new schema.
+    rv = Migrate(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    // Migrations happen infrequently and reflect a change in DB structure.
+    // This is a good time to rebuild the database.  It also helps catch
+    // if a new migration is incorrect by fast failing on the corruption.
+    needVacuum = true;
+  } else {
+    // There is no schema installed.  Create the database from scratch.
+    rv = aConn->ExecuteSimpleSQL(nsDependentCString(aTableSql));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->SetSchemaVersion(aLatestSchemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = aConn->GetSchemaVersion(&schemaVersion);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  rv = Validate(aConn, aLatestSchemaVersion, aTableSql, aExpectedTableName);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  rv = trans.Commit();
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (needVacuum) {
+    // Unfortunately, this must be performed outside of the transaction.
+    aConn->ExecuteSimpleSQL(NS_LITERAL_CSTRING("VACUUM"));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+  }
+
+  return rv;
+}
+
+nsresult
+InitializeConnection(mozIStorageConnection* aConn)
+{
+  MOZ_ASSERT(!NS_IsMainThread());
+  MOZ_ASSERT(aConn);
+
+  // This function needs to perform per-connection initialization tasks that
+  // need to happen regardless of the schema.
+
+  nsPrintfCString pragmas(
+    // Use a smaller page size to improve perf/footprint; default is too large
+    "PRAGMA page_size = %u; "
+    // Enable auto_vacuum; this must happen after page_size and before WAL
+    "PRAGMA auto_vacuum = INCREMENTAL; "
+    "PRAGMA foreign_keys = ON; ",
+    kPageSize
+  );
+
+  // Note, the default encoding of UTF-8 is preferred.  mozStorage does all
+  // the work necessary to convert UTF-16 nsString values for us.  We don't
+  // need ordering and the binary equality operations are correct.  So, do
+  // NOT set PRAGMA encoding to UTF-16.
+
+  nsresult rv = aConn->ExecuteSimpleSQL(pragmas);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Limit fragmentation by growing the database by many pages at once.
+  rv = aConn->SetGrowthIncrement(kGrowthSize, EmptyCString());
+  if (rv == NS_ERROR_FILE_TOO_BIG) {
+    NS_WARNING("Not enough disk space to set sqlite growth increment.");
+    rv = NS_OK;
+  }
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Enable WAL journaling. This must be performed in a separate transaction
+  // after changing the page_size and enabling auto_vacuum.
+  nsPrintfCString wal(
+    // WAL journal can grow to given number of *pages*
+    "PRAGMA wal_autocheckpoint = %u; "
+    // Always truncate the journal back to given number of *bytes*
+    "PRAGMA journal_size_limit = %u; "
+    // WAL must be enabled at the end to allow page size to be changed, etc.
+    "PRAGMA journal_mode = WAL; ",
+    kWalAutoCheckpointPages,
+    kWalAutoCheckpointSize
+  );
+
+  rv = aConn->ExecuteSimpleSQL(wal);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Verify that we successfully set the vacuum mode to incremental.  It
+  // is very easy to put the database in a state where the auto_vacuum
+  // pragma above fails silently.
+#ifdef DEBUG
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA auto_vacuum;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t mode;
+  rv = state->GetInt32(0, &mode);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // integer value 2 is incremental mode
+  if (NS_WARN_IF(mode != 2)) { return NS_ERROR_UNEXPECTED; }
+#endif
+
+  return NS_OK;
+}
+
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn)
+{
+  // Determine how much free space is in the database.
+  nsCOMPtr<mozIStorageStatement> state;
+  nsresult rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA freelist_count;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  int32_t freePages = 0;
+  rv = state->GetInt32(0, &freePages);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // We have a relatively small page size, so we want to be careful to avoid
+  // fragmentation.  We already use a growth incremental which will cause
+  // sqlite to allocate and release multiple pages at the same time.  We can
+  // further reduce fragmentation by making our allocated chunks a bit
+  // "sticky".  This is done by creating some hysteresis where we allocate
+  // pages/chunks as soon as we need them, but we only release pages/chunks
+  // when we have a large amount of free space.  This helps with the case
+  // where a page is adding and remove resources causing it to dip back and
+  // forth across a chunk boundary.
+  //
+  // So only proceed with releasing pages if we have more than our constant
+  // threshold.
+  if (freePages <= kMaxFreePages) {
+    return NS_OK;
+  }
+
+  // Release the excess pages back to the sqlite VFS.  This may also release
+  // chunks of multiple pages back to the OS.
+  int32_t pagesToRelease = freePages - kMaxFreePages;
+
+  rv = aConn->ExecuteSimpleSQL(nsPrintfCString(
+    "PRAGMA incremental_vacuum(%d);", pagesToRelease
+  ));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  // Verify that our incremental vacuum actually did something
+#ifdef DEBUG
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "PRAGMA freelist_count;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  hasMoreData = false;
+  rv = state->ExecuteStep(&hasMoreData);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  freePages = 0;
+  rv = state->GetInt32(0, &freePages);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  MOZ_ASSERT(freePages <= kMaxFreePages);
+#endif
+
+  return NS_OK;
+}
+
+namespace {
+
+#ifdef DEBUG
+struct Expect
+{
+  // Expect exact SQL
+  Expect(const char* aName, const char* aType, const char* aSql)
+    : mName(aName)
+    , mType(aType)
+    , mSql(aSql)
+    , mIgnoreSql(false)
+  { }
+
+  // Ignore SQL
+  Expect(const char* aName, const char* aType)
+    : mName(aName)
+    , mType(aType)
+    , mIgnoreSql(true)
+  { }
+
+  const nsCString mName;
+  const nsCString mType;
+  const nsCString mSql;
+  const bool mIgnoreSql;
+};
+#endif
+
+nsresult
+Validate(mozIStorageConnection* aConn,
+         int32_t aLatestSchemaVersion,
+         const char* aExpectedTableSql,
+         const char* aExpectedTableName)
+{
+  int32_t schemaVersion;
+  nsresult rv = aConn->GetSchemaVersion(&schemaVersion);
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  if (NS_WARN_IF(schemaVersion != aLatestSchemaVersion)) {
+    return NS_ERROR_FAILURE;
+  }
+
+#ifdef DEBUG
+  nsPrintfCString autoindex("sqlite_autoindex_%s_1", aExpectedTableName);
+
+  Expect expect[] = {
+    Expect(aExpectedTableName, "table", aExpectedTableSql),
+    // auto-gen by sqlite.
+    Expect("sqlite_sequence", "table"),
+    // auto-gen by sqlite.
+    Expect(autoindex.get(), "index")
+  };
+
+  const uint32_t expectLength = sizeof(expect) / sizeof(Expect);
+
+  // Read the schema from the sqlite_master table and compare.
+  nsCOMPtr<mozIStorageStatement> state;
+  rv = aConn->CreateStatement(NS_LITERAL_CSTRING(
+    "SELECT name, type, sql FROM sqlite_master;"
+  ), getter_AddRefs(state));
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  bool hasMoreData = false;
+  while (NS_SUCCEEDED(state->ExecuteStep(&hasMoreData)) && hasMoreData) {
+    nsAutoCString name;
+    rv = state->GetUTF8String(0, name);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsAutoCString type;
+    rv = state->GetUTF8String(1, type);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsAutoCString sql;
+    rv = state->GetUTF8String(2, sql);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool foundMatch = false;
+    for (uint32_t i = 0; i < expectLength; ++i) {
+      if (name == expect[i].mName) {
+        if (type != expect[i].mType) {
+          NS_WARNING(nsPrintfCString("Unexpected type for schema entry %s",
+                     name.get()).get());
+          return NS_ERROR_FAILURE;
+        }
+
+        if (!expect[i].mIgnoreSql && sql != expect[i].mSql) {
+          NS_WARNING(nsPrintfCString("Unexpected SQL for schema entry %s",
+                     name.get()).get());
+          return NS_ERROR_FAILURE;
+        }
+
+        foundMatch = true;
+        break;
+      }
+    }
+
+    if (NS_WARN_IF(!foundMatch)) {
+      NS_WARNING(nsPrintfCString("Unexpected schema entry %s in BSync database",
+                 name.get()).get());
+      return NS_ERROR_FAILURE;
+    }
+  }
+#endif
+
+  return rv;
+}
+
+nsresult
+Migrate(mozIStorageConnection* aConn)
+{
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+} // anonymous namespace
+
+} // namespace dbutils
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/DBSchemaUtils.h b/dom/backgroundsync/DBSchemaUtils.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/DBSchemaUtils.h
@@ -0,0 +1,38 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_DBSchemaUtils_h
+#define mozilla_dom_DBSchemaUtils_h
+
+class mozIStorageConnection;
+struct nsID;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+namespace dbutils {
+
+// Note, this cannot be executed within a transaction.
+nsresult
+CreateOrMigrateSchema(mozIStorageConnection* aConn,
+                      int32_t aLatestSchemaVersion,
+                      const char* aTableSql,
+                      const char* aExpectedTableName);
+
+// Note, this cannot be executed within a transaction.
+nsresult
+InitializeConnection(mozIStorageConnection* aConn);
+
+// Note, this works best when its NOT executed within a transaction.
+nsresult
+IncrementalVacuum(mozIStorageConnection* aConn);
+
+} // namespace dbutils
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_DBSchemaUtils_h
diff --git a/dom/backgroundsync/PBackgroundSync.ipdl b/dom/backgroundsync/PBackgroundSync.ipdl
--- a/dom/backgroundsync/PBackgroundSync.ipdl
+++ b/dom/backgroundsync/PBackgroundSync.ipdl
@@ -5,24 +5,26 @@
 include protocol PBackground;
 
 include BackgroundSyncIPCTypes;
 
 using struct nsID from "nsID.h";
 
 namespace mozilla {
 namespace dom {
+namespace backgroundsync {
 
 protocol PBackgroundSync
 {
   manager PBackground;
 
 parent: // child -> parent messages
   async Request(nsID aRequestId, SyncOp aOp);
   async Shutdown();
 
 child: // parent -> child messages
   async Response(nsID requestId, SyncOpResponse aResponse);
   async __delete__();
 };
 
+} // namespace backgroundsync
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/QuotaClient.cpp b/dom/backgroundsync/QuotaClient.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/QuotaClient.cpp
@@ -0,0 +1,185 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "QuotaClient.h"
+#include "StorageManager.h"
+
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/dom/quota/UsageInfo.h"
+#include "mozilla/ipc/BackgroundParent.h"
+#include "nsIFile.h"
+#include "nsISimpleEnumerator.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::DebugOnly;
+using mozilla::dom::ContentParentId;
+using mozilla::dom::backgroundsync::StorageManager;
+using mozilla::dom::quota::Client;
+using mozilla::dom::quota::PersistenceType;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::UsageInfo;
+using mozilla::ipc::AssertIsOnBackgroundThread;
+
+class BackgroundSyncQuotaClient final : public Client
+{
+public:
+  virtual Type
+  GetType() override
+  {
+    return BACKGROUNDSYNC;
+  }
+
+  virtual nsresult
+  InitOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
+             const nsACString& aOrigin, UsageInfo* aUsageInfo) override
+  {
+    // The QuotaManager passes a nullptr UsageInfo if there is no quota being
+    // enforced against the origin.
+    if (!aUsageInfo) {
+      return NS_OK;
+    }
+
+    return GetUsageForOrigin(aPersistenceType, aGroup, aOrigin, aUsageInfo);
+  }
+
+  virtual nsresult
+  GetUsageForOrigin(PersistenceType aPersistenceType, const nsACString& aGroup,
+                    const nsACString& aOrigin, UsageInfo* aUsageInfo) override
+  {
+    MOZ_ASSERT(aUsageInfo);
+
+    QuotaManager* qm = QuotaManager::Get();
+    MOZ_ASSERT(qm);
+
+    nsCOMPtr<nsIFile> dir;
+    nsresult rv = qm->GetDirectoryForOrigin(aPersistenceType, aOrigin,
+                                            getter_AddRefs(dir));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    rv = dir->Append(NS_LITERAL_STRING(BACKGROUNDSYNC_DIRECTORY_NAME));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    nsCOMPtr<nsISimpleEnumerator> entries;
+    rv = dir->GetDirectoryEntries(getter_AddRefs(entries));
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    bool hasMore;
+    while (NS_SUCCEEDED(rv = entries->HasMoreElements(&hasMore)) && hasMore &&
+           !aUsageInfo->Canceled()) {
+      nsCOMPtr<nsISupports> entry;
+      rv = entries->GetNext(getter_AddRefs(entry));
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      nsCOMPtr<nsIFile> file = do_QueryInterface(entry);
+
+      nsAutoString leafName;
+      rv = file->GetLeafName(leafName);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      bool isDir;
+      rv = file->IsDirectory(&isDir);
+      if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+      if (isDir) {
+        NS_WARNING("Unknown BackgroundSync directory found!");
+        continue;
+      }
+
+      // Ignore transient sqlite files and marker files
+      if (leafName.EqualsLiteral("registrations.sqlite-journal") ||
+          leafName.EqualsLiteral("registrations.sqlite-shm") ||
+          leafName.Find(NS_LITERAL_CSTRING("registrations.sqlite-mj"), false, 0, 0) == 0 ||
+          leafName.EqualsLiteral("context_open.marker")) {
+        continue;
+      }
+
+      if (leafName.EqualsLiteral("registrations.sqlite") ||
+          leafName.EqualsLiteral("registrations.sqlite-wal")) {
+        int64_t fileSize;
+        rv = file->GetFileSize(&fileSize);
+        if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+        MOZ_ASSERT(fileSize >= 0);
+
+        aUsageInfo->AppendToDatabaseUsage(fileSize);
+        continue;
+      }
+
+      NS_WARNING("Unknown BackgroundSync file found!");
+    }
+
+    return NS_OK;
+  }
+
+  virtual void
+  OnOriginClearCompleted(PersistenceType aPersistenceType,
+                         const nsACString& aOrigin) override
+  { }
+
+  virtual void
+  ReleaseIOThreadObjects() override
+  {
+    // Nothing to do here as the StorageContext handles cleaning everything up
+    // automatically.
+  }
+
+  virtual void
+  AbortOperations(const nsACString& aOrigin) override
+  {
+    AssertIsOnBackgroundThread();
+
+    StorageManager::Abort(aOrigin);
+  }
+
+  virtual void
+  AbortOperationsForProcess(ContentParentId aContentParentId) override
+  { }
+
+  virtual void
+  StartIdleMaintenance() override
+  { }
+
+  virtual void
+  StopIdleMaintenance() override
+  { }
+
+  virtual void
+  ShutdownWorkThreads() override
+  {
+    AssertIsOnBackgroundThread();
+
+    // spins the event loop and synchronously shuts down all StorageManagers.
+    StorageManager::ShutdownAll();
+  }
+
+private:
+  ~BackgroundSyncQuotaClient()
+  {
+    AssertIsOnBackgroundThread();
+  }
+
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncQuotaClient, override)
+};
+
+} // namespace
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+already_AddRefed<mozilla::dom::quota::Client> CreateQuotaClient()
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<BackgroundSyncQuotaClient> ref = new BackgroundSyncQuotaClient();
+  return ref.forget();
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/QuotaClient.h b/dom/backgroundsync/QuotaClient.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/QuotaClient.h
@@ -0,0 +1,24 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_backgroundsync_QuotaClient_h
+#define mozilla_dom_backgroundsync_QuotaClient_h
+
+#include "mozilla/Attributes.h"
+#include "mozilla/dom/quota/Client.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+already_AddRefed<mozilla::dom::quota::Client>
+CreateQuotaClient();
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_backgroundsync_QuotaClient_h
diff --git a/dom/backgroundsync/StorageAction.cpp b/dom/backgroundsync/StorageAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.cpp
@@ -0,0 +1,40 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageAction.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+void
+StorageAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual BackgroundSync could have its StorageActions canceled
+  // and then shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+StorageAction::StorageAction()
+  : mCanceled(false)
+{
+}
+
+StorageAction::~StorageAction()
+{
+}
+
+bool
+StorageAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageAction.h b/dom/backgroundsync/StorageAction.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.h
@@ -0,0 +1,102 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageAction_h
+#define mozilla_dom_StorageAction_h
+
+#include "BackgroundSyncTypes.h"
+
+#include "mozilla/Atomics.h"
+#include "nsISupportsImpl.h"
+
+class mozIStorageConnection;
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+class StorageAction
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageAction)
+
+  class Resolver
+  {
+  public:
+    // Note: StorageAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       StorageAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple StorageActions running on the same thread/StorageContext.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread.  Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: StorageAction should hold Resolver ref until its ready to call
+  //        Resolve().
+  // Note: The "target" thread is determined when the StorageAction is scheduled
+  //       on StorageContext. The StorageAction should not assume any particular
+  //       thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the StorageAction is canceled.
+  // The StorageAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT. If
+  // CancelOnInitiatingThread() is called after Resolve() has already occurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the StorageAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent
+  // calls should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+protected:
+  StorageAction();
+
+  // virtual because deleted through base class pointer
+  virtual ~StorageAction();
+
+  // Check if this StorageAction has been canceled.
+  // May be called from any thread, but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageAction_h
diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageContext.cpp
@@ -0,0 +1,1116 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageAction.h"
+#include "StorageContext.h"
+#include "StorageManager.h"
+#include "StorageManagerId.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozIStorageConnection.h"
+#include "nsIFile.h"
+#include "nsIPrincipal.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::backgroundsync::StorageAction;
+using mozilla::dom::backgroundsync::QuotaInfo;
+
+class NullAction final : public StorageAction
+{
+public:
+  NullAction()
+  {
+  }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
+  {
+    // Resolve success immediately. This Action does no actual work.
+    MOZ_ASSERT(aResolver);
+    aResolver->Resolve(NS_OK);
+  }
+};
+
+} // namespace
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::AssertIsOnIOThread;
+using mozilla::dom::quota::OpenDirectoryListener;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+using mozilla::dom::quota::DirectoryLock;
+
+class StorageContext::Data final : public StorageAction::Data
+{
+public:
+  explicit Data(nsIThread* aTarget)
+    : mTarget(aTarget)
+  {
+    MOZ_ASSERT(mTarget);
+  }
+
+  virtual mozIStorageConnection*
+  GetConnection() const override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    return mConnection;
+  }
+
+  virtual void
+  SetConnection(mozIStorageConnection* aConn) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(!mConnection);
+    mConnection = aConn;
+    MOZ_ASSERT(mConnection);
+  }
+
+private:
+  ~Data()
+  {
+    // We could proxy release our data here, but instead just assert. The
+    // StorageContext code should guarantee that we are destroyed on the target
+    // thread once the connection is initialized. If we're not, then
+    // QuotaManager might race and try to clear the origin out from under us.
+    MOZ_ASSERT_IF(mConnection, mTarget == NS_GetCurrentThread());
+  }
+
+  nsCOMPtr<nsIThread> mTarget;
+  nsCOMPtr<mozIStorageConnection> mConnection;
+
+  // Threadsafe counting because we're created on the PBackground thread
+  // and destroyed on the target IO thread.
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageContext::Data)
+};
+
+// Executed to perform the complicated dance of steps necessary to initialize
+// the QuotaManager.This must be performed for each origin before any disk
+// IO occurrs.
+class StorageContext::QuotaInitRunnable final : public nsIRunnable
+                                              , public OpenDirectoryListener
+{
+public:
+  QuotaInitRunnable(StorageContext* aContext,
+                    StorageManager* aManager,
+                    Data* aData,
+                    nsIThread* aTarget,
+                    StorageAction* aInitAction)
+    : mContext(aContext)
+    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
+    , mManager(aManager)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mInitAction(aInitAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mResult(NS_OK)
+    , mState(STATE_INIT)
+    , mCanceled(false)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mManager);
+    MOZ_ASSERT(mData);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mInitiatingThread);
+    MOZ_ASSERT(mInitAction);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_GET_INFO;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(!mCanceled);
+    mCanceled = true;
+    mInitAction->CancelOnInitiatingThread();
+  }
+
+  void OpenDirectory();
+
+  // OpenDirectoryListener methods
+  virtual void
+  DirectoryLockAcquired(mozilla::dom::quota::DirectoryLock* aLock) override;
+
+  virtual void
+  DirectoryLockFailed() override;
+
+private:
+  class SyncResolver final : public StorageAction::Resolver
+  {
+  public:
+    SyncResolver()
+      : mResolved(false)
+      , mResult(NS_OK)
+    { }
+
+    virtual void
+    Resolve(nsresult aRv) override
+    {
+      MOZ_ASSERT(!mResolved);
+      mResolved = true;
+      mResult = aRv;
+    };
+
+    bool Resolved() const { return mResolved; }
+    nsresult Result() const { return mResult; }
+
+  private:
+    ~SyncResolver() { }
+
+    bool mResolved;
+    nsresult mResult;
+
+    NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
+                               override)
+  };
+
+  ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mInitAction);
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_GET_INFO,
+    STATE_CREATE_QUOTA_MANAGER,
+    STATE_OPEN_DIRECTORY,
+    STATE_WAIT_FOR_DIRECTORY_LOCK,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Complete(nsresult aResult)
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
+
+    MOZ_ASSERT(NS_SUCCEEDED(mResult));
+    mResult = aResult;
+
+    mState = STATE_COMPLETING;
+    MOZ_ALWAYS_SUCCEEDS(
+      mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mManager = nullptr;
+    mInitAction = nullptr;
+  }
+
+  RefPtr<StorageContext> mContext;
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+  RefPtr<StorageManager> mManager;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<StorageAction> mInitAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsresult mResult;
+  QuotaInfo mQuotaInfo;
+  RefPtr<quota::DirectoryLock> mDirectoryLock;
+  State mState;
+  Atomic<bool> mCanceled;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+void
+StorageContext::QuotaInitRunnable::OpenDirectory()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
+             mState == STATE_OPEN_DIRECTORY);
+  MOZ_ASSERT(QuotaManager::Get());
+
+  // QuotaManager::OpenDirectory() will hold a reference to us as
+  // a listener. We will then get DirectoryLockAcquired() on the owning
+  // thread when it is safe to access our storage directory.
+  mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
+  QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
+                                     mQuotaInfo.mGroup,
+                                     mQuotaInfo.mOrigin,
+                                     mQuotaInfo.mIsApp,
+                                     mozilla::dom::quota::Client::BACKGROUNDSYNC,
+                                     /* aExclusive */ false,
+                                     this);
+}
+
+void
+StorageContext::QuotaInitRunnable::DirectoryLockAcquired(
+    mozilla::dom::quota::DirectoryLock* aLock)
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  mDirectoryLock = aLock;
+
+  if (mCanceled) {
+    Complete(NS_ERROR_ABORT);
+    return;
+  }
+
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+
+  mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+  nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Complete(rv);
+    return;
+  }
+}
+
+void
+StorageContext::QuotaInitRunnable::DirectoryLockFailed()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  NS_WARNING("Failed to acquire a directory lock!");
+
+  Complete(NS_ERROR_FAILURE);
+}
+
+NS_IMPL_ISUPPORTS(StorageContext::QuotaInitRunnable, nsIRunnable);
+
+// The QuotaManager init state machine is represented in the following diagram:
+//
+//    +---------------+
+//    |     Start     |      Resolve(error)
+//    | (Orig Thread) +---------------------+
+//    +-------+-------+                     |
+//            |                             |
+// +----------v-----------+                 |
+// |       GetInfo        |  Resolve(error) |
+// |    (Main Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |  CreateQuotaManager  |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |    OpenDirectory     |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// | WaitForDirectoryLock |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v------------+                |
+// |EnsureOriginInitialized| Resolve(error) |
+// |   (Quota IO Thread)   +----------------+
+// +----------+------------+                |
+//            |                             |
+// +----------v------------+                |
+// |     RunOnTarget       | Resolve(error) |
+// |   (Target Thread)     +----------------+
+// +----------+------------+                |
+//            |                             |
+//  +---------v---------+            +------v------+
+//  |      Running      |            |  Completing |
+//  | (Target Thread)   +------------>(Orig Thread)|
+//  +-------------------+            +------+------+
+//                                          |
+//                                    +-----v----+
+//                                    | Complete |
+//                                    +----------+
+//
+// The initialization process proceeds through the main states.  If an error
+// occurs, then we transition to Completing state back on the original thread.
+NS_IMETHODIMP
+StorageContext::QuotaInitRunnable::Run()
+{
+  // May run on different threads depending on the state.  See individual
+  // state cases for thread assertions.
+
+  RefPtr<SyncResolver> resolver = new SyncResolver();
+
+  switch(mState) {
+    // -----------------------------------
+    case STATE_GET_INFO:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
+      nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
+      nsresult rv = QuotaManager::GetInfoFromPrincipal(principal,
+                                                       &mQuotaInfo.mGroup,
+                                                       &mQuotaInfo.mOrigin,
+                                                       &mQuotaInfo.mIsApp);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_CREATE_QUOTA_MANAGER;
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // ----------------------------------
+    case STATE_CREATE_QUOTA_MANAGER:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (mCanceled || QuotaManager::IsShuttingDown()) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      if (QuotaManager::Get()) {
+        OpenDirectory();
+        return NS_OK;
+      }
+
+      mState = STATE_OPEN_DIRECTORY;
+      QuotaManager::GetOrCreate(this);
+      break;
+    }
+    // ----------------------------------
+    case STATE_OPEN_DIRECTORY:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (NS_WARN_IF(!QuotaManager::Get())) {
+        resolver->Resolve(NS_ERROR_FAILURE);
+        break;
+      }
+
+      OpenDirectory();
+      break;
+    }
+    // ----------------------------------
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+    {
+      AssertIsOnIOThread();
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
+                                                  mQuotaInfo.mGroup,
+                                                  mQuotaInfo.mOrigin,
+                                                  mQuotaInfo.mIsApp,
+                                                  getter_AddRefs(mQuotaInfo.mDir));
+      if (NS_FAILED(rv)) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_RUN_ON_TARGET;
+
+      MOZ_ALWAYS_SUCCEEDS(
+        mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+
+      mState = STATE_RUNNING;
+
+      // Execute the provided initialization StorageAction. The
+      // StorageAction must Resolve() before returning.
+      mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
+      MOZ_ASSERT(resolver->Resolved());
+
+      mData = nullptr;
+
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+      mInitAction->CompleteOnInitiatingThread(mResult);
+      mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
+      mState = STATE_COMPLETE;
+
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----
+    case STATE_WAIT_FOR_DIRECTORY_LOCK:
+    default:
+    {
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+    }
+  }
+
+  if (resolver->Resolved()) {
+    Complete(resolver->Result());
+  }
+
+  return NS_OK;
+}
+
+// Runnable wrapper around StorageAction objects dispatched on the StorageContext.
+// This runnable executes the StorageAction on the appropriate threads while the
+// StorageContext is initialized.
+class StorageContext::ActionRunnable final : public nsIRunnable
+                                           , public StorageAction::Resolver
+                                           , public StorageContext::Activity
+{
+public:
+  ActionRunnable(StorageContext* aContext, Data* aData, nsIEventTarget* aTarget,
+                 StorageAction* aAction, const QuotaInfo& aQuotaInfo)
+    : mContext(aContext)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaInfo(aQuotaInfo)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+    , mExecutingRunOnTarget(false)
+  {
+    MOZ_ASSERT(mContext);
+    // mData may be nullptr
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  virtual void
+  Cancel() override
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    mAction->CancelOnInitiatingThread();
+  }
+
+  virtual void Resolve(nsresult aRv) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(mState == STATE_RUNNING);
+
+    mResult = aRv;
+
+    // We ultimately must complete on the initiating thread, but bounce through
+    // the current thread again to ensure that we don't destroy objects and
+    // state out from under the currently running action's stack.
+    mState = STATE_RESOLVING;
+
+    // If we were resolved synchronously within Action::RunOnTarget() then we
+    // can avoid a thread bounce and just resolve once RunOnTarget() returns.
+    // The Run() method will handle this by looking at mState after
+    // RunOnTarget() returns.
+    if (mExecutingRunOnTarget) {
+      return;
+    }
+
+    // Otherwise we are in an asynchronous resolve.  And must perform a thread
+    // bounce to run on the target thread again.
+    MOZ_ALWAYS_SUCCEEDS(
+      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+private:
+  ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->RemoveActivity(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_RESOLVING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  RefPtr<StorageContext> mContext;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  RefPtr<StorageAction> mAction;
+  const QuotaInfo mQuotaInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+  // Only accessible on target thread;
+  bool mExecutingRunOnTarget;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(StorageContext::ActionRunnable, nsIRunnable);
+
+// The ActionRunnable has a simpler state machine.  It basically needs to run
+// the action on the target thread and then complete on the original thread.
+//
+//   +-------------+
+//   |    Start    |
+//   |(Orig Thread)|
+//   +-----+-------+
+//         |
+// +-------v---------+
+// |  RunOnTarget    |
+// |Target IO Thread)+---+ Resolve()
+// +-------+---------+   |
+//         |             |
+// +-------v----------+  |
+// |     Running      |  |
+// |(Target IO Thread)|  |
+// +------------------+  |
+//         | Resolve()   |
+// +-------v----------+  |
+// |     Resolving    <--+                   +-------------+
+// |                  |                      |  Completing |
+// |(Target IO Thread)+---------------------->(Orig Thread)|
+// +------------------+                      +-------+-----+
+//                                                   |
+//                                                   |
+//                                              +----v---+
+//                                              |Complete|
+//                                              +--------+
+//
+// Its important to note that synchronous actions will effectively Resolve()
+// out of the Running state immediately. Asynchronous StorageActions may remain
+// in the Running state for some time, but normally the ActionRunnable itself
+// does not see any execution there. Its all handled internal to the StorageAction.
+NS_IMETHODIMP
+StorageContext::ActionRunnable::Run()
+{
+  switch(mState) {
+    // ----------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      MOZ_ASSERT(!mExecutingRunOnTarget);
+
+      // Note that we are calling RunOnTarget().  This lets us detect
+      // if Resolve() is called synchronously.
+      AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
+      mExecutingRunOnTarget = true;
+
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaInfo, mData);
+
+      mData = nullptr;
+
+      // Resolve was called synchronously from RunOnTarget(). We can
+      // immediately move to completing now since we are sure RunOnTarget()
+      // completed.
+      if (mState == STATE_RESOLVING) {
+        // Use recursion instead of switch case fall-through...  Seems slightly
+        // easier to understand.
+        Run();
+      }
+
+      break;
+    }
+    // -----------------
+    case STATE_RESOLVING:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // The call to StorageAction::RunOnTarget() must have returned now if we
+      // are running on the target thread again.  We may now proceed
+      // with completion.
+      mState = STATE_COMPLETING;
+      // Shutdown must be delayed until all Contexts are destroyed.  Crash
+      // for this invariant violation.
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----------------
+    default:
+    {
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+    }
+  }
+  return NS_OK;
+}
+
+void
+StorageContext::ThreadsafeHandle::AllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    AllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all StorageContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+void
+StorageContext::ThreadsafeHandle::InvalidateAndAllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    InvalidateAndAllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all StorageContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+StorageContext::ThreadsafeHandle::ThreadsafeHandle(StorageContext* aContext)
+  : mStrongRef(aContext)
+  , mWeakRef(aContext)
+  , mOwningThread(NS_GetCurrentThread())
+{
+}
+
+StorageContext::ThreadsafeHandle::~ThreadsafeHandle()
+{
+  // Normally we only touch mStrongRef on the owning thread.  This is safe,
+  // however, because when we do use mStrongRef on the owning thread we are
+  // always holding a strong ref to the ThreadsafeHandle via the owning
+  // runnable.  So we cannot run the ThreadsafeHandle destructor simultaneously.
+  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  NS_ProxyRelease(mOwningThread, mStrongRef.forget());
+}
+
+void
+StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+
+  // A StorageContext "closes" when its ref count drops to zero. Dropping this
+  // strong ref is necessary, but not sufficient for the close to occur.
+  // Any outstanding IO will continue and keep the StorageContext alive. Once
+  // the StorageContext is idle, it will be destroyed.
+
+  // First, tell the context to flush any target thread shared data. This
+  // data must be released on the target thread prior to running the
+  // StorageContext destructor. This will schedule an Action which ensures that
+  // the ~StorageContext() is not immediately executed when we drop the strong
+  // ref.
+  if (mStrongRef) {
+    mStrongRef->DoomTargetData();
+  }
+
+  // Now drop our strong ref and let StorageContext finish running any
+  // outstanding StorageActions.
+  mStrongRef = nullptr;
+}
+
+void
+StorageContext::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  // Cancel the StorageContext through the weak reference. This means we can
+  // allow the StorageContext to close by dropping the strong ref, but then
+  // still cancel ongoing IO if necessary.
+  if (mWeakRef) {
+    mWeakRef->Invalidate();
+  }
+  // We should synchronously have AllowToCloseOnOwningThread called when
+  // the Context is canceled.
+  MOZ_ASSERT(!mStrongRef);
+}
+
+void
+StorageContext::ThreadsafeHandle::StorageContextDestroyed(StorageContext* aContext)
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  MOZ_ASSERT(!mStrongRef);
+  MOZ_ASSERT(mWeakRef);
+  MOZ_ASSERT(mWeakRef == aContext);
+  mWeakRef = nullptr;
+}
+
+// static
+already_AddRefed<StorageContext>
+StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
+                       StorageAction* aInitAction, StorageContext* aOldContext)
+{
+  RefPtr<StorageContext> context =
+    new StorageContext(aManager, aTarget, aInitAction);
+  context->Init(aOldContext);
+  return context.forget();
+}
+
+StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
+                               StorageAction* aInitAction)
+  : mManager(aManager)
+  , mTarget(aTarget)
+  , mData(new Data(aTarget))
+  , mState(STATE_CONTEXT_PREINIT)
+  , mOrphanedData(false)
+  , mInitAction(aInitAction)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mTarget);
+}
+
+void
+StorageContext::Dispatch(StorageAction* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aAction);
+
+  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT ||
+             mState == STATE_CONTEXT_PREINIT) {
+    PendingStorageAction* pending = mPendingActions.AppendElement();
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aAction);
+}
+
+void
+StorageContext::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  // In PREINIT state we have not dispatch the init action yet.  Just
+  // forget it.
+  if (mState == STATE_CONTEXT_PREINIT) {
+    MOZ_ASSERT(!mInitRunnable);
+    mInitAction = nullptr;
+
+  // In INIT state we have dispatched the runnable, but not received the
+  // async completion yet.  Cancel the runnable, but don't forget about it
+  // until we get OnQuotaInit() callback.
+  } else if (mState == STATE_CONTEXT_INIT) {
+    mInitRunnable->Cancel();
+  }
+
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  {
+    ActivityList::ForwardIterator iter(mActivityList);
+    while (iter.HasMore()) {
+      iter.GetNext()->Cancel();
+    }
+  }
+  AllowToClose();
+}
+
+bool
+StorageContext::IsCanceled() const
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  return mState == STATE_CONTEXT_CANCELED;
+}
+
+void
+StorageContext::Invalidate()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  mManager->NoteClosing();
+  CancelAll();
+}
+
+void
+StorageContext::AllowToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->AllowToClose();
+  }
+}
+
+StorageContext::~StorageContext()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(!mData);
+
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->StorageContextDestroyed(this);
+  }
+
+  // Note, this may set the mOrphanedData flag.
+  mManager->RemoveStorageContext(this);
+
+  if (mNextContext) {
+    mNextContext->Start();
+  }
+}
+
+void
+StorageContext::Init(StorageContext* aOldContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  if (aOldContext) {
+    aOldContext->SetNextContext(this);
+    return;
+  }
+
+  Start();
+}
+
+void
+StorageContext::Start()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  // Previous context closing delayed our start, but then we were canceled.
+  // In this case, just do nothing here.
+  if (mState == STATE_CONTEXT_CANCELED) {
+    MOZ_ASSERT(!mInitRunnable);
+    MOZ_ASSERT(!mInitAction);
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
+  MOZ_ASSERT(!mInitRunnable);
+
+  mInitRunnable = new QuotaInitRunnable(this, mManager, mData, mTarget,
+                                        mInitAction);
+  mInitAction = nullptr;
+
+  mState = STATE_CONTEXT_INIT;
+
+  nsresult rv = mInitRunnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all StorageContexts are destroyed.
+    // Shutdown must also prevent any new StorageContexts from being constructed.
+    // Crash for this invariant violation.
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  RefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
+
+  if (aDoomData) {
+    mData = nullptr;
+  }
+
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all Contexts are destroyed.  Crash
+    // for this invariant violation.
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+  AddActivity(runnable);
+}
+
+void
+StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                            already_AddRefed<quota::DirectoryLock> aDirectoryLock)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  MOZ_ASSERT(mInitRunnable);
+  mInitRunnable = nullptr;
+
+  mQuotaInfo = aQuotaInfo;
+
+  // Always save the directory lock to ensure QuotaManager does not shutdown
+  // before the StorageContext has gone away.
+  MOZ_ASSERT(!mDirectoryLock);
+  mDirectoryLock = aDirectoryLock;
+
+  // If we opening the context failed, but we were not explicitly canceled,
+  // still treat the entire context as canceled.  We don't want to allow
+  // new actions to be dispatched.  We also cannot leave the context in
+  // the INIT state after failing to open.
+  if (NS_FAILED(aRv)) {
+    mState = STATE_CONTEXT_CANCELED;
+  }
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    mThreadsafeHandle->AllowToClose();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+StorageContext::AddActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+  mActivityList.AppendElement(aActivity);
+}
+
+void
+StorageContext::RemoveActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+}
+
+void
+StorageContext::NoteOrphanedData()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  // This may be called more than once
+  mOrphanedData = true;
+}
+
+already_AddRefed<StorageContext::ThreadsafeHandle>
+StorageContext::CreateThreadsafeHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  if (!mThreadsafeHandle) {
+    mThreadsafeHandle = new ThreadsafeHandle(this);
+  }
+  RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
+  return ref.forget();
+}
+
+void
+StorageContext::SetNextContext(StorageContext* aNextContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aNextContext);
+  MOZ_ASSERT(!mNextContext);
+  mNextContext = aNextContext;
+}
+
+void
+StorageContext::DoomTargetData()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(mData);
+
+  // We are about to drop our reference to the Data. We need to ensure that
+  // the ~StorageContext() destructor does not run until contents of Data have
+  // been released on the Target thread.
+
+  // Dispatch a no-op StorageAction. This will hold the StorageContext alive
+  // through a roundtrip to the target thread and back to the owning thread.
+  // The ref to the Data object is cleared on the owning thread after creating
+  // the ActionRunnable, but before dispatching it.
+  RefPtr<StorageAction> action = new NullAction();
+  DispatchAction(action, true /* doomed data */);
+
+  MOZ_ASSERT(!mData);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageContext.h b/dom/backgroundsync/StorageContext.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageContext.h
@@ -0,0 +1,218 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageContext_h
+#define mozilla_dom_StorageContext_h
+
+#include "BackgroundSyncTypes.h"
+#include "StorageAction.h"
+
+namespace mozilla {
+namespace dom {
+
+namespace quota {
+  class DirectoryLock;
+} // namespace quota
+
+namespace backgroundsync {
+
+class StorageManager;
+
+/**
+ * The StorageContext class is RAII-style class for managing IO operations
+ * within Background Sync storage.
+ *
+ * When a StorageContext is created it performs the complicated steps necessary
+ * to initialize the QuotaManager. StorageAction objects dispatched on the
+ * Context are delayed until this initialization is complete. They are then
+ * allow to execute on any specified thread. Once all references to the
+ * StorageContext are gone, then the steps necessary to release the QuotaManager
+ * are performed. After initialization the StorageContext holds a self reference,
+ * so it will stay alive until one of three conditions occur:
+ *
+ * 1) The StorageManager will call StorageContext::AllowToClose() when all of
+ *    the actors have removed themselves as listener. This means an idle
+ *    context with no active DOM objects will close gracefully.
+ * 2) The QuotaManager aborts all operations so it can delete the files.
+ *    In this case the QuotaManager calls Client::AbortOperations() which
+ *    in turn cancels all existing StorageAction objects and then marks the
+ *    StorageManager as invalid.
+ * 3) Browser shutdown occurs and the StorageManager calls
+ *    StorageContext::CancelAll()
+ *
+ * In either case, though, the StorageAction objects must be destroyed first to
+ * allow the StorageContext to be destroyed.
+ *
+ * While the StorageContext performs operations asynchronously on threads, all
+ * of methods in its public interface must be called on the same thread
+ * originally used to create the Context.
+ */
+
+class StorageContext final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageContext)
+
+  // Define a class allowing other threads to hold the StorageContext alive.
+  // This also allows these other threads to safely close or cancel the
+  // StorageContext.
+  class ThreadsafeHandle final
+  {
+    friend class StorageContext;
+
+  public:
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ThreadsafeHandle)
+
+    void AllowToClose();
+    void InvalidateAndAllowToClose();
+
+  private:
+    explicit ThreadsafeHandle(StorageContext* aContext);
+    ~ThreadsafeHandle();
+
+    // Disallow copying.
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
+    void AllowToCloseOnOwningThread();
+    void InvalidateAndAllowToCloseOnOwningThread();
+
+    void StorageContextDestroyed(StorageContext* aContext);
+
+    // Cleared to allow the StorageContext to close.  Only safe to access on
+    // owning thread.
+    RefPtr<StorageContext> mStrongRef;
+
+    // Used to support cancelation even while the StorageContext is already
+    // allowed to close.  Cleared by ~StorageContext() calling
+    // StorageContextDestroyed().  Only safe to access on owning thread.
+    StorageContext* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+  };
+
+  // Different objects hold references to the StorageContext while some work is
+  // being performed asynchronously. These objects must implement the Activity
+  // interface and register themselves with the AddActivity().  When they are
+  // destroyed they must call RemoveActivity(). This allows the StorageContext
+  // to cancel any outstanding Activity work when the Context is cancelled.
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+  };
+
+  // Create a Context attached to the given StorageManager.
+  // The given StorageAction will run on the QuotaManager IO thread.
+  // Note, this StorageAction must be execute synchronously.
+  static already_AddRefed<StorageContext>
+  Create(StorageManager* aManager, nsIThread* aTarget,
+         StorageAction* aInitAction, StorageContext* aOldContext);
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(StorageAction* aAction);
+
+  // Cancel any StorageActions running or waiting to run.
+  // This should allow the StorageContext to be released and
+  // Listener::RemoveContext() will be called when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+  // True if CancelAll() has been called.
+  bool IsCanceled() const;
+
+  // Like CancelAll(), but also marks the Manager as "invalid".
+  void Invalidate();
+
+  // Remove any self references and allow the StorageContext to be released
+  // when there are no more StorageActions to process.
+  void AllowToClose();
+
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo&
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
+  // Tell the StorageContext that some state information has been orphaned in
+  // the data store and won't be cleaned up. The StoargeContext will leave the
+  // marker in place to trigger cleanup the next times its opened.
+  void NoteOrphanedData();
+
+private:
+  class Data;
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_PREINIT,
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingStorageAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    RefPtr<StorageAction> mAction;
+  };
+
+  StorageContext(StorageManager* aManager, nsIThread* aTarget,
+                 StorageAction* aInitAction);
+  ~StorageContext();
+  void Init(StorageContext* aOldContext);
+  void Start();
+  void DispatchAction(StorageAction* aAction, bool aDoomData = false);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+    already_AddRefed<mozilla::dom::quota::DirectoryLock> aDirectoryLock);
+
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
+
+  void
+  SetNextContext(StorageContext* aNextContext);
+
+  void
+  DoomTargetData();
+
+  RefPtr<StorageManager> mManager;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<Data> mData;
+  State mState;
+  bool mOrphanedData;
+  QuotaInfo mQuotaInfo;
+  RefPtr<QuotaInitRunnable> mInitRunnable;
+  RefPtr<StorageAction> mInitAction;
+  nsTArray<PendingStorageAction> mPendingActions;
+
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us. This creates
+  // a ref-cycle that keeps the StorageContext alive.  The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  RefPtr<mozilla::dom::quota::DirectoryLock> mDirectoryLock;
+  RefPtr<StorageContext> mNextContext;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageContext_h
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -0,0 +1,781 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "DBAction.h"
+#include "StorageContext.h"
+#include "StorageManager.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/StaticMutex.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+namespace {
+
+// StorageActions that are executed when a StorageContext is first created.
+// It ensures that the database is setup properly.
+// This lets other actions not worry about these details.
+class SetupAction final : public SyncDBAction
+{
+public:
+  SetupAction()
+    : SyncDBAction(DBAction::Create)
+  { }
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    // Executes in its own transaction.
+    nsresult rv = db::CreateOrMigrateSchema(aConn);
+    if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+    return rv;
+  }
+};
+
+} // anonymous namespace
+
+// ---------------------------------------------------------------------------
+
+// Singleton class to track StorageManager instances and ensure there is only
+// one for each unique StorageManagerId.
+class StorageManager::Factory
+{
+public:
+  friend class StaticAutoPtr<StorageManager::Factory>;
+
+  static nsresult
+  GetOrCreate(StorageManagerId* aManagerId,
+              StorageManager** aManagerOut)
+  {
+    AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance. This forces the Get() call
+    // below to use the same factory.
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    RefPtr<StorageManager> ref = Get(aManagerId);
+    if (!ref) {
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("BSyncIOThread", getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      ref = new StorageManager(aManagerId, ioThread);
+
+      // There may be an old manager for this origin in the process of
+      // cleaning up.  We need to tell the new manager about this so
+      // that it won't actually start until the old manager is done.
+      RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
+      ref->Init(oldManager);
+
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<StorageManager>
+  Get(StorageManagerId* aManagerId, State aState = Open)
+  {
+    AssertIsOnBackgroundThread();
+
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    // Iterate in reverse to find the most recent, matching Manager. This
+    // is important when looking for a Closing Manager.  If a new Manager
+    // chains to an old Manager we want it to be the most recent one.
+    ManagerList::BackwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      RefPtr<StorageManager> manager = iter.GetNext();
+      if (aState == manager->GetState() && *manager->mManagerId == *aManagerId) {
+        return manager.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void
+  Remove(StorageManager* aManager)
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(sFactory);
+
+    MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
+
+    // Clean up the factory singleton if there are no more managers.
+    MaybeDestroyInstance();
+  }
+
+  static void
+  Abort(const nsACString& aOrigin)
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        if (aOrigin.IsVoid() ||
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
+          manager->Abort();
+        }
+      }
+    }
+  }
+
+  static void
+  ShutdownAll()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      // Note that we are synchronously calling shutdown code here. If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
+    }
+
+    MaybeDestroyInstance();
+  }
+
+  static bool
+  IsShutdownAllComplete()
+  {
+    AssertIsOnBackgroundThread();
+    return !sFactory;
+  }
+
+private:
+  Factory()
+    : mInSyncShutdown(false)
+  {
+    MOZ_COUNT_CTOR(StorageManager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(StorageManager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
+  }
+
+  static nsresult
+  MaybeCreateInstance()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // Be clear about what we are locking. sFactory is bg thread only, so
+      // we don't need to lock it here. Just protect sFactoryShutdown and
+      // sBackgroundThread.
+      {
+        StaticMutexAutoLock lock(sMutex);
+
+        if (sFactoryShutdown) {
+          return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+        }
+      }
+
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread. Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+
+    return NS_OK;
+  }
+
+  static void
+  MaybeDestroyInstance()
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(sFactory);
+
+    // If the factory is still in use then we cannot delete yet. This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down. We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
+    sFactory = nullptr;
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove(). PBackground thread only.
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Protects following static attribute.
+  static StaticMutex sMutex;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sMutex to access.
+  static bool sFactoryShutdown;
+
+  // Weak references as we don't want to keep StorageManager objects alive
+  // forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
+  typedef nsTObserverArray<StorageManager*> ManagerList;
+  ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
+};
+
+// static
+StaticAutoPtr<StorageManager::Factory> StorageManager::Factory::sFactory;
+
+// static
+StaticMutex StorageManager::Factory::sMutex;
+
+// static
+bool StorageManager::Factory::sFactoryShutdown = false;
+
+// ---------------------------------------------------------------------------
+
+// Abstract class to help implement the varios StorageActions.
+class StorageManager::BaseAction : public SyncDBAction
+{
+protected:
+  BaseAction(const nsID& aRequestId, StorageManager* aManager)
+    : SyncDBAction(DBAction::Existing)
+    , mRequestId(aRequestId)
+    , mManager(aManager)
+  {}
+
+  virtual void
+  Complete(nsresult aRv) = 0;
+
+  virtual void
+  CompleteOnInitiatingThread(nsresult aRv) override
+  {
+    NS_ASSERT_OWNINGTHREAD(StorageManager::BaseAction);
+
+    Complete(aRv);
+
+    // Ensure we release the manager on the initiating thread.
+    mManager = nullptr;
+  }
+
+  const nsID mRequestId;
+  RefPtr<StorageManager> mManager;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::RegisterAction final : public StorageManager::BaseAction
+{
+public:
+  RegisterAction(const nsID& aRequestId,
+                 StorageManager* aManager,
+                 const SyncRegisterArgs& aRegisterArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aRegisterArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::Register(aConn, mArgs);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete<SyncOpResponse>(
+        mRequestId,
+        SyncOpError(static_cast<uint32_t>(aRv))
+      );
+    } else {
+      mManager->OnRequestComplete<SyncOpResponse>(
+          mRequestId,
+          SyncRegisterResponse(mArgs.mOrigin())
+      );
+    }
+  }
+
+private:
+  SyncRegisterArgs mArgs;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::GetTagsAction final : public StorageManager::BaseAction
+{
+public:
+  GetTagsAction(const nsID& aRequestId,
+                StorageManager* aManager,
+                const SyncGetTagsArgs& aGetTagsArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aGetTagsArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::GetTags(aConn, mArgs, mTags);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    if (NS_FAILED(aRv)) {
+      mManager->OnRequestComplete<SyncOpResponse>(
+        mRequestId,
+        SyncOpError(static_cast<uint32_t>(aRv))
+      );
+    } else {
+      mManager->OnRequestComplete<SyncOpResponse>(
+          mRequestId,
+          SyncGetTagsResponse(mTags)
+      );
+    }
+  }
+
+private:
+  SyncGetTagsArgs mArgs;
+  nsTArray<nsString> mTags;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::GetAllAction final : public StorageManager::BaseAction
+{
+public:
+  GetAllAction(const nsID& aRequestId,
+               StorageManager* aManager)
+    : BaseAction(aRequestId, aManager)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::GetAll(aConn, mRegistrations);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete<SyncOpResponse>(
+        mRequestId,
+        SyncGetAllResponse(mRegistrations)
+    );
+  }
+
+private:
+  nsTArray<Registration> mRegistrations;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::RemoveAction final : public StorageManager::BaseAction
+{
+public:
+  RemoveAction(const nsID& aRequestId,
+               StorageManager* aManager,
+               const SyncRemoveArgs& aRemoveArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aRemoveArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::Remove(aConn, mArgs);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete<SyncOpResponse>(
+        mRequestId,
+        SyncOpResponse(void_t())
+    );
+  }
+
+private:
+  SyncRemoveArgs mArgs;
+};
+
+// ---------------------------------------------------------------------------
+
+class StorageManager::ChangeStateAction final : public StorageManager::BaseAction
+{
+public:
+  ChangeStateAction(const nsID& aRequestId,
+                   StorageManager* aManager,
+                   const SyncChangeStateArgs& aChangeStateArgs)
+    : BaseAction(aRequestId, aManager)
+    , mArgs(aChangeStateArgs)
+  {}
+
+  virtual nsresult
+  RunSyncOnTarget(const QuotaInfo& aQuotaInfo,
+                  mozIStorageConnection* aConn) override
+  {
+    nsresult rv = db::ChangeState(aConn, mArgs);
+    NS_WARN_IF(NS_FAILED(rv));
+    return rv;
+  }
+
+  virtual void
+  Complete(nsresult aRv) override
+  {
+    NS_WARN_IF(NS_FAILED(aRv));
+    // We need to remove the reference to the request independently of
+    // its result so we can close the context.
+    mManager->OnRequestComplete<SyncOpResponse>(
+        mRequestId,
+        SyncOpResponse(void_t())
+    );
+  }
+
+private:
+  SyncChangeStateArgs mArgs;
+};
+
+// ---------------------------------------------------------------------------
+
+// static
+nsresult
+StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+                            StorageManager** aManagerOut)
+{
+  AssertIsOnBackgroundThread();
+  return Factory::GetOrCreate(aManagerId, aManagerOut);
+}
+
+// static
+void
+StorageManager::ShutdownAll()
+{
+  mozilla::ipc::AssertIsOnBackgroundThread();
+
+  Factory::ShutdownAll();
+  while (!Factory::IsShutdownAllComplete()) {
+    if (!NS_ProcessNextEvent()) {
+      NS_WARNING("Something bad happened!");
+      break;
+    }
+  }
+}
+
+// static
+void
+StorageManager::Abort(const nsACString& aOrigin)
+{
+ mozilla::ipc::AssertIsOnBackgroundThread();
+
+ Factory::Abort(aOrigin);
+}
+
+StorageManager::StorageManager(StorageManagerId* aManagerId,
+                               nsIThread* aIOThread)
+  : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
+  , mContext(nullptr)
+  , mShuttingDown(false)
+  , mState(Open)
+{
+  MOZ_ASSERT(mManagerId);
+  MOZ_ASSERT(mIOThread);
+}
+
+StorageManager::~StorageManager()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mState == Closing);
+  MOZ_ASSERT(!mContext);
+
+/*  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+
+  // Don't spin the event loop in the destructor waiting for the thread to
+  // shutdown. Defer this to the main thread, instead.
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
+}
+
+void
+StorageManager::Init(StorageManager* aOldManager)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  RefPtr<StorageContext> oldContext;
+  if (aOldManager) {
+    oldContext = aOldManager->mContext;
+  }
+
+  // Create the context immediately. Since there can at most be one
+  // StorageContext per StorageManager, this lets us cleanly call
+  // Factory::Remove() once the StorageContext goes away.
+  RefPtr<StorageAction> setupAction = new SetupAction();
+  RefPtr<StorageContext> ref = StorageContext::Create(this, mIOThread,
+                                                      setupAction, oldContext);
+  mContext = ref;
+}
+
+void
+StorageManager::Abort()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+
+  // Note that we are closing to prevent any new requests from coming in and
+  // creating a new StorageContext. We must ensure all Contexts and IO
+  // operations are complete before shutdown proceeds.
+  NoteClosing();
+
+  // Cancel and only note that we are done after the context is cleaned up.
+  RefPtr<StorageContext> context = mContext;
+  context->CancelAll();
+}
+
+void
+StorageManager::Shutdown()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  // Ignore duplicate attempts to shutdown. This can occur when we start a
+  // browser initiated shutdown and then run ~StorageManager() which also
+  // calls Shutdown().
+  if (mShuttingDown) {
+    return;
+  }
+
+  mShuttingDown = true;
+
+  // Note that we are closing to prevent any new requests from coming in and
+  // creating a new StorageContext. We must ensure all Contexts and IO
+  // operations are complete before shutdown proceeds.
+  NoteClosing();
+
+  // If there is a context, then cancel and only note that we are done after
+  // its cleaned up.
+  if (mContext) {
+    RefPtr<StorageContext> context = mContext;
+    context->CancelAll();
+  }
+}
+
+void
+StorageManager::NoteClosing()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+
+  // This can be called more than once legitimately through different paths.
+  mState = Closing;
+}
+
+void
+StorageManager::RemoveStorageContext(StorageContext* aContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(mContext == aContext);
+
+  // Wether the StorageContext destruction was triggered from the StorageManager
+  // going idle or the underlying storage being invalidated, we should know we
+  // are closing before the StorageContext is destroyed.
+  MOZ_ASSERT(mState == Closing);
+
+  mContext = nullptr;
+
+  // Once the context is gone, we can immediately remove ourself from the
+  // Factory list. We don't need to block shutdown by stayin in the list
+  // any more.
+  Factory::Remove(this);
+}
+
+void
+StorageManager::MaybeAllowContextToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  // If we have an active context, but we have no more pending requests,
+  // then let it shut itself down. We must wait for all possible users
+  // of state information to complete before doing this.
+  RefPtr<StorageContext> context = mContext;
+  if (context && mPendingRequests.IsEmpty()) {
+    // Mark the StorageManager as invalid so that it won't get used again.
+    NoteClosing();
+
+    context->AllowToClose();
+  }
+}
+
+// Common to DOM and internal requests.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, StorageAction* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mContext);
+  MOZ_ASSERT(aAction);
+
+  mPendingRequests.AppendElement(aRequestId);
+
+  if (NS_WARN_IF(mState == Closing)) {
+    OnRequestComplete(aRequestId,
+                      SyncOpError(static_cast<uint32_t>(NS_ERROR_ABORT)));
+    return;
+  }
+
+  RefPtr<StorageContext> context = mContext;
+  MOZ_ASSERT(!context->IsCanceled());
+
+  context->Dispatch(aAction);
+}
+
+// DOM request.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp)
+{
+  RefPtr<StorageAction> action;
+
+  switch(aOp.mArgs().type()) {
+    case SyncOpArgs::TSyncRegisterArgs:
+    {
+      action = new RegisterAction(aRequestId, this,
+                                  aOp.mArgs().get_SyncRegisterArgs());
+      break;
+    }
+    case SyncOpArgs::TSyncGetTagsArgs:
+    {
+      action = new GetTagsAction(aRequestId, this,
+                                 aOp.mArgs().get_SyncGetTagsArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync request");
+    }
+  }
+
+  ExecuteRequest(aRequestId, action);
+}
+
+// Internal request.
+void
+StorageManager::ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp)
+{
+  RefPtr<StorageAction> action;
+
+  switch(aOp.mArgs().type()) {
+    case SyncInternalOpArgs::TSyncGetAllArgs:
+    {
+      action = new GetAllAction(aRequestId, this);
+      break;
+    }
+    case SyncInternalOpArgs::TSyncChangeStateArgs:
+    {
+      action = new ChangeStateAction(aRequestId, this,
+                                     aOp.mArgs().get_SyncChangeStateArgs());
+      break;
+    }
+    case SyncInternalOpArgs::TSyncRemoveArgs:
+    {
+      action = new RemoveAction(aRequestId, this,
+                                aOp.mArgs().get_SyncRemoveArgs());
+      break;
+    }
+    default:
+    {
+      MOZ_CRASH("Unknown BackgroundSync internal request");
+    }
+  }
+
+  ExecuteRequest(aRequestId, action);
+}
+
+// Common to DOM and internal responses.
+void
+StorageManager::OnRequestComplete(const nsID& aRequestId)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageManager);
+  MOZ_ASSERT(mPendingRequests.Contains(aRequestId));
+
+  mPendingRequests.RemoveElement(aRequestId);
+
+  MaybeAllowContextToClose();
+}
+
+template<typename T>
+void
+StorageManager::OnRequestComplete(const nsID& aRequestId, const T& aResponse)
+{
+  // XXX Notify listener
+
+  OnRequestComplete(aRequestId);
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.h
@@ -0,0 +1,117 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManager_h
+#define mozilla_dom_StorageManager_h
+
+#include "StorageContext.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+/**
+ * The StorageManager class is responsible for managing the storage of sync
+ * requests. The DOM objects and IPC actors are basically just plumbing to
+ * get the request to the right StorageManager object running in the parent
+ * process.
+ *
+ * There should be exactly one StorageManager object for each origin or app
+ * using the BackgroundSync API. This uniqueness is defined by the
+ * StorageManagerId equality operator. The uniqueness is enforced by the
+ * Manager GetOrCreate() factory method.
+ *
+ * The StorageManager instances are kept alive by the BackgroundSyncService,
+ * which keeps a reference to the StorageManager dealing with a storage request
+ * until that request is completed or the actor requesting it is destroyed.
+ */
+
+class StorageManager final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageManager)
+
+  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+                              StorageManager** aManagerOut);
+
+  enum State
+  {
+    Open,
+    Closing
+  };
+
+  State GetState() const
+  {
+    return mState;
+  }
+
+  already_AddRefed<StorageManagerId> GetManagerId() const
+  {
+    RefPtr<StorageManagerId> ref = mManagerId;
+    return ref.forget();
+  }
+
+  // Synchronously shutdown.  This spins the event loop.
+  static void ShutdownAll();
+
+  // Cancel actions for given origin or all actions if passed string is null.
+  static void Abort(const nsACString& aOrigin);
+
+  // Must be called by StorageContext objects before they are destroyed.
+  void RemoveStorageContext(StorageContext* aContext);
+
+  // Marks the StorageManager "invalid". Once the StorageContext completes
+  // no new operations will be permitted with this StorageManager.
+  // New actors will get a new StorageManager.
+  void NoteClosing();
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+private:
+  class BaseAction;
+  class ChangeStateAction;
+  class Factory;
+  class GetAllAction;
+  class GetTagsAction;
+  class RegisterAction;
+  class RemoveAction;
+
+  StorageManager(StorageManagerId* aManagerId,
+                 nsIThread* aIOThread);
+  ~StorageManager();
+
+  void Init(StorageManager* aOldManager);
+  void Abort();
+  void Shutdown();
+
+  void MaybeAllowContextToClose();
+
+  void OnRequestComplete(const nsID& aRequestId);
+  template<typename T>
+  void OnRequestComplete(const nsID& aRequestId, const T& aResponse);
+
+  void ExecuteRequest(const nsID& aRequestId, StorageAction* aAction);
+  void ExecuteRequest(const nsID& aRequestId, const SyncInternalOp& aOp);
+
+  RefPtr<StorageManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+
+  // Weak reference cleared by RemoveStorageContext() in StorageContext
+  // destructor.
+  StorageContext* MOZ_NON_OWNING_REF mContext;
+
+  bool mShuttingDown;
+  State mState;
+
+  // Keep a list of the request IDs coming from BackgroundSyncService.
+  nsTArray<nsID> mPendingRequests;
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManager_h
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -0,0 +1,175 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManagerId.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+/**
+ * StorageManagerIdFactory
+ */
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManagerIdFactory> factory =
+    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(factory));
+
+  return factory.forget();
+}
+
+StorageManagerIdFactory::StorageManagerIdFactory(
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+  : mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(aListener);
+
+  mListenerList.AppendElement(aListener);
+}
+
+StorageManagerIdFactory::~StorageManagerIdFactory()
+{
+  // Since this is a Runnable that executes on multiple threads, its a race
+  // to see which thread de-refs us last. Therefore we cannot guarantee which
+  // thread we destruct on.
+
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+NS_IMETHODIMP
+StorageManagerIdFactory::Run()
+{
+  // Execute twice. First on the main thread and the back on the originating
+  // thread.
+
+  if (mManagerId) {
+    AssertIsOnBackgroundThread();
+
+    ListenerList::ForwardIterator iter(mListenerList);
+    while (iter.HasMore()) {
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+    }
+
+    // The listener must clear its reference in
+    // OnStorageManagerIdCreated().
+    MOZ_ASSERT(mListenerList.IsEmpty());
+
+    return NS_OK;
+  }
+
+  AssertIsOnMainThread();
+
+  nsresult rv;
+  RefPtr<nsIPrincipal> principal =
+    PrincipalInfoToPrincipal(mPrincipalInfo, &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  rv = StorageManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(this, NS_DISPATCH_NORMAL));
+
+  return NS_OK;
+}
+
+void
+StorageManagerIdFactory::AddListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+}
+
+void
+StorageManagerIdFactory::RemoveListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+
+  MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
+}
+
+/**
+ * StorageManagerId
+ */
+
+// static
+nsresult
+StorageManagerId::Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<StorageManagerId> ref =
+    new StorageManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+StorageManagerId::StorageManagerId(nsIPrincipal* aPrincipal,
+                                   const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+StorageManagerId::~StorageManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -0,0 +1,94 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManagerId_h
+#define mozilla_dom_StorageManagerId_h
+
+namespace mozilla {
+namespace dom {
+namespace backgroundsync {
+
+using mozilla::ipc::PrincipalInfo;
+
+class StorageManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const StorageManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  StorageManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~StorageManagerId();
+
+  StorageManagerId(const StorageManagerId&) = delete;
+  StorageManagerId& operator=(const StorageManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerId)
+};
+
+class StorageManagerIdFactory : public Runnable
+{
+public:
+  // An interface to be implemented by code wishing to use the
+  // StorageManagerIdFactory.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the StorageManagerIdFactory to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+  };
+
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
+
+  void AddListener(Listener* aListener);
+  // The Listener must call RemoveListener() when
+  // OnStorageManagerIdCreated is called or when
+  // the Listener is destroyed.
+  void RemoveListener(Listener* aListener);
+
+private:
+  StorageManagerIdFactory(Listener* aListener,
+                          const PrincipalInfo& aPrincipalInfo);
+  virtual ~StorageManagerIdFactory();
+
+  // Weak reference cleared by RemoveListener().
+  typedef nsTObserverArray<Listener*> ListenerList;
+  ListenerList mListenerList;
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<StorageManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namespace backgroundsync
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManagerId_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -1,21 +1,34 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXPORTS.mozilla.dom.backgroundsync += [
-    'BackgroundSync.h'
+    'BackgroundSync.h',
+    'BackgroundSyncTypes.h',
+    'QuotaClient.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
-    'BackgroundSyncParent.cpp'
+    'BackgroundSyncParent.cpp',
+    'ChromeDBSchema.cpp',
+    'ChromeStorageManager.cpp',
+    'DBAction.cpp',
+    'DBConnection.cpp',
+    'DBSchema.cpp',
+    'DBSchemaUtils.cpp',
+    'QuotaClient.cpp',
+    'StorageAction.cpp',
+    'StorageContext.cpp',
+    'StorageManager.cpp',
+    'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/dom/quota/ActorsParent.cpp b/dom/quota/ActorsParent.cpp
--- a/dom/quota/ActorsParent.cpp
+++ b/dom/quota/ActorsParent.cpp
@@ -23,16 +23,17 @@
 
 #include <algorithm>
 #include "GeckoProfiler.h"
 #include "mozilla/Atomics.h"
 #include "mozilla/BasePrincipal.h"
 #include "mozilla/CondVar.h"
 #include "mozilla/dom/PContent.h"
 #include "mozilla/dom/asmjscache/AsmJSCache.h"
+#include "mozilla/dom/backgroundsync/QuotaClient.h"
 #include "mozilla/dom/cache/QuotaClient.h"
 #include "mozilla/dom/indexedDB/ActorsParent.h"
 #include "mozilla/dom/quota/PQuotaParent.h"
 #include "mozilla/dom/quota/PQuotaRequestParent.h"
 #include "mozilla/dom/quota/PQuotaUsageRequestParent.h"
 #include "mozilla/ipc/BackgroundParent.h"
 #include "mozilla/ipc/BackgroundUtils.h"
 #include "mozilla/IntegerRange.h"
@@ -3035,25 +3036,27 @@ QuotaManager::Init(const nsAString& aBas
   // Make a timer here to avoid potential failures later. We don't actually
   // initialize the timer until shutdown.
   mShutdownTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
   if (NS_WARN_IF(!mShutdownTimer)) {
     return NS_ERROR_FAILURE;
   }
 
   static_assert(Client::IDB == 0 && Client::ASMJS == 1 && Client::DOMCACHE == 2 &&
-                Client::TYPE_MAX == 3, "Fix the registration!");
+                Client::BACKGROUNDSYNC == 3 && Client::TYPE_MAX == 4,
+                "Fix the registration!");
 
   MOZ_ASSERT(mClients.Capacity() == Client::TYPE_MAX,
              "Should be using an auto array with correct capacity!");
 
   // Register clients.
   mClients.AppendElement(indexedDB::CreateQuotaClient());
   mClients.AppendElement(asmjscache::CreateClient());
   mClients.AppendElement(cache::CreateQuotaClient());
+  mClients.AppendElement(backgroundsync::CreateQuotaClient());
 
   return NS_OK;
 }
 
 void
 QuotaManager::Shutdown()
 {
   AssertIsOnOwningThread();
diff --git a/dom/quota/Client.h b/dom/quota/Client.h
--- a/dom/quota/Client.h
+++ b/dom/quota/Client.h
@@ -13,16 +13,17 @@
 
 #include "PersistenceType.h"
 
 class nsIRunnable;
 
 #define IDB_DIRECTORY_NAME "idb"
 #define ASMJSCACHE_DIRECTORY_NAME "asmjs"
 #define DOMCACHE_DIRECTORY_NAME "cache"
+#define BACKGROUNDSYNC_DIRECTORY_NAME "backgroundsync"
 
 BEGIN_QUOTA_NAMESPACE
 
 class UsageInfo;
 
 // An abstract interface for quota manager clients.
 // Each storage API must provide an implementation of this interface in order
 // to participate in centralized quota and storage handling.
@@ -36,16 +37,17 @@ public:
   Release() = 0;
 
   enum Type {
     IDB = 0,
     //LS,
     //APPCACHE,
     ASMJS,
     DOMCACHE,
+    BACKGROUNDSYNC,
     TYPE_MAX
   };
 
   virtual Type
   GetType() = 0;
 
   static nsresult
   TypeToText(Type aType, nsAString& aText)
@@ -58,16 +60,20 @@ public:
       case ASMJS:
         aText.AssignLiteral(ASMJSCACHE_DIRECTORY_NAME);
         break;
 
       case DOMCACHE:
         aText.AssignLiteral(DOMCACHE_DIRECTORY_NAME);
         break;
 
+      case BACKGROUNDSYNC:
+        aText.AssignLiteral(BACKGROUNDSYNC_DIRECTORY_NAME);
+        break;
+
       case TYPE_MAX:
       default:
         NS_NOTREACHED("Bad id value!");
         return NS_ERROR_UNEXPECTED;
     }
 
     return NS_OK;
   }
@@ -79,16 +85,19 @@ public:
       aType = IDB;
     }
     else if (aText.EqualsLiteral(ASMJSCACHE_DIRECTORY_NAME)) {
       aType = ASMJS;
     }
     else if (aText.EqualsLiteral(DOMCACHE_DIRECTORY_NAME)) {
       aType = DOMCACHE;
     }
+    else if (aText.EqualsLiteral(BACKGROUNDSYNC_DIRECTORY_NAME)) {
+      aType = BACKGROUNDSYNC;
+    }
     else {
       return NS_ERROR_FAILURE;
     }
 
     return NS_OK;
   }
 
   // Methods which are called on the IO thred.
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -469,18 +469,19 @@ BackgroundChildImpl::DeallocPFileSystemR
     dont_AddRef(static_cast<dom::FileSystemTaskChildBase*>(aActor));
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
-dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+dom::backgroundsync::PBackgroundSyncChild*
+BackgroundChildImpl::AllocPBackgroundSyncChild(
+    const PrincipalInfo& aPrincipalInfo)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -161,17 +161,17 @@ protected:
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -888,33 +888,39 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
-mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+mozilla::dom::backgroundsync::PBackgroundSyncParent*
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  RefPtr<BackgroundSyncParent> agent =
+    new BackgroundSyncParent(aPrincipalInfo);
+  return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundSyncParent*>(aActor);
+  RefPtr<BackgroundSyncParent> parent =
+    dont_AddRef(static_cast<BackgroundSyncParent*>(aActor));
+  MOZ_ASSERT(parent);
+
   return true;
 }
 
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -193,17 +193,17 @@ protected:
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/IPCMessageUtils.h b/ipc/glue/IPCMessageUtils.h
--- a/ipc/glue/IPCMessageUtils.h
+++ b/ipc/glue/IPCMessageUtils.h
@@ -8,16 +8,17 @@
 #define __IPC_GLUE_IPCMESSAGEUTILS_H__
 
 #include "base/process_util.h"
 #include "chrome/common/ipc_message_utils.h"
 
 #include "mozilla/ArrayUtils.h"
 #include "mozilla/Attributes.h"
 #include "mozilla/DebugOnly.h"
+#include "mozilla/dom/backgroundsync/BackgroundSyncTypes.h"
 #include "mozilla/dom/ipc/StructuredCloneData.h"
 #include "mozilla/Maybe.h"
 #include "mozilla/net/WebSocketFrame.h"
 #include "mozilla/TimeStamp.h"
 #ifdef XP_WIN
 #include "mozilla/TimeStamp_windows.h"
 #endif
 #include "mozilla/TypeTraits.h"
@@ -806,11 +807,20 @@ struct ParamTraits<mozilla::Maybe<T>>
       *result = mozilla::Some(mozilla::Move(tmp));
     } else {
       *result = mozilla::Nothing();
     }
     return true;
   }
 };
 
+using namespace mozilla::dom::backgroundsync;
+
+template <>
+struct ParamTraits<RegistrationState>
+  : public ContiguousEnumSerializer<RegistrationState,
+                                    RegistrationState::PENDING,
+                                    RegistrationState::REREGISTERING_WHILE_FIRING>
+{ };
+
 } /* namespace IPC */
 
 #endif /* __IPC_GLUE_IPCMESSAGEUTILS_H__ */
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -97,17 +97,17 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
