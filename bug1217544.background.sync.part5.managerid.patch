# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  53ec980e00e03d6609707c8413b71deca4125745
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: StorageManager and StorageContext. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -334,17 +334,18 @@ BackgroundSync::ActorCreated(PBackground
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
   if (mShuttingDown) {
     return;
   }
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -12,17 +12,17 @@
 #include "mozilla/dom/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
 {
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -10,33 +10,65 @@
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class BackgroundSyncParent::PendingRequest final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(PendingRequest)
+
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID RequestId()
+  {
+    return mRequestId;
+  }
+
+  SyncOp Op()
+  {
+    return mOp;
+  }
+private:
+  ~PendingRequest() {}
+
+  nsID mRequestId;
+  SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  mStorageManagerIdFactory =
+    StorageManagerIdFactory::Create(this, aPrincipalInfo);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       // XXX Do registration.
       const SyncRegisterResponse response(true);
@@ -52,22 +84,60 @@ bool BackgroundSyncParent::RecvRequest(c
       Unused << SendResponse(aRequestId, response);
       break;
     }
     default:
     {
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a StorageManagerId for this parent yet, we
+  // queue the request.
+  if (!mStorageManagerId) {
+    RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
+    mPendingRequests.AppendElement(pendingRequest);
+    return true;
+  }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
+void
+BackgroundSyncParent::OnStorageManagerIdCreated(
+    StorageManagerId* aManagerId)
+{
+  MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(!mStorageManagerId);
+
+  mStorageManagerId = aManagerId;
+  mStorageManagerIdFactory->RemoveListener(this);
+  mStorageManagerIdFactory = nullptr;
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+    MOZ_ASSERT(mPendingRequests[i]);
+    ExecuteRequest(mPendingRequests[i]->RequestId(),
+                   mPendingRequests[i]->Op());
+  }
+  mPendingRequests.Clear();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,43 +2,62 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
+#include "StorageManagerId.h"
+
 #include "mozilla/dom/PBackgroundSyncParent.h"
 #include "mozilla/dom/BackgroundSyncIPCTypes.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundParentImpl;
+  class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
+                                 , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 private:
-  BackgroundSyncParent();
+  BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // StorageManagerId method
+  virtual void
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+
+  RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
+  // We use this Id to ensure that we have a single StorageManager
+  // per principal.
+  RefPtr<StorageManagerId> mStorageManagerId;
+
+  class PendingRequest;
+  nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
-
-
diff --git a/dom/backgroundsync/BackgroundSyncTypes.h b/dom/backgroundsync/BackgroundSyncTypes.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncTypes.h
@@ -0,0 +1,33 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncTypes_h
+#define mozilla_dom_BackgroundSyncTypes_h
+
+#include <stdint.h>
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "nsString.h"
+
+namespace mozilla {
+namespace dom {
+
+typedef int64_t StorageId;
+static const StorageId INVALID_STORAGE_ID = -1;
+
+struct QuotaInfo
+{
+  QuotaInfo() : mIsApp(false) { }
+  nsCOMPtr<nsIFile> mDir;
+  nsCString mGroup;
+  nsCString mOrigin;
+  bool mIsApp;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncTypes_h
diff --git a/dom/backgroundsync/StorageAction.cpp b/dom/backgroundsync/StorageAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.cpp
@@ -0,0 +1,38 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageAction.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+StorageAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual BackgroundSync could have its StorageActions canceled
+  // and then shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+StorageAction::StorageAction()
+  : mCanceled(false)
+{
+}
+
+StorageAction::~StorageAction()
+{
+}
+
+bool
+StorageAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageAction.h b/dom/backgroundsync/StorageAction.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.h
@@ -0,0 +1,106 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageAction_h
+#define mozilla_dom_StorageAction_h
+
+#include "BackgroundSyncTypes.h"
+
+#include "mozilla/Atomics.h"
+#include "nsISupportsImpl.h"
+
+class mozIStorageConnection;
+
+namespace mozilla {
+namespace dom {
+
+class StorageAction
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageAction)
+
+  class Resolver
+  {
+  public:
+    // Note: StorageAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       StorageAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple StorageActions running on the same thread/StorageContext.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread.  Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: StorageAction should hold Resolver ref until its ready to call
+  //        Resolve().
+  // Note: The "target" thread is determined when the StorageAction is scheduled
+  //       on StorageContext. The StorageAction should not assume any particular
+  //       thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the StorageAction is canceled.
+  // The StorageAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT. If
+  // CancelOnInitiatingThread() is called after Resolve() has already occurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the StorageAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent
+  // calls should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread. If this StorageAction will operate on
+  // the given storage ID then override this to return true.
+  virtual bool MatchesStorageId(StorageId aId) const {
+    return false;
+  }
+
+protected:
+  StorageAction();
+
+  // virtual because deleted through base class pointer
+  virtual ~StorageAction();
+
+  // Check if this StorageAction has been canceled.
+  // May be called from any thread, but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageAction_h
diff --git a/dom/backgroundsync/StorageContext.cpp b/dom/backgroundsync/StorageContext.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageContext.cpp
@@ -0,0 +1,1140 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageAction.h"
+#include "StorageContext.h"
+#include "StorageManager.h"
+#include "StorageManagerId.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/DebugOnly.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozIStorageConnection.h"
+#include "nsIFile.h"
+#include "nsIPrincipal.h"
+#include "nsIRunnable.h"
+#include "nsThreadUtils.h"
+
+namespace {
+
+using mozilla::dom::StorageAction;
+using mozilla::dom::QuotaInfo;
+
+class NullAction final : public StorageAction
+{
+public:
+  NullAction()
+  {
+  }
+
+  virtual void
+  RunOnTarget(Resolver* aResolver, const QuotaInfo&, Data*) override
+  {
+    // Resolve success immediately. This Action does no actual work.
+    MOZ_ASSERT(aResolver);
+    aResolver->Resolve(NS_OK);
+  }
+};
+
+} // namespace
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::DebugOnly;
+using mozilla::dom::quota::AssertIsOnIOThread;
+using mozilla::dom::quota::OpenDirectoryListener;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::dom::quota::PERSISTENCE_TYPE_DEFAULT;
+using mozilla::dom::quota::PersistenceType;
+
+class StorageContext::Data final : public StorageAction::Data
+{
+public:
+  explicit Data(nsIThread* aTarget)
+    : mTarget(aTarget)
+  {
+    MOZ_ASSERT(mTarget);
+  }
+
+  virtual mozIStorageConnection*
+  GetConnection() const override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    return mConnection;
+  }
+
+  virtual void
+  SetConnection(mozIStorageConnection* aConn) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(!mConnection);
+    mConnection = aConn;
+    MOZ_ASSERT(mConnection);
+  }
+
+private:
+  ~Data()
+  {
+    // We could proxy release our data here, but instead just assert. The
+    // StorageContext code should guarantee that we are destroyed on the target
+    // thread once the connection is initialized. If we're not, then
+    // QuotaManager might race and try to clear the origin out from under us.
+    MOZ_ASSERT_IF(mConnection, mTarget == NS_GetCurrentThread());
+  }
+
+  nsCOMPtr<nsIThread> mTarget;
+  nsCOMPtr<mozIStorageConnection> mConnection;
+
+  // Threadsafe counting because we're created on the PBackground thread
+  // and destroyed on the target IO thread.
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageContext::Data)
+};
+
+// Executed to perform the complicated dance of steps necessary to initialize
+// the QuotaManager.This must be performed for each origin before any disk
+// IO occurrs.
+class StorageContext::QuotaInitRunnable final : public nsIRunnable
+                                              , public OpenDirectoryListener
+{
+public:
+  QuotaInitRunnable(StorageContext* aContext,
+                    StorageManager* aManager,
+                    Data* aData,
+                    nsIThread* aTarget,
+                    StorageAction* aInitAction)
+    : mContext(aContext)
+    , mThreadsafeHandle(aContext->CreateThreadsafeHandle())
+    , mManager(aManager)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mInitAction(aInitAction)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mResult(NS_OK)
+    , mState(STATE_INIT)
+    , mCanceled(false)
+  {
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mManager);
+    MOZ_ASSERT(mData);
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mInitiatingThread);
+    MOZ_ASSERT(mInitAction);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_GET_INFO;
+    nsresult rv = NS_DispatchToMainThread(this, nsIThread::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  void Cancel()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(!mCanceled);
+    mCanceled = true;
+    mInitAction->CancelOnInitiatingThread();
+  }
+
+  void OpenDirectory();
+
+  // OpenDirectoryListener methods
+  virtual void
+  DirectoryLockAcquired(quota::DirectoryLock* aLock) override;
+
+  virtual void
+  DirectoryLockFailed() override;
+
+private:
+  class SyncResolver final : public StorageAction::Resolver
+  {
+  public:
+    SyncResolver()
+      : mResolved(false)
+      , mResult(NS_OK)
+    { }
+
+    virtual void
+    Resolve(nsresult aRv) override
+    {
+      MOZ_ASSERT(!mResolved);
+      mResolved = true;
+      mResult = aRv;
+    };
+
+    bool Resolved() const { return mResolved; }
+    nsresult Result() const { return mResult; }
+
+  private:
+    ~SyncResolver() { }
+
+    bool mResolved;
+    nsresult mResult;
+
+    NS_INLINE_DECL_REFCOUNTING(StorageContext::QuotaInitRunnable::SyncResolver,
+                               override)
+  };
+
+  ~QuotaInitRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mInitAction);
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_GET_INFO,
+    STATE_CREATE_QUOTA_MANAGER,
+    STATE_OPEN_DIRECTORY,
+    STATE_WAIT_FOR_DIRECTORY_LOCK,
+    STATE_ENSURE_ORIGIN_INITIALIZED,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  void Complete(nsresult aResult)
+  {
+    MOZ_ASSERT(mState == STATE_RUNNING || NS_FAILED(aResult));
+
+    MOZ_ASSERT(NS_SUCCEEDED(mResult));
+    mResult = aResult;
+
+    mState = STATE_COMPLETING;
+    MOZ_ALWAYS_SUCCEEDS(
+      mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+    MOZ_ASSERT(mContext);
+    mContext = nullptr;
+    mManager = nullptr;
+    mInitAction = nullptr;
+  }
+
+  RefPtr<StorageContext> mContext;
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+  RefPtr<StorageManager> mManager;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<StorageAction> mInitAction;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  nsresult mResult;
+  QuotaInfo mQuotaInfo;
+  RefPtr<quota::DirectoryLock> mDirectoryLock;
+  State mState;
+  Atomic<bool> mCanceled;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+void
+StorageContext::QuotaInitRunnable::OpenDirectory()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_CREATE_QUOTA_MANAGER ||
+             mState == STATE_OPEN_DIRECTORY);
+  MOZ_ASSERT(QuotaManager::Get());
+
+  // QuotaManager::OpenDirectory() will hold a reference to us as
+  // a listener. We will then get DirectoryLockAcquired() on the owning
+  // thread when it is safe to access our storage directory.
+  mState = STATE_WAIT_FOR_DIRECTORY_LOCK;
+  QuotaManager::Get()->OpenDirectory(PERSISTENCE_TYPE_DEFAULT,
+                                     mQuotaInfo.mGroup,
+                                     mQuotaInfo.mOrigin,
+                                     mQuotaInfo.mIsApp,
+                                     quota::Client::DOMCACHE,
+                                     /* aExclusive */ false,
+                                     this);
+}
+
+void
+StorageContext::QuotaInitRunnable::DirectoryLockAcquired(
+    quota::DirectoryLock* aLock)
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  mDirectoryLock = aLock;
+
+  if (mCanceled) {
+    Complete(NS_ERROR_ABORT);
+    return;
+  }
+
+  QuotaManager* qm = QuotaManager::Get();
+  MOZ_ASSERT(qm);
+
+  mState = STATE_ENSURE_ORIGIN_INITIALIZED;
+  nsresult rv = qm->IOThread()->Dispatch(this, nsIThread::DISPATCH_NORMAL);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    Complete(rv);
+    return;
+  }
+}
+
+void
+StorageContext::QuotaInitRunnable::DirectoryLockFailed()
+{
+  NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+  MOZ_ASSERT(mState == STATE_WAIT_FOR_DIRECTORY_LOCK);
+  MOZ_ASSERT(!mDirectoryLock);
+
+  NS_WARNING("Failed to acquire a directory lock!");
+
+  Complete(NS_ERROR_FAILURE);
+}
+
+NS_IMPL_ISUPPORTS(StorageContext::QuotaInitRunnable, nsIRunnable);
+
+// The QuotaManager init state machine is represented in the following diagram:
+//
+//    +---------------+
+//    |     Start     |      Resolve(error)
+//    | (Orig Thread) +---------------------+
+//    +-------+-------+                     |
+//            |                             |
+// +----------v-----------+                 |
+// |       GetInfo        |  Resolve(error) |
+// |    (Main Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |  CreateQuotaManager  |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// |    OpenDirectory     |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v-----------+                 |
+// | WaitForDirectoryLock |  Resolve(error) |
+// |    (Orig Thread)     +-----------------+
+// +----------+-----------+                 |
+//            |                             |
+// +----------v------------+                |
+// |EnsureOriginInitialized| Resolve(error) |
+// |   (Quota IO Thread)   +----------------+
+// +----------+------------+                |
+//            |                             |
+// +----------v------------+                |
+// |     RunOnTarget       | Resolve(error) |
+// |   (Target Thread)     +----------------+
+// +----------+------------+                |
+//            |                             |
+//  +---------v---------+            +------v------+
+//  |      Running      |            |  Completing |
+//  | (Target Thread)   +------------>(Orig Thread)|
+//  +-------------------+            +------+------+
+//                                          |
+//                                    +-----v----+
+//                                    | Complete |
+//                                    +----------+
+//
+// The initialization process proceeds through the main states.  If an error
+// occurs, then we transition to Completing state back on the original thread.
+NS_IMETHODIMP
+StorageContext::QuotaInitRunnable::Run()
+{
+  // May run on different threads depending on the state.  See individual
+  // state cases for thread assertions.
+
+  RefPtr<SyncResolver> resolver = new SyncResolver();
+
+  switch(mState) {
+    // -----------------------------------
+    case STATE_GET_INFO:
+    {
+      MOZ_ASSERT(NS_IsMainThread());
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      RefPtr<StorageManagerId> managerId = mManager->GetManagerId();
+      nsCOMPtr<nsIPrincipal> principal = managerId->Principal();
+      nsresult rv = QuotaManager::GetInfoFromPrincipal(principal,
+                                                       &mQuotaInfo.mGroup,
+                                                       &mQuotaInfo.mOrigin,
+                                                       &mQuotaInfo.mIsApp);
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_CREATE_QUOTA_MANAGER;
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // ----------------------------------
+    case STATE_CREATE_QUOTA_MANAGER:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (mCanceled || QuotaManager::IsShuttingDown()) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      if (QuotaManager::Get()) {
+        OpenDirectory();
+        return NS_OK;
+      }
+
+      mState = STATE_OPEN_DIRECTORY;
+      QuotaManager::GetOrCreate(this);
+      break;
+    }
+    // ----------------------------------
+    case STATE_OPEN_DIRECTORY:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+
+      if (NS_WARN_IF(!QuotaManager::Get())) {
+        resolver->Resolve(NS_ERROR_FAILURE);
+        break;
+      }
+
+      OpenDirectory();
+      break;
+    }
+    // ----------------------------------
+    case STATE_ENSURE_ORIGIN_INITIALIZED:
+    {
+      AssertIsOnIOThread();
+
+      if (mCanceled) {
+        resolver->Resolve(NS_ERROR_ABORT);
+        break;
+      }
+
+      QuotaManager* qm = QuotaManager::Get();
+      MOZ_ASSERT(qm);
+      nsresult rv = qm->EnsureOriginIsInitialized(PERSISTENCE_TYPE_DEFAULT,
+                                                  mQuotaInfo.mGroup,
+                                                  mQuotaInfo.mOrigin,
+                                                  mQuotaInfo.mIsApp,
+                                                  getter_AddRefs(mQuotaInfo.mDir));
+      if (NS_FAILED(rv)) {
+        resolver->Resolve(rv);
+        break;
+      }
+
+      mState = STATE_RUN_ON_TARGET;
+
+      MOZ_ALWAYS_SUCCEEDS(
+        mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+
+      mState = STATE_RUNNING;
+
+      // Execute the provided initialization StorageAction. The
+      // StorageAction must Resolve() before returning.
+      mInitAction->RunOnTarget(resolver, mQuotaInfo, mData);
+      MOZ_ASSERT(resolver->Resolved());
+
+      mData = nullptr;
+
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(QuotaInitRunnable);
+      mInitAction->CompleteOnInitiatingThread(mResult);
+      mContext->OnQuotaInit(mResult, mQuotaInfo, mDirectoryLock.forget());
+      mState = STATE_COMPLETE;
+
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----
+    case STATE_WAIT_FOR_DIRECTORY_LOCK:
+    default:
+    {
+      MOZ_CRASH("unexpected state in QuotaInitRunnable");
+    }
+  }
+
+  if (resolver->Resolved()) {
+    Complete(resolver->Result());
+  }
+
+  return NS_OK;
+}
+
+// Runnable wrapper around StorageAction objects dispatched on the StorageContext.
+// This runnable executes the StorageAction on the appropriate threads while the
+// StorageContext is initialized.
+class StorageContext::ActionRunnable final : public nsIRunnable
+                                           , public StorageAction::Resolver
+                                           , public StorageContext::Activity
+{
+public:
+  ActionRunnable(StorageContext* aContext, Data* aData, nsIEventTarget* aTarget,
+                 StorageAction* aAction, const QuotaInfo& aQuotaInfo)
+    : mContext(aContext)
+    , mData(aData)
+    , mTarget(aTarget)
+    , mAction(aAction)
+    , mQuotaInfo(aQuotaInfo)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mState(STATE_INIT)
+    , mResult(NS_OK)
+    , mExecutingRunOnTarget(false)
+  {
+    MOZ_ASSERT(mContext);
+    // mData may be nullptr
+    MOZ_ASSERT(mTarget);
+    MOZ_ASSERT(mAction);
+    // mQuotaInfo.mDir may be nullptr if QuotaInitRunnable failed
+    MOZ_ASSERT(mInitiatingThread);
+  }
+
+  nsresult Dispatch()
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    MOZ_ASSERT(mState == STATE_INIT);
+
+    mState = STATE_RUN_ON_TARGET;
+    nsresult rv = mTarget->Dispatch(this, nsIEventTarget::DISPATCH_NORMAL);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      mState = STATE_COMPLETE;
+      Clear();
+    }
+    return rv;
+  }
+
+  virtual bool
+  MatchesStorageId(StorageId aId) const override
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    return mAction->MatchesStorageId(aId);
+  }
+
+  virtual void
+  Cancel() override
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    mAction->CancelOnInitiatingThread();
+  }
+
+  virtual void Resolve(nsresult aRv) override
+  {
+    MOZ_ASSERT(mTarget == NS_GetCurrentThread());
+    MOZ_ASSERT(mState == STATE_RUNNING);
+
+    mResult = aRv;
+
+    // We ultimately must complete on the initiating thread, but bounce through
+    // the current thread again to ensure that we don't destroy objects and
+    // state out from under the currently running action's stack.
+    mState = STATE_RESOLVING;
+
+    // If we were resolved synchronously within Action::RunOnTarget() then we
+    // can avoid a thread bounce and just resolve once RunOnTarget() returns.
+    // The Run() method will handle this by looking at mState after
+    // RunOnTarget() returns.
+    if (mExecutingRunOnTarget) {
+      return;
+    }
+
+    // Otherwise we are in an asynchronous resolve.  And must perform a thread
+    // bounce to run on the target thread again.
+    MOZ_ALWAYS_SUCCEEDS(
+      mTarget->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+  }
+
+private:
+  ~ActionRunnable()
+  {
+    MOZ_ASSERT(mState == STATE_COMPLETE);
+    MOZ_ASSERT(!mContext);
+    MOZ_ASSERT(!mAction);
+  }
+
+  void Clear()
+  {
+    NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+    MOZ_ASSERT(mContext);
+    MOZ_ASSERT(mAction);
+    mContext->RemoveActivity(this);
+    mContext = nullptr;
+    mAction = nullptr;
+  }
+
+  enum State
+  {
+    STATE_INIT,
+    STATE_RUN_ON_TARGET,
+    STATE_RUNNING,
+    STATE_RESOLVING,
+    STATE_COMPLETING,
+    STATE_COMPLETE
+  };
+
+  RefPtr<StorageContext> mContext;
+  RefPtr<Data> mData;
+  nsCOMPtr<nsIEventTarget> mTarget;
+  RefPtr<StorageAction> mAction;
+  const QuotaInfo mQuotaInfo;
+  nsCOMPtr<nsIThread> mInitiatingThread;
+  State mState;
+  nsresult mResult;
+
+  // Only accessible on target thread;
+  bool mExecutingRunOnTarget;
+
+public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+  NS_DECL_NSIRUNNABLE
+};
+
+NS_IMPL_ISUPPORTS(StorageContext::ActionRunnable, nsIRunnable);
+
+// The ActionRunnable has a simpler state machine.  It basically needs to run
+// the action on the target thread and then complete on the original thread.
+//
+//   +-------------+
+//   |    Start    |
+//   |(Orig Thread)|
+//   +-----+-------+
+//         |
+// +-------v---------+
+// |  RunOnTarget    |
+// |Target IO Thread)+---+ Resolve()
+// +-------+---------+   |
+//         |             |
+// +-------v----------+  |
+// |     Running      |  |
+// |(Target IO Thread)|  |
+// +------------------+  |
+//         | Resolve()   |
+// +-------v----------+  |
+// |     Resolving    <--+                   +-------------+
+// |                  |                      |  Completing |
+// |(Target IO Thread)+---------------------->(Orig Thread)|
+// +------------------+                      +-------+-----+
+//                                                   |
+//                                                   |
+//                                              +----v---+
+//                                              |Complete|
+//                                              +--------+
+//
+// Its important to note that synchronous actions will effectively Resolve()
+// out of the Running state immediately. Asynchronous StorageActions may remain
+// in the Running state for some time, but normally the ActionRunnable itself
+// does not see any execution there. Its all handled internal to the StorageAction.
+NS_IMETHODIMP
+StorageContext::ActionRunnable::Run()
+{
+  switch(mState) {
+    // ----------------------
+    case STATE_RUN_ON_TARGET:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      MOZ_ASSERT(!mExecutingRunOnTarget);
+
+      // Note that we are calling RunOnTarget().  This lets us detect
+      // if Resolve() is called synchronously.
+      AutoRestore<bool> executingRunOnTarget(mExecutingRunOnTarget);
+      mExecutingRunOnTarget = true;
+
+      mState = STATE_RUNNING;
+      mAction->RunOnTarget(this, mQuotaInfo, mData);
+
+      mData = nullptr;
+
+      // Resolve was called synchronously from RunOnTarget(). We can
+      // immediately move to completing now since we are sure RunOnTarget()
+      // completed.
+      if (mState == STATE_RESOLVING) {
+        // Use recursion instead of switch case fall-through...  Seems slightly
+        // easier to understand.
+        Run();
+      }
+
+      break;
+    }
+    // -----------------
+    case STATE_RESOLVING:
+    {
+      MOZ_ASSERT(NS_GetCurrentThread() == mTarget);
+      // The call to StorageAction::RunOnTarget() must have returned now if we
+      // are running on the target thread again.  We may now proceed
+      // with completion.
+      mState = STATE_COMPLETING;
+      // Shutdown must be delayed until all Contexts are destroyed.  Crash
+      // for this invariant violation.
+      MOZ_ALWAYS_SUCCEEDS(
+        mInitiatingThread->Dispatch(this, nsIThread::DISPATCH_NORMAL));
+      break;
+    }
+    // -------------------
+    case STATE_COMPLETING:
+    {
+      NS_ASSERT_OWNINGTHREAD(ActionRunnable);
+      mAction->CompleteOnInitiatingThread(mResult);
+      mState = STATE_COMPLETE;
+      // Explicitly cleanup here as the destructor could fire on any of
+      // the threads we have bounced through.
+      Clear();
+      break;
+    }
+    // -----------------
+    default:
+    {
+      MOZ_CRASH("unexpected state in ActionRunnable");
+      break;
+    }
+  }
+  return NS_OK;
+}
+
+void
+StorageContext::ThreadsafeHandle::AllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    AllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all StorageContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::AllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+void
+StorageContext::ThreadsafeHandle::InvalidateAndAllowToClose()
+{
+  if (mOwningThread == NS_GetCurrentThread()) {
+    InvalidateAndAllowToCloseOnOwningThread();
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all StorageContexts have been destroyed.
+  nsCOMPtr<nsIRunnable> runnable =
+    NewRunnableMethod(this, &ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread);
+  MOZ_ALWAYS_SUCCEEDS(
+    mOwningThread->Dispatch(runnable, nsIThread::DISPATCH_NORMAL));
+}
+
+StorageContext::ThreadsafeHandle::ThreadsafeHandle(StorageContext* aContext)
+  : mStrongRef(aContext)
+  , mWeakRef(aContext)
+  , mOwningThread(NS_GetCurrentThread())
+{
+}
+
+StorageContext::ThreadsafeHandle::~ThreadsafeHandle()
+{
+  // Normally we only touch mStrongRef on the owning thread.  This is safe,
+  // however, because when we do use mStrongRef on the owning thread we are
+  // always holding a strong ref to the ThreadsafeHandle via the owning
+  // runnable.  So we cannot run the ThreadsafeHandle destructor simultaneously.
+  if (!mStrongRef || mOwningThread == NS_GetCurrentThread()) {
+    return;
+  }
+
+  // Dispatch is guaranteed to succeed here because we block shutdown until
+  // all Contexts have been destroyed.
+  NS_ProxyRelease(mOwningThread, mStrongRef.forget());
+}
+
+void
+StorageContext::ThreadsafeHandle::AllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+
+  // A StorageContext "closes" when its ref count drops to zero. Dropping this
+  // strong ref is necessary, but not sufficient for the close to occur.
+  // Any outstanding IO will continue and keep the StorageContext alive. Once
+  // the StorageContext is idle, it will be destroyed.
+
+  // First, tell the context to flush any target thread shared data. This
+  // data must be released on the target thread prior to running the
+  // StorageContext destructor. This will schedule an Action which ensures that
+  // the ~StorageContext() is not immediately executed when we drop the strong
+  // ref.
+  if (mStrongRef) {
+    mStrongRef->DoomTargetData();
+  }
+
+  // Now drop our strong ref and let StorageContext finish running any
+  // outstanding StorageActions.
+  mStrongRef = nullptr;
+}
+
+void
+StorageContext::ThreadsafeHandle::InvalidateAndAllowToCloseOnOwningThread()
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  // Cancel the StorageContext through the weak reference. This means we can
+  // allow the StorageContext to close by dropping the strong ref, but then
+  // still cancel ongoing IO if necessary.
+  if (mWeakRef) {
+    mWeakRef->Invalidate();
+  }
+  // We should synchronously have AllowToCloseOnOwningThread called when
+  // the Context is canceled.
+  MOZ_ASSERT(!mStrongRef);
+}
+
+void
+StorageContext::ThreadsafeHandle::StorageContextDestroyed(StorageContext* aContext)
+{
+  MOZ_ASSERT(mOwningThread == NS_GetCurrentThread());
+  MOZ_ASSERT(!mStrongRef);
+  MOZ_ASSERT(mWeakRef);
+  MOZ_ASSERT(mWeakRef == aContext);
+  mWeakRef = nullptr;
+}
+
+// static
+already_AddRefed<StorageContext>
+StorageContext::Create(StorageManager* aManager, nsIThread* aTarget,
+                       StorageAction* aInitAction, StorageContext* aOldContext)
+{
+  RefPtr<StorageContext> context =
+    new StorageContext(aManager, aTarget, aInitAction);
+  context->Init(aOldContext);
+  return context.forget();
+}
+
+StorageContext::StorageContext(StorageManager* aManager, nsIThread* aTarget,
+                               StorageAction* aInitAction)
+  : mManager(aManager)
+  , mTarget(aTarget)
+  , mData(new Data(aTarget))
+  , mState(STATE_CONTEXT_PREINIT)
+  , mOrphanedData(false)
+  , mInitAction(aInitAction)
+{
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(mTarget);
+}
+
+void
+StorageContext::Dispatch(StorageAction* aAction)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aAction);
+
+  MOZ_ASSERT(mState != STATE_CONTEXT_CANCELED);
+  if (mState == STATE_CONTEXT_CANCELED) {
+    return;
+  } else if (mState == STATE_CONTEXT_INIT ||
+             mState == STATE_CONTEXT_PREINIT) {
+    PendingStorageAction* pending = mPendingActions.AppendElement();
+    pending->mAction = aAction;
+    return;
+  }
+
+  MOZ_ASSERT(STATE_CONTEXT_READY);
+  DispatchAction(aAction);
+}
+
+void
+StorageContext::CancelAll()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  // In PREINIT state we have not dispatch the init action yet.  Just
+  // forget it.
+  if (mState == STATE_CONTEXT_PREINIT) {
+    MOZ_ASSERT(!mInitRunnable);
+    mInitAction = nullptr;
+
+  // In INIT state we have dispatched the runnable, but not received the
+  // async completion yet.  Cancel the runnable, but don't forget about it
+  // until we get OnQuotaInit() callback.
+  } else if (mState == STATE_CONTEXT_INIT) {
+    mInitRunnable->Cancel();
+  }
+
+  mState = STATE_CONTEXT_CANCELED;
+  mPendingActions.Clear();
+  {
+    ActivityList::ForwardIterator iter(mActivityList);
+    while (iter.HasMore()) {
+      iter.GetNext()->Cancel();
+    }
+  }
+  AllowToClose();
+}
+
+bool
+StorageContext::IsCanceled() const
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  return mState == STATE_CONTEXT_CANCELED;
+}
+
+void
+StorageContext::Invalidate()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  mManager->NoteClosing();
+  CancelAll();
+}
+
+void
+StorageContext::AllowToClose()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->AllowToClose();
+  }
+}
+
+void
+StorageContext::CancelForStorageId(StorageId aId)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  // Remove matching pending actions
+  for (int32_t i = mPendingActions.Length() - 1; i >= 0; --i) {
+    if (mPendingActions[i].mAction->MatchesStorageId(aId)) {
+      mPendingActions.RemoveElementAt(i);
+    }
+  }
+
+  // Cancel activities and let them remove themselves
+  ActivityList::ForwardIterator iter(mActivityList);
+  while (iter.HasMore()) {
+    Activity* activity = iter.GetNext();
+    if (activity->MatchesStorageId(aId)) {
+      activity->Cancel();
+    }
+  }
+}
+
+StorageContext::~StorageContext()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(mManager);
+  MOZ_ASSERT(!mData);
+
+  if (mThreadsafeHandle) {
+    mThreadsafeHandle->StorageContextDestroyed(this);
+  }
+
+  // Note, this may set the mOrphanedData flag.
+  mManager->RemoveStorageContext(this);
+
+  if (mNextContext) {
+    mNextContext->Start();
+  }
+}
+
+void
+StorageContext::Init(StorageContext* aOldContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  if (aOldContext) {
+    aOldContext->SetNextContext(this);
+    return;
+  }
+
+  Start();
+}
+
+void
+StorageContext::Start()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  // Previous context closing delayed our start, but then we were canceled.
+  // In this case, just do nothing here.
+  if (mState == STATE_CONTEXT_CANCELED) {
+    MOZ_ASSERT(!mInitRunnable);
+    MOZ_ASSERT(!mInitAction);
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_PREINIT);
+  MOZ_ASSERT(!mInitRunnable);
+
+  mInitRunnable = new QuotaInitRunnable(this, mManager, mData, mTarget,
+                                        mInitAction);
+  mInitAction = nullptr;
+
+  mState = STATE_CONTEXT_INIT;
+
+  nsresult rv = mInitRunnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all StorageContexts are destroyed.
+    // Shutdown must also prevent any new StorageContexts from being constructed.
+    // Crash for this invariant violation.
+    MOZ_CRASH("Failed to dispatch QuotaInitRunnable.");
+  }
+}
+
+void
+StorageContext::DispatchAction(StorageAction* aAction, bool aDoomData)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  RefPtr<ActionRunnable> runnable =
+    new ActionRunnable(this, mData, mTarget, aAction, mQuotaInfo);
+
+  if (aDoomData) {
+    mData = nullptr;
+  }
+
+  nsresult rv = runnable->Dispatch();
+  if (NS_FAILED(rv)) {
+    // Shutdown must be delayed until all Contexts are destroyed.  Crash
+    // for this invariant violation.
+    MOZ_CRASH("Failed to dispatch ActionRunnable to target thread.");
+  }
+  AddActivity(runnable);
+}
+
+void
+StorageContext::OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                            already_AddRefed<quota::DirectoryLock> aDirectoryLock)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+
+  MOZ_ASSERT(mInitRunnable);
+  mInitRunnable = nullptr;
+
+  mQuotaInfo = aQuotaInfo;
+
+  // Always save the directory lock to ensure QuotaManager does not shutdown
+  // before the StorageContext has gone away.
+  MOZ_ASSERT(!mDirectoryLock);
+  mDirectoryLock = aDirectoryLock;
+
+  // If we opening the context failed, but we were not explicitly canceled,
+  // still treat the entire context as canceled.  We don't want to allow
+  // new actions to be dispatched.  We also cannot leave the context in
+  // the INIT state after failing to open.
+  if (NS_FAILED(aRv)) {
+    mState = STATE_CONTEXT_CANCELED;
+  }
+
+  if (mState == STATE_CONTEXT_CANCELED) {
+    for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+      mPendingActions[i].mAction->CompleteOnInitiatingThread(aRv);
+    }
+    mPendingActions.Clear();
+    mThreadsafeHandle->AllowToClose();
+    // Context will destruct after return here and last ref is released.
+    return;
+  }
+
+  MOZ_ASSERT(mState == STATE_CONTEXT_INIT);
+  mState = STATE_CONTEXT_READY;
+
+  for (uint32_t i = 0; i < mPendingActions.Length(); ++i) {
+    DispatchAction(mPendingActions[i].mAction);
+  }
+  mPendingActions.Clear();
+}
+
+void
+StorageContext::AddActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+  mActivityList.AppendElement(aActivity);
+}
+
+void
+StorageContext::RemoveActivity(Activity* aActivity)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aActivity);
+  MOZ_ALWAYS_TRUE(mActivityList.RemoveElement(aActivity));
+  MOZ_ASSERT(!mActivityList.Contains(aActivity));
+}
+
+void
+StorageContext::NoteOrphanedData()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  // This may be called more than once
+  mOrphanedData = true;
+}
+
+already_AddRefed<StorageContext::ThreadsafeHandle>
+StorageContext::CreateThreadsafeHandle()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  if (!mThreadsafeHandle) {
+    mThreadsafeHandle = new ThreadsafeHandle(this);
+  }
+  RefPtr<ThreadsafeHandle> ref = mThreadsafeHandle;
+  return ref.forget();
+}
+
+void
+StorageContext::SetNextContext(StorageContext* aNextContext)
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(aNextContext);
+  MOZ_ASSERT(!mNextContext);
+  mNextContext = aNextContext;
+}
+
+void
+StorageContext::DoomTargetData()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageContext);
+  MOZ_ASSERT(mData);
+
+  // We are about to drop our reference to the Data. We need to ensure that
+  // the ~StorageContext() destructor does not run until contents of Data have
+  // been released on the Target thread.
+
+  // Dispatch a no-op StorageAction. This will hold the StorageContext alive
+  // through a roundtrip to the target thread and back to the owning thread.
+  // The ref to the Data object is cleared on the owning thread after creating
+  // the ActionRunnable, but before dispatching it.
+  RefPtr<StorageAction> action = new NullAction();
+  DispatchAction(action, true /* doomed data */);
+
+  MOZ_ASSERT(!mData);
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageContext.h b/dom/backgroundsync/StorageContext.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageContext.h
@@ -0,0 +1,219 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageContext_h
+#define mozilla_dom_StorageContext_h
+
+namespace mozilla {
+namespace dom {
+
+namespace quota {
+  class DirectoryLock;
+} // namespace quota
+
+class StorageManager;
+
+/**
+ * The StorageContext class is RAII-style class for managing IO operations
+ * within Background Sync storage.
+ *
+ * When a StorageContext is created it performs the complicated steps necessary
+ * to initialize the QuotaManager. StorageAction objects dispatched on the
+ * Context are delayed until this initialization is complete. They are then
+ * allow to execute on any specified thread. Once all references to the
+ * StorageContext are gone, then the steps necessary to release the QuotaManager
+ * are performed. After initialization the StorageContext holds a self reference,
+ * so it will stay alive until one of three conditions occur:
+ *
+ * 1) The StorageManager will call StorageContext::AllowToClose() when all of
+ *    the actors have removed themselves as listener. This means an idle
+ *    context with no active DOM objects will close gracefully.
+ * 2) The QuotaManager aborts all operations so it can delete the files.
+ *    In this case the QuotaManager calls Client::AbortOperations() which
+ *    in turn cancels all existing Action objects and then marks the
+ *    StorageManager as invalid.
+ * 3) Browser shutdown occurs and the StorageManager calls
+ *    StorageContext::CancelAll()
+ *
+ * In either case, though, the StorageAction objects must be destroyed first to
+ * allow the StorageContext to be destroyed.
+ *
+ * While the StorageContext performs operations asynchronously on threads, all
+ * of methods in its public interface must be called on the same thread
+ * originally used to create the Context.
+ */
+
+class StorageContext final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageContext)
+
+  // Define a class allowing other threads to hold the StorageContext alive.
+  // This also allows these other threads to safely close or cancel the
+  // StorageContext.
+  class ThreadsafeHandle final
+  {
+    friend class StorageContext;
+
+  public:
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ThreadsafeHandle)
+
+    void AllowToClose();
+    void InvalidateAndAllowToClose();
+
+  private:
+    explicit ThreadsafeHandle(StorageContext* aContext);
+    ~ThreadsafeHandle();
+
+    // Disallow copying.
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
+    void AllowToCloseOnOwningThread();
+    void InvalidateAndAllowToCloseOnOwningThread();
+
+    void StorageContextDestroyed(StorageContext* aContext);
+
+    // Cleared to allow the StorageContext to close.  Only safe to access on
+    // owning thread.
+    RefPtr<StorageContext> mStrongRef;
+
+    // Used to support cancelation even while the StorageContext is already
+    // allowed to close.  Cleared by ~StorageContext() calling
+    // StorageContextDestroyed().  Only safe to access on owning thread.
+    StorageContext* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+  };
+
+  // Different objects hold references to the StorageContext while some work is
+  // being performed asynchronously. These objects must implement the Activity
+  // interface and register themselves with the AddActivity().  When they are
+  // destroyed they must call RemoveActivity(). This allows the StorageContext
+  // to cancel any outstanding Activity work when the Context is cancelled.
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+    virtual bool MatchesStorageId(StorageId aStorageId) const = 0;
+  };
+
+  // Create a Context attached to the given StorageManager.
+  // The given StorageAction will run on the QuotaManager IO thread.
+  // Note, this StorageAction must be execute synchronously.
+  static already_AddRefed<StorageContext>
+  Create(StorageManager* aManager, nsIThread* aTarget,
+         StorageAction* aInitAction, StorageContext* aOldContext);
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(StorageAction* aAction);
+
+  // Cancel any StorageActions running or waiting to run.
+  // This should allow the StorageContext to be released and
+  // Listener::RemoveContext() will be called when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+  // True if CancelAll() has been called.
+  bool IsCanceled() const;
+
+  // Like CancelAll(), but also marks the Manager as "invalid".
+  void Invalidate();
+
+  // Remove any self references and allow the StorageContext to be released
+  // when there are no more StorageActions to process.
+  void AllowToClose();
+
+  // Cancel any StorageActions running or waiting to run that operate on the
+  // given storage ID.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelForStorageId(StorageId aId);
+
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo&
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
+  // Tell the StorageContext that some state information has been orphaned in
+  // the data store and won't be cleaned up. The StoargeContext will leave the
+  // marker in place to trigger cleanup the next times its opened.
+  void NoteOrphanedData();
+
+private:
+  class Data;
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_PREINIT,
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingStorageAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    RefPtr<StorageAction> mAction;
+  };
+
+  StorageContext(StorageManager* aManager, nsIThread* aTarget,
+                 StorageAction* aInitAction);
+  ~StorageContext();
+  void Init(StorageContext* aOldContext);
+  void Start();
+  void DispatchAction(StorageAction* aAction, bool aDoomData = false);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                   already_AddRefed<quota::DirectoryLock> aDirectoryLock);
+
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
+
+  void
+  SetNextContext(StorageContext* aNextContext);
+
+  void
+  DoomTargetData();
+
+  RefPtr<StorageManager> mManager;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<Data> mData;
+  State mState;
+  bool mOrphanedData;
+  QuotaInfo mQuotaInfo;
+  RefPtr<QuotaInitRunnable> mInitRunnable;
+  RefPtr<StorageAction> mInitAction;
+  nsTArray<PendingStorageAction> mPendingActions;
+
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us. This creates
+  // a ref-cycle that keeps the StorageContext alive.  The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  RefPtr<quota::DirectoryLock> mDirectoryLock;
+  RefPtr<StorageContext> mNextContext;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageContext_h
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -0,0 +1,325 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManager.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/StaticMutex.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+// ---------------------------------------------------------------------------
+
+// Singleton class to track Manager instances and ensure there is only
+// one for each unique StorageManagerId.
+class StorageManager::Factory
+{
+public:
+  friend class StaticAutoPtr<StorageManager::Factory>;
+
+  static nsresult
+  GetOrCreate(StorageManagerId* aManagerId,
+              StorageManager** aManagerOut)
+  {
+    AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance. This forces the Get() call
+    // below to use the same factory.
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    RefPtr<StorageManager> ref = Get(aManagerId);
+    if (!ref) {
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("BSyncIOThread",
+                             getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      ref = new StorageManager(aManagerId, ioThread);
+
+      // There may be an old manager for this origin in the process of
+      // cleaning up.  We need to tell the new manager about this so
+      // that it won't actually start until the old manager is done.
+      RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
+      ref->Init(oldManager);
+
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<StorageManager>
+  Get(StorageManagerId* aManagerId, State aState = Open)
+  {
+    AssertIsOnBackgroundThread();
+
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    // Iterate in reverse to find the most recent, matching Manager. This
+    // is important when looking for a Closing Manager.  If a new Manager
+    // chains to an old Manager we want it to be the most recent one.
+    ManagerList::BackwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      RefPtr<StorageManager> manager = iter.GetNext();
+      if (aState == manager->GetState() && *manager->mManagerId == *aManagerId) {
+        return manager.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void
+  Remove(StorageManager* aManager)
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(sFactory);
+
+    MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
+
+    // Clean up the factory singleton if there are no more managers.
+    MaybeDestroyInstance();
+  }
+
+  static void
+  Abort(const nsACString& aOrigin)
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        if (aOrigin.IsVoid() ||
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
+          manager->Abort();
+        }
+      }
+    }
+  }
+
+  static void
+  ShutdownAll()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      // Note that we are synchronously calling shutdown code here. If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
+    }
+
+    MaybeDestroyInstance();
+  }
+
+  static bool
+  IsShutdownAllComplete()
+  {
+    AssertIsOnBackgroundThread();
+    return !sFactory;
+  }
+
+private:
+  Factory()
+    : mInSyncShutdown(false)
+  {
+    MOZ_COUNT_CTOR(StorageManager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(StorageManager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
+  }
+
+  static nsresult
+  MaybeCreateInstance()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // Be clear about what we are locking. sFactory is bg thread only, so
+      // we don't need to lock it here. Just protect sFactoryShutdown and
+      // sBackgroundThread.
+      {
+        StaticMutexAutoLock lock(sMutex);
+
+        if (sFactoryShutdown) {
+          return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+        }
+      }
+
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread. Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+
+    return NS_OK;
+  }
+
+  static void
+  MaybeDestroyInstance()
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(sFactory);
+
+    // If the factory is still in use then we cannot delete yet. This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down. We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
+    sFactory = nullptr;
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove(). PBackground thread only.
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Protects following static attribute.
+  static StaticMutex sMutex;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sMutex to access.
+  static bool sFactoryShutdown;
+
+  // Weak references as we don't want to keep StorageManager objects alive
+  // forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
+  typedef nsTObserverArray<StorageManager*> ManagerList;
+  ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
+};
+
+// static
+StaticAutoPtr<StorageManager::Factory> StorageManager::Factory::sFactory;
+
+// static
+StaticMutex StorageManager::Factory::sMutex;
+
+// static
+bool StorageManager::Factory::sFactoryShutdown = false;
+
+// ---------------------------------------------------------------------------
+
+// static
+nsresult
+StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+                            StorageManager** aManagerOut)
+{
+  AssertIsOnBackgroundThread();
+  return Factory::GetOrCreate(aManagerId, aManagerOut);
+}
+
+StorageManager::StorageManager(StorageManagerId* aManagerId,
+                               nsIThread* aIOThread)
+  : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
+  , mContext(nullptr)
+  , mShuttingDown(false)
+  , mState(Open)
+{
+  MOZ_ASSERT(mManagerId);
+  MOZ_ASSERT(mIOThread);
+}
+
+StorageManager::~StorageManager()
+{
+  NS_ASSERT_OWNINGTHREAD(Manager);
+  MOZ_ASSERT(mState == Closing);
+  MOZ_ASSERT(!mContext);
+
+/*  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+
+  // Don't spin the event loop in the destructor waiting for the thread to
+  // shutdown. Defer this to the main thread, instead.
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
+}
+
+void
+StorageManager::RemoveStorageContext(StorageContext* aContext)
+{
+  // XXX
+}
+
+void
+StorageManager::NoteClosing()
+{
+  // XXX
+}
+
+void
+StorageManager::Init(StorageManager* aOldManager)
+{
+  // XXX
+}
+
+void
+StorageManager::Abort()
+{
+  // XXX
+}
+
+void
+StorageManager::Shutdown()
+{
+  // XXX
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.h
@@ -0,0 +1,82 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManager_h
+#define mozilla_dom_StorageManager_h
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * The StorageManager class is responsible for managing the storage of sync
+ * requests. The DOM objects and IPC actors are basically just plumbing to
+ * get the request to the right StorageManager object running in the parent
+ * process.
+ *
+ * There should be exactly one StorageManager object for each origin or app
+ * using the BackgroundSync API. This uniqueness is defined by the
+ * StorageManagerId equality operator. The uniqueness is enforced by the
+ * Manager GetOrCreate() factory method.
+ */
+
+class StorageManager final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageManager)
+
+  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+                              StorageManager** aManagerOut);
+
+  enum State
+  {
+    Open,
+    Closing
+  };
+
+  State GetState() const
+  {
+    return mState;
+  }
+
+  already_AddRefed<StorageManagerId> GetManagerId() const
+  {
+    RefPtr<StorageManagerId> ref = mManagerId;
+    return ref.forget();
+  }
+
+  // Must be called by StorageContext objects before they are destroyed.
+  void RemoveStorageContext(StorageContext* aContext);
+
+  // Marks the StorageManager "invalid". Once the StorageContext completes
+  // no new operations will be permitted with this StorageManager.
+  // New actors will get a new StorageManager.
+  void NoteClosing();
+
+private:
+  class Factory;
+
+  StorageManager(StorageManagerId* aManagerId, nsIThread* aIOThread);
+  ~StorageManager();
+
+  void Init(StorageManager* aOldManager);
+  void Abort();
+  void Shutdown();
+
+  RefPtr<StorageManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+
+  // Weak reference cleared by RemoveStorageContext() in StorageContext
+  // destructor.
+  StorageContext* MOZ_NON_OWNING_REF mContext;
+
+  bool mShuttingDown;
+  State mState;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManager_h
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -0,0 +1,173 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManagerId.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * StorageManagerIdFactory
+ */
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManagerIdFactory> factory =
+    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(factory));
+
+  return factory.forget();
+}
+
+StorageManagerIdFactory::StorageManagerIdFactory(
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+  : mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(aListener);
+
+  mListenerList.AppendElement(aListener);
+}
+
+StorageManagerIdFactory::~StorageManagerIdFactory()
+{
+  // Since this is a Runnable that executes on multiple threads, its a race
+  // to see which thread de-refs us last. Therefore we cannot guarantee which
+  // thread we destruct on.
+
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+NS_IMETHODIMP
+StorageManagerIdFactory::Run()
+{
+  // Execute twice. First on the main thread and the back on the originating
+  // thread.
+
+  if (mManagerId) {
+    AssertIsOnBackgroundThread();
+
+    ListenerList::ForwardIterator iter(mListenerList);
+    while (iter.HasMore()) {
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+    }
+
+    // The listener must clear its reference in
+    // OnStorageManagerIdCreated().
+    MOZ_ASSERT(mListenerList.IsEmpty());
+
+    return NS_OK;
+  }
+
+  AssertIsOnMainThread();
+
+  nsresult rv;
+  RefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                            &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  rv = StorageManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(this, NS_DISPATCH_NORMAL));
+
+  return NS_OK;
+}
+
+void
+StorageManagerIdFactory::AddListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+}
+
+void
+StorageManagerIdFactory::RemoveListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+
+  MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
+}
+
+/**
+ * StorageManagerId
+ */
+
+// static
+nsresult
+StorageManagerId::Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<StorageManagerId> ref =
+    new StorageManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+StorageManagerId::StorageManagerId(nsIPrincipal* aPrincipal,
+                                   const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+StorageManagerId::~StorageManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManagerId_h
+#define mozilla_dom_StorageManagerId_h
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::PrincipalInfo;
+
+class StorageManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const StorageManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  StorageManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~StorageManagerId();
+
+  StorageManagerId(const StorageManagerId&) = delete;
+  StorageManagerId& operator=(const StorageManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerId)
+};
+
+class StorageManagerIdFactory : public Runnable
+{
+public:
+  // An interface to be implemented by code wishing to use the
+  // StorageManagerIdFactory.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the StorageManagerIdFactory to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+  };
+
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
+
+  void AddListener(Listener* aListener);
+  // The Listener must call RemoveListener() when
+  // OnStorageManagerIdCreated is called or when
+  // the Listener is destroyed.
+  void RemoveListener(Listener* aListener);
+
+private:
+  StorageManagerIdFactory(Listener* aListener,
+                          const PrincipalInfo& aPrincipalInfo);
+  virtual ~StorageManagerIdFactory();
+
+  // Weak reference cleared by RemoveListener().
+  typedef nsTObserverArray<Listener*> ListenerList;
+  ListenerList mListenerList;
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<StorageManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManagerId_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -5,17 +5,21 @@
 
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
-    'BackgroundSyncParent.cpp'
+    'BackgroundSyncParent.cpp',
+    'StorageAction.cpp',
+    'StorageContext.cpp',
+    'StorageManager.cpp',
+    'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -470,17 +470,18 @@ BackgroundChildImpl::DeallocPFileSystemR
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
 dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+BackgroundChildImpl::AllocPBackgroundSyncChild(
+    const PrincipalInfo& aPrincipalInfo)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -161,17 +161,17 @@ protected:
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -889,32 +889,38 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
 mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  RefPtr<BackgroundSyncParent> agent =
+    new BackgroundSyncParent(aPrincipalInfo);
+  return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundSyncParent*>(aActor);
+  RefPtr<BackgroundSyncParent> parent =
+    dont_AddRef(static_cast<BackgroundSyncParent*>(aActor));
+  MOZ_ASSERT(parent);
+
   return true;
 }
 
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -193,17 +193,17 @@ protected:
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -97,17 +97,17 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
