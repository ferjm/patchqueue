# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  264cc148309eed356129b01b4246e7db76787ac9
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: Ensure unique manager per principal. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -319,17 +319,18 @@ BackgroundSync::ActorFailed()
 
 void
 BackgroundSync::ActorCreated(PBackgroundChild* aActor)
 {
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -12,17 +12,17 @@
 #include "mozilla/dom/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
 {
diff --git a/dom/backgroundsync/BackgroundSyncManagerId.cpp b/dom/backgroundsync/BackgroundSyncManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncManagerId.cpp
@@ -0,0 +1,69 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "BackgroundSyncManagerId.h"
+
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+
+// static
+nsresult
+BackgroundSyncManagerId::Create(nsIPrincipal* aPrincipal,
+                                BackgroundSyncManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<BackgroundSyncManagerId> ref =
+    new BackgroundSyncManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+BackgroundSyncManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+BackgroundSyncManagerId::BackgroundSyncManagerId(nsIPrincipal* aPrincipal,
+                                                 const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+BackgroundSyncManagerId::~BackgroundSyncManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncManagerId.h b/dom/backgroundsync/BackgroundSyncManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/BackgroundSyncManagerId.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_BackgroundSyncManagerId_h
+#define mozilla_dom_BackgroundSyncManagerId_h
+
+namespace mozilla {
+namespace dom {
+
+class BackgroundSyncManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         BackgroundSyncManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const BackgroundSyncManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  BackgroundSyncManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~BackgroundSyncManagerId();
+
+  BackgroundSyncManagerId(const BackgroundSyncManagerId&) = delete;
+  BackgroundSyncManagerId& operator=(const BackgroundSyncManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(BackgroundSyncManagerId)
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_BackgroundSyncManagerId_h
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -10,36 +10,115 @@
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class CreateManagerIdRunnable : public Runnable
+{
+public:
+  CreateManagerIdRunnable(const PrincipalInfo& aPrincipalInfo,
+                          BackgroundSyncParent* aParent,
+                          BackgroundSyncManagerId* aManagerId)
+    : mPrincipalInfo(aPrincipalInfo)
+    , mInitiatingThread(NS_GetCurrentThread())
+    , mParent(aParent)
+    , mManagerId(aManagerId)
+  {
+  }
+
+  NS_IMETHODIMP
+  Run() override
+  {
+    if (mManagerId) {
+      AssertIsOnBackgroundThread();
+      mParent->SetManagerId(mManagerId);
+      return NS_OK;
+    }
+
+    AssertIsOnMainThread();
+
+    nsresult rv;
+    RefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                              &rv);
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    rv = BackgroundSyncManagerId::Create(principal, getter_AddRefs(mManagerId));
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(this, NS_DISPATCH_NORMAL));
+
+    return NS_OK;
+  }
+
+private:
+  ~CreateManagerIdRunnable() {}
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<BackgroundSyncParent> mParent;
+  RefPtr<BackgroundSyncManagerId> mManagerId;
+};
+
+struct BackgroundSyncParent::PendingRequest final
+{
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID mRequestId;
+  SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  RefPtr<nsIRunnable> runnable = new CreateManagerIdRunnable(aPrincipalInfo,
+                                                             this,
+                                                             nullptr);
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(runnable));
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::SetManagerId(BackgroundSyncManagerId* aManagerId)
 {
-  AssertIsOnBackgroundThread();
+    mManagerId = aManagerId;
 
+    // Flush pending requests.
+    for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+      ExecuteRequest(mPendingRequests[i].mRequestId, mPendingRequests[i].mOp);
+    }
+    mPendingRequests.Clear();
+}
+
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
+{
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       // XXX Do registration.
       const SyncRegisterResponse response(true);
       //const SyncOpError response(static_cast<uint32_t>(NS_ERROR_FAILURE));
       Unused << SendResponse(aRequestId, response);
       break;
@@ -52,20 +131,37 @@ bool BackgroundSyncParent::RecvRequest(c
       Unused << SendResponse(aRequestId, response);
       break;
     }
     default:
     {
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a BackgroundSyncManagerId for this parent yet, we
+  // queue the request.
+  if (!mManagerId) {
+    mPendingRequests.AppendElement(PendingRequest(aRequestId, aOp));
+    return true;
+  }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,43 +2,57 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
+#include "BackgroundSyncManagerId.h"
+
 #include "mozilla/dom/PBackgroundSyncParent.h"
 #include "mozilla/dom/BackgroundSyncIPCTypes.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundParentImpl;
+  class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 private:
-  BackgroundSyncParent();
+  BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  void SetManagerId(BackgroundSyncManagerId* aManagerId);
+
+  RefPtr<BackgroundSyncManagerId> mManagerId;
+  struct PendingRequest;
+  nsTArray<PendingRequest> mPendingRequests;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
 
 
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -5,16 +5,17 @@
 
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
+    'BackgroundSyncManagerId.cpp',
     'BackgroundSyncParent.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -470,17 +470,18 @@ BackgroundChildImpl::DeallocPFileSystemR
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
 dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+BackgroundChildImpl::AllocPBackgroundSyncChild(
+    const PrincipalInfo& aPrincipalInfo)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -161,17 +161,17 @@ protected:
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -889,22 +889,23 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
 mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  return new BackgroundSyncParent(aPrincipalInfo);
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -193,17 +193,17 @@ protected:
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -97,17 +97,17 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
