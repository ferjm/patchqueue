# HG changeset patch
# User Fernando Jimenez <ferjmoreno@gmail.com>
# Parent  53ec980e00e03d6609707c8413b71deca4125745
Bug 1217544 - Implement one-off BackgroundSync API. Part 5: StorageManager and StorageContext. r=baku

diff --git a/dom/backgroundsync/BackgroundSync.cpp b/dom/backgroundsync/BackgroundSync.cpp
--- a/dom/backgroundsync/BackgroundSync.cpp
+++ b/dom/backgroundsync/BackgroundSync.cpp
@@ -334,17 +334,18 @@ BackgroundSync::ActorCreated(PBackground
   MOZ_ASSERT(IsBackgroundSyncThread());
   MOZ_ASSERT(aActor);
   MOZ_ASSERT(!mActor);
 
   if (mShuttingDown) {
     return;
   }
 
-  PBackgroundSyncChild* actor = aActor->SendPBackgroundSyncConstructor();
+  PBackgroundSyncChild* actor =
+    aActor->SendPBackgroundSyncConstructor(*mPrincipalInfo);
   mActor = static_cast<BackgroundSyncChild*>(actor);
   MOZ_ASSERT(mActor);
 
   // Flush pending requests.
   for (uint32_t i = 0, len = mPendingOperations.Length(); i < len; ++i) {
     RefPtr<SyncOpRunnable> runnable = mPendingOperations[i];
     MOZ_ASSERT(runnable);
     runnable->SetActor(mActor);
diff --git a/dom/backgroundsync/BackgroundSyncChild.h b/dom/backgroundsync/BackgroundSyncChild.h
--- a/dom/backgroundsync/BackgroundSyncChild.h
+++ b/dom/backgroundsync/BackgroundSyncChild.h
@@ -12,17 +12,17 @@
 #include "mozilla/dom/PBackgroundSyncChild.h"
 
 #include "nsID.h"
 #include "nsClassHashtable.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundChildImpl;
+  class BackgroundChildImpl;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSync;
 
 class BackgroundSyncChild final : public PBackgroundSyncChild
 {
diff --git a/dom/backgroundsync/BackgroundSyncParent.cpp b/dom/backgroundsync/BackgroundSyncParent.cpp
--- a/dom/backgroundsync/BackgroundSyncParent.cpp
+++ b/dom/backgroundsync/BackgroundSyncParent.cpp
@@ -10,33 +10,65 @@
 #include "mozilla/ipc/BackgroundParent.h"
 
 namespace mozilla {
 
 using namespace ipc;
 
 namespace dom {
 
-BackgroundSyncParent::BackgroundSyncParent()
+class BackgroundSyncParent::PendingRequest final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(PendingRequest)
+
+  explicit PendingRequest(const nsID& aRequestId,
+                          const SyncOp& aOp)
+    : mRequestId(aRequestId)
+    , mOp(aOp)
+  {}
+
+  nsID RequestId()
+  {
+    return mRequestId;
+  }
+
+  SyncOp Op()
+  {
+    return mOp;
+  }
+private:
+  ~PendingRequest() {}
+
+  nsID mRequestId;
+  SyncOp mOp;
+};
+
+BackgroundSyncParent::BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsOnBackgroundThread();
+
+  mStorageManagerIdFactory =
+    StorageManagerIdFactory::Create(this, aPrincipalInfo);
 }
 
 BackgroundSyncParent::~BackgroundSyncParent()
 {
   AssertIsOnBackgroundThread();
 }
 
-void BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
+void
+BackgroundSyncParent::ActorDestroy(ActorDestroyReason aWhy)
 {
   AssertIsOnBackgroundThread();
 }
 
-bool BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
-                                       const SyncOp& aOp)
+void
+BackgroundSyncParent::ExecuteRequest(const nsID& aRequestId,
+                                     const SyncOp& aOp)
 {
   AssertIsOnBackgroundThread();
 
   switch(aOp.mArgs().type()) {
     case SyncOpArgs::TSyncRegisterArgs:
     {
       // XXX Do registration.
       const SyncRegisterResponse response(true);
@@ -52,22 +84,60 @@ bool BackgroundSyncParent::RecvRequest(c
       Unused << SendResponse(aRequestId, response);
       break;
     }
     default:
     {
       MOZ_CRASH("Unknown BackgroundSync request");
     }
   }
+}
+
+bool
+BackgroundSyncParent::RecvRequest(const nsID& aRequestId,
+                                  const SyncOp& aOp)
+{
+  AssertIsOnBackgroundThread();
+
+  // If we haven't created a StorageManagerId for this parent yet, we
+  // queue the request.
+  if (!mStorageManagerId) {
+    RefPtr<PendingRequest> pendingRequest = new PendingRequest(aRequestId, aOp);
+    mPendingRequests.AppendElement(pendingRequest);
+    return true;
+  }
+
+  ExecuteRequest(aRequestId, aOp);
   return true;
 }
 
-bool BackgroundSyncParent::RecvShutdown()
+bool
+BackgroundSyncParent::RecvShutdown()
 {
   AssertIsOnBackgroundThread();
 
   Unused << Send__delete__(this);
 
   return true;
 }
 
+void
+BackgroundSyncParent::OnStorageManagerIdCreated(
+    StorageManagerId* aManagerId)
+{
+  MOZ_ASSERT(mStorageManagerIdFactory);
+  MOZ_ASSERT(!mStorageManagerId);
+
+  mStorageManagerId = aManagerId;
+  mStorageManagerIdFactory->RemoveListener(this);
+  mStorageManagerIdFactory = nullptr;
+
+  // Flush pending requests.
+  for (uint32_t i = 0, len = mPendingRequests.Length(); i < len; i++) {
+    MOZ_ASSERT(mPendingRequests[i]);
+    ExecuteRequest(mPendingRequests[i]->RequestId(),
+                   mPendingRequests[i]->Op());
+  }
+  mPendingRequests.Clear();
+}
+
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/backgroundsync/BackgroundSyncParent.h b/dom/backgroundsync/BackgroundSyncParent.h
--- a/dom/backgroundsync/BackgroundSyncParent.h
+++ b/dom/backgroundsync/BackgroundSyncParent.h
@@ -2,43 +2,62 @@
 /* vim: set ts=8 sts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef mozilla_dom_BackgroundSyncParent_h
 #define mozilla_dom_BackgroundSyncParent_h
 
+#include "StorageManagerId.h"
+
 #include "mozilla/dom/PBackgroundSyncParent.h"
 #include "mozilla/dom/BackgroundSyncIPCTypes.h"
 
 #include "nsID.h"
 
 namespace mozilla {
 
 namespace ipc {
-class BackgroundParentImpl;
+  class BackgroundParentImpl;
+  class PrincipalInfo;
 } // namespace ipc
 
 namespace dom {
 
 class BackgroundSyncParent final : public PBackgroundSyncParent
+                                 , StorageManagerIdFactory::Listener
 {
   friend class mozilla::ipc::BackgroundParentImpl;
+  friend class CreateManagerIdRunnable;
 
 public:
+  NS_INLINE_DECL_REFCOUNTING(BackgroundSyncParent)
+
   virtual bool RecvRequest(const nsID& aRequestId,
                            const SyncOp& aOp) override;
 
   virtual bool RecvShutdown() override;
 private:
-  BackgroundSyncParent();
+  BackgroundSyncParent(const PrincipalInfo& aPrincipalInfo);
   ~BackgroundSyncParent();
 
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
+
+  void ExecuteRequest(const nsID& aRequestId, const SyncOp& aOp);
+
+  // StorageManagerId method
+  virtual void
+  OnStorageManagerIdCreated(StorageManagerId* aManagerId) override;
+
+  RefPtr<StorageManagerIdFactory> mStorageManagerIdFactory;
+  // We use this Id to ensure that we have a single StorageManager
+  // per principal.
+  RefPtr<StorageManagerId> mStorageManagerId;
+
+  class PendingRequest;
+  nsTArray<RefPtr<PendingRequest>> mPendingRequests;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_BackgroundSyncParent_h
-
-
diff --git a/dom/backgroundsync/StorageAction.cpp b/dom/backgroundsync/StorageAction.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.cpp
@@ -0,0 +1,38 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageAction.h"
+
+namespace mozilla {
+namespace dom {
+
+void
+StorageAction::CancelOnInitiatingThread()
+{
+  NS_ASSERT_OWNINGTHREAD(StorageAction);
+  // It is possible for cancellation to be duplicated. For example, an
+  // individual BackgroundSync could have its StorageActions canceled
+  // and then shutdown could trigger a second action.
+  mCanceled = true;
+}
+
+StorageAction::StorageAction()
+  : mCanceled(false)
+{
+}
+
+StorageAction::~StorageAction()
+{
+}
+
+bool
+StorageAction::IsCanceled() const
+{
+  return mCanceled;
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageAction.h b/dom/backgroundsync/StorageAction.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageAction.h
@@ -0,0 +1,104 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageAction_h
+#define mozilla_dom_StorageAction_h
+
+#include "mozilla/Atomics.h"
+#include "nsISupportsImpl.h"
+
+class mozIStorageConnection;
+
+namespace mozilla {
+namespace dom {
+
+class StorageAction
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageAction)
+
+  class Resolver
+  {
+  public:
+    // Note: StorageAction must drop Resolver ref after calling Resolve()!
+    // Note: Must be called on the same thread used to execute
+    //       StorageAction::RunOnTarget().
+    virtual void Resolve(nsresult aRv) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    AddRef(void) = 0;
+
+    NS_IMETHOD_(MozExternalRefCountType)
+    Release(void) = 0;
+  };
+
+  // Class containing data that can be opportunistically shared between
+  // multiple StorageActions running on the same thread/StorageContext.
+  class Data
+  {
+  public:
+    virtual mozIStorageConnection*
+    GetConnection() const = 0;
+
+    virtual void
+    SetConnection(mozIStorageConnection* aConn) = 0;
+  };
+
+  // Execute operations on the target thread.  Once complete call
+  // Resolver::Resolve(). This can be done sync or async.
+  // Note: StorageAction should hold Resolver ref until its ready to call
+  //        Resolve().
+  // Note: The "target" thread is determined when the StorageAction is scheduled
+  //       on StorageContext. The StorageAction should not assume any particular
+  //       thread is used.
+  virtual void RunOnTarget(Resolver* aResolver, const QuotaInfo& aQuotaInfo,
+                           Data* aOptionalData) = 0;
+
+  // Called on initiating thread when the StorageAction is canceled.
+  // The StorageAction is responsible for calling Resolver::Resolve() as normal;
+  // either with a normal error code or NS_ERROR_ABORT. If
+  // CancelOnInitiatingThread() is called after Resolve() has already occurred,
+  // then the cancel can be ignored.
+  //
+  // Cancellation is a best effort to stop processing as soon as possible, but
+  // does not guarantee the StorageAction will not run.
+  //
+  // CancelOnInitiatingThread() may be called more than once. Subsequent
+  // calls should have no effect.
+  //
+  // Default implementation sets an internal cancellation flag that can be
+  // queried with IsCanceled().
+  virtual void CancelOnInitiatingThread();
+
+  // Executed on the initiating thread and is passed the nsresult given to
+  // Resolver::Resolve().
+  virtual void CompleteOnInitiatingThread(nsresult aRv) { }
+
+  // Executed on the initiating thread. If this StorageAction will operate on
+  // the given storage ID then override this to return true.
+  virtual bool MatchesStorageId(StorageId aId) const {
+    return false;
+  }
+
+protected:
+  StorageAction();
+
+  // virtual because deleted through base class pointer
+  virtual ~StorageAction();
+
+  // Check if this StorageAction has been canceled.
+  // May be called from any thread, but typically used from the target thread.
+  bool IsCanceled() const;
+
+private:
+  // Accessible from any thread.
+  Atomic<bool> mCanceled;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageAction_h
diff --git a/dom/backgroundsync/StorageContext.h b/dom/backgroundsync/StorageContext.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageContext.h
@@ -0,0 +1,213 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageContext_h
+#define mozilla_dom_StorageContext_h
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * The StorageContext class is RAII-style class for managing IO operations
+ * within Background Sync storage.
+ *
+ * When a StorageContext is created it performs the complicated steps necessary
+ * to initialize the QuotaManager. StorageAction objects dispatched on the
+ * Context are delayed until this initialization is complete. They are then
+ * allow to execute on any specified thread. Once all references to the
+ * StorageContext are gone, then the steps necessary to release the QuotaManager
+ * are performed. After initialization the StorageContext holds a self reference,
+ * so it will stay alive until one of three conditions occur:
+ *
+ * 1) The StorageManager will call StorageContext::AllowToClose() when all of
+ *    the actors have removed themselves as listener. This means an idle
+ *    context with no active DOM objects will close gracefully.
+ * 2) The QuotaManager aborts all operations so it can delete the files.
+ *    In this case the QuotaManager calls Client::AbortOperations() which
+ *    in turn cancels all existing Action objects and then marks the
+ *    StorageManager as invalid.
+ * 3) Browser shutdown occurs and the StorageManager calls
+ *    StorageContext::CancelAll()
+ *
+ * In either case, though, the StorageAction objects must be destroyed first to
+ * allow the StorageContext to be destroyed.
+ *
+ * While the StorageContext performs operations asynchronously on threads, all
+ * of methods in its public interface must be called on the same thread
+ * originally used to create the Context.
+ */
+
+class StorageContext final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageContext)
+
+  // Define a class allowing other threads to hold the StorageContext alive.
+  // This also allows these other threads to safely close or cancel the
+  // StorageContext.
+  class ThreadsafeHandle final
+  {
+    friend class StorageContext;
+
+  public:
+    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(ThreadsafeHandle)
+
+    void AllowToClose();
+    void InvalidateAndAllowToClose();
+
+  private:
+    explicit ThreadsafeHandle(StorageContext* aContext);
+    ~ThreadsafeHandle();
+
+    // Disallow copying.
+    ThreadsafeHandle(const ThreadsafeHandle&) = delete;
+    ThreadsafeHandle& operator=(const ThreadsafeHandle&) = delete;
+
+    void AllowToCloseOnOwningThread();
+    void InvalidateAndAllowToCloseOnOwningThread();
+
+    void StorageContextDestroyed(StorageContext* aContext);
+
+    // Cleared to allow the StorageContext to close.  Only safe to access on
+    // owning thread.
+    RefPtr<StorageContext> mStrongRef;
+
+    // Used to support cancelation even while the StorageContext is already
+    // allowed to close.  Cleared by ~StorageContext() calling
+    // StorageContextDestroyed().  Only safe to access on owning thread.
+    StorageContext* mWeakRef;
+
+    nsCOMPtr<nsIThread> mOwningThread;
+  };
+
+  // Different objects hold references to the StorageContext while some work is
+  // being performed asynchronously. These objects must implement the Activity
+  // interface and register themselves with the AddActivity().  When they are
+  // destroyed they must call RemoveActivity(). This allows the StorageContext
+  // to cancel any outstanding Activity work when the Context is cancelled.
+  class Activity
+  {
+  public:
+    virtual void Cancel() = 0;
+    virtual bool MatchesStorageId(StorageId aStorageId) const = 0;
+  };
+
+  // Create a Context attached to the given StorageManager.
+  // The given StorageAction will run on the QuotaManager IO thread.
+  // Note, this StorageAction must be execute synchronously.
+  static already_AddRefed<StorageContext>
+  Create(StorageManager* aManager, nsIThread* aTarget,
+         StorageAction* aInitAction, StorageContext* aOldContext);
+
+  // Execute given action on the target once the quota manager has been
+  // initialized.
+  //
+  // Only callable from the thread that created the Context.
+  void Dispatch(StorageAction* aAction);
+
+  // Cancel any StorageActions running or waiting to run.
+  // This should allow the StorageContext to be released and
+  // Listener::RemoveContext() will be called when complete.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelAll();
+
+  // True if CancelAll() has been called.
+  bool IsCanceled() const;
+
+  // Like CancelAll(), but also marks the Manager as "invalid".
+  void Invalidate();
+
+  // Remove any self references and allow the StorageContext to be released
+  // when there are no more StorageActions to process.
+  void AllowToClose();
+
+  // Cancel any StorageActions running or waiting to run that operate on the
+  // given storage ID.
+  //
+  // Only callable from the thread that created the Context.
+  void CancelForStorageId(StorageId aId);
+
+  void AddActivity(Activity* aActivity);
+  void RemoveActivity(Activity* aActivity);
+
+  const QuotaInfo&
+  GetQuotaInfo() const
+  {
+    return mQuotaInfo;
+  }
+
+  // Tell the StorageContext that some state information has been orphaned in
+  // the data store and won't be cleaned up. The StoargeContext will leave the
+  // marker in place to trigger cleanup the next times its opened.
+  void NoteOrphanedData();
+
+private:
+  class Data;
+  class QuotaInitRunnable;
+  class ActionRunnable;
+
+  enum State
+  {
+    STATE_CONTEXT_PREINIT,
+    STATE_CONTEXT_INIT,
+    STATE_CONTEXT_READY,
+    STATE_CONTEXT_CANCELED
+  };
+
+  struct PendingStorageAction
+  {
+    nsCOMPtr<nsIEventTarget> mTarget;
+    RefPtr<StorageAction> mAction;
+  };
+
+  StorageContext(StorageManager* aManager, nsIThread* aTarget,
+                 StorageAction* aInitAction);
+  ~StorageContext();
+  void Init(StorageContext* aOldContext);
+  void Start();
+  void DispatchAction(StorageAction* aAction, bool aDoomData = false);
+  void OnQuotaInit(nsresult aRv, const QuotaInfo& aQuotaInfo,
+                   already_AddRefed<DirectoryLock> aDirectoryLock);
+
+
+  already_AddRefed<ThreadsafeHandle>
+  CreateThreadsafeHandle();
+
+  void
+  SetNextContext(Context* aNextContext);
+
+  void
+  DoomTargetData();
+
+  RefPtr<StorageManager> mManager;
+  nsCOMPtr<nsIThread> mTarget;
+  RefPtr<Data> mData;
+  State mState;
+  bool mOrphanedData;
+  QuotaInfo mQuotaInfo;
+  RefPtr<QuotaInitRunnable> mInitRunnable;
+  RefPtr<StorageAction> mInitAction;
+  nsTArray<PendingStorageAction> mPendingActions;
+
+  // Weak refs since activites must remove themselves from this list before
+  // being destroyed by calling RemoveActivity().
+  typedef nsTObserverArray<Activity*> ActivityList;
+  ActivityList mActivityList;
+
+  // The ThreadsafeHandle may have a strong ref back to us. This creates
+  // a ref-cycle that keeps the StorageContext alive.  The ref-cycle is broken
+  // when ThreadsafeHandle::AllowToClose() is called.
+  RefPtr<ThreadsafeHandle> mThreadsafeHandle;
+
+  RefPtr<DirectoryLock> mDirectoryLock;
+  RefPtr<StorageContext> mNextContext;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageContext_h
diff --git a/dom/backgroundsync/StorageManager.cpp b/dom/backgroundsync/StorageManager.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.cpp
@@ -0,0 +1,309 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManager.h"
+
+#include "mozilla/AutoRestore.h"
+#include "mozilla/StaticMutex.h"
+#include "nsIThread.h"
+#include "nsThreadUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+// ---------------------------------------------------------------------------
+
+// Singleton class to track Manager instances and ensure there is only
+// one for each unique StorageManagerId.
+class StorageManager::Factory
+{
+public:
+  friend class StaticAutoPtr<StorageManager::Factory>;
+
+  static nsresult
+  GetOrCreate(StorageManagerId* aManagerId,
+              StorageManager** aManagerOut)
+  {
+    AssertIsOnBackgroundThread();
+
+    // Ensure there is a factory instance. This forces the Get() call
+    // below to use the same factory.
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return rv;
+    }
+
+    RefPtr<StorageManager> ref = Get(aManagerId);
+    if (!ref) {
+      nsCOMPtr<nsIThread> ioThread;
+      rv = NS_NewNamedThread("BSyncIOThread",
+                             getter_AddRefs(ioThread));
+      if (NS_WARN_IF(NS_FAILED(rv))) {
+        return rv;
+      }
+
+      ref = new StorageManager(aManagerId, ioThread);
+
+      // There may be an old manager for this origin in the process of
+      // cleaning up.  We need to tell the new manager about this so
+      // that it won't actually start until the old manager is done.
+      RefPtr<StorageManager> oldManager = Get(aManagerId, Closing);
+      ref->Init(oldManager);
+
+      MOZ_ASSERT(!sFactory->mManagerList.Contains(ref));
+      sFactory->mManagerList.AppendElement(ref);
+    }
+
+    ref.forget(aManagerOut);
+
+    return NS_OK;
+  }
+
+  static already_AddRefed<StorageManager>
+  Get(StorageManagerId* aManagerId, State aState = Open)
+  {
+    AssertIsOnBackgroundThread();
+
+    nsresult rv = MaybeCreateInstance();
+    if (NS_WARN_IF(NS_FAILED(rv))) {
+      return nullptr;
+    }
+
+    // Iterate in reverse to find the most recent, matching Manager. This
+    // is important when looking for a Closing Manager.  If a new Manager
+    // chains to an old Manager we want it to be the most recent one.
+    ManagerList::BackwardIterator iter(sFactory->mManagerList);
+    while (iter.HasMore()) {
+      RefPtr<StorageManager> manager = iter.GetNext();
+      if (aState == manager->GetState() && *manager->mManagerId == *aManagerId) {
+        return manager.forget();
+      }
+    }
+
+    return nullptr;
+  }
+
+  static void
+  Remove(StorageManager* aManager)
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(aManager);
+    MOZ_ASSERT(sFactory);
+
+    MOZ_ALWAYS_TRUE(sFactory->mManagerList.RemoveElement(aManager));
+
+    // Clean up the factory singleton if there are no more managers.
+    MaybeDestroyInstance();
+  }
+
+  static void
+  Abort(const nsACString& aOrigin)
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        if (aOrigin.IsVoid() ||
+            manager->mManagerId->QuotaOrigin() == aOrigin) {
+          manager->Abort();
+        }
+      }
+    }
+  }
+
+  static void
+  ShutdownAll()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      return;
+    }
+
+    MOZ_ASSERT(!sFactory->mManagerList.IsEmpty());
+
+    {
+      // Note that we are synchronously calling shutdown code here. If any
+      // of the shutdown code synchronously decides to delete the Factory
+      // we need to delay that delete until the end of this method.
+      AutoRestore<bool> restore(sFactory->mInSyncShutdown);
+      sFactory->mInSyncShutdown = true;
+
+      ManagerList::ForwardIterator iter(sFactory->mManagerList);
+      while (iter.HasMore()) {
+        RefPtr<StorageManager> manager = iter.GetNext();
+        manager->Shutdown();
+      }
+    }
+
+    MaybeDestroyInstance();
+  }
+
+  static bool
+  IsShutdownAllComplete()
+  {
+    AssertIsOnBackgroundThread();
+    return !sFactory;
+  }
+
+private:
+  Factory()
+    : mInSyncShutdown(false)
+  {
+    MOZ_COUNT_CTOR(StorageManager::Factory);
+  }
+
+  ~Factory()
+  {
+    MOZ_COUNT_DTOR(StorageManager::Factory);
+    MOZ_ASSERT(mManagerList.IsEmpty());
+    MOZ_ASSERT(!mInSyncShutdown);
+  }
+
+  static nsresult
+  MaybeCreateInstance()
+  {
+    AssertIsOnBackgroundThread();
+
+    if (!sFactory) {
+      // Be clear about what we are locking. sFactory is bg thread only, so
+      // we don't need to lock it here. Just protect sFactoryShutdown and
+      // sBackgroundThread.
+      {
+        StaticMutexAutoLock lock(sMutex);
+
+        if (sFactoryShutdown) {
+          return NS_ERROR_ILLEGAL_DURING_SHUTDOWN;
+        }
+      }
+
+      // We cannot use ClearOnShutdown() here because we're not on the main
+      // thread. Instead, we delete sFactory in Factory::Remove() after the
+      // last manager is removed.  ShutdownObserver ensures this happens
+      // before shutdown.
+      sFactory = new Factory();
+    }
+
+    // Never return sFactory to code outside Factory.  We need to delete it
+    // out from under ourselves just before we return from Remove().  This
+    // would be (even more) dangerous if other code had a pointer to the
+    // factory itself.
+
+    return NS_OK;
+  }
+
+  static void
+  MaybeDestroyInstance()
+  {
+    AssertIsOnBackgroundThread();
+    MOZ_ASSERT(sFactory);
+
+    // If the factory is still in use then we cannot delete yet. This
+    // could be due to managers still existing or because we are in the
+    // middle of shutting down. We need to be careful not to delete ourself
+    // synchronously during shutdown.
+    if (!sFactory->mManagerList.IsEmpty() || sFactory->mInSyncShutdown) {
+      return;
+    }
+
+    sFactory = nullptr;
+  }
+
+  // Singleton created on demand and deleted when last Manager is cleared
+  // in Remove(). PBackground thread only.
+  static StaticAutoPtr<Factory> sFactory;
+
+  // Protects following static attribute.
+  static StaticMutex sMutex;
+
+  // Indicate if shutdown has occurred to block re-creation of sFactory.
+  // Must hold sMutex to access.
+  static bool sFactoryShutdown;
+
+  // Weak references as we don't want to keep StorageManager objects alive
+  // forever.
+  // When a Manager is destroyed it calls Factory::Remove() to clear itself.
+  // PBackground thread only.
+  typedef nsTObserverArray<StorageManager*> ManagerList;
+  ManagerList mManagerList;
+
+  // This flag is set when we are looping through the list and calling
+  // Shutdown() on each Manager.  We need to be careful not to synchronously
+  // trigger the deletion of the factory while still executing this loop.
+  bool mInSyncShutdown;
+};
+
+// static
+StaticAutoPtr<StorageManager::Factory> StorageManager::Factory::sFactory;
+
+// static
+StaticMutex StorageManager::Factory::sMutex;
+
+// static
+bool StorageManager::Factory::sFactoryShutdown = false;
+
+// ---------------------------------------------------------------------------
+
+// static
+nsresult
+StorageManager::GetOrCreate(StorageManagerId* aManagerId,
+                            StorageManager** aManagerOut)
+{
+  AssertIsOnBackgroundThread();
+  return NS_OK;
+}
+
+StorageManager::StorageManager(StorageManagerId* aManagerId,
+                               nsIThread* aIOThread)
+  : mManagerId(aManagerId)
+  , mIOThread(aIOThread)
+  , mState(Open)
+{
+  MOZ_ASSERT(mManagerId);
+  MOZ_ASSERT(mIOThread);
+}
+
+StorageManager::~StorageManager()
+{
+  MOZ_ASSERT(mState == Closing);
+/* XXX
+  nsCOMPtr<nsIThread> ioThread;
+  mIOThread.swap(ioThread);
+
+  // Don't spin the event loop in the destructor waiting for the thread to
+  // shutdown. Defer this to the main thread, instead.
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(
+        NewRunnableMethod(ioThread, &nsIThread::Shutdown)));*/
+}
+
+void
+StorageManager::Init(StorageManager* aOldManager)
+{
+  // XXX
+}
+
+void
+StorageManager::Abort()
+{
+  // XXX
+}
+
+void
+StorageManager::Shutdown()
+{
+  // XXX
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManager.h b/dom/backgroundsync/StorageManager.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManager.h
@@ -0,0 +1,62 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManager_h
+#define mozilla_dom_StorageManager_h
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * The StorageManager class is responsible for managing the storage of sync
+ * requests. The DOM objects and IPC actors are basically just plumbing to
+ * get the request to the right StorageManager object running in the parent
+ * process.
+ *
+ * There should be exactly one StorageManager object for each origin or app
+ * using the BackgroundSync API. This uniqueness is defined by the
+ * StorageManagerId equality operator. The uniqueness is enforced by the
+ * Manager GetOrCreate() factory method.
+ */
+
+class StorageManager final
+{
+public:
+  NS_INLINE_DECL_REFCOUNTING(StorageManager)
+
+  static nsresult GetOrCreate(StorageManagerId* aManagerId,
+                              StorageManager** aManagerOut);
+
+  enum State
+  {
+    Open,
+    Closing
+  };
+
+  State GetState() const
+  {
+    return mState;
+  }
+
+private:
+  class Factory;
+
+  StorageManager(StorageManagerId* aManagerId, nsIThread* aIOThread);
+  ~StorageManager();
+
+  void Init(StorageManager* aOldManager);
+  void Abort();
+  void Shutdown();
+
+  RefPtr<StorageManagerId> mManagerId;
+  nsCOMPtr<nsIThread> mIOThread;
+  State mState;
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManager_h
diff --git a/dom/backgroundsync/StorageManagerId.cpp b/dom/backgroundsync/StorageManagerId.cpp
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.cpp
@@ -0,0 +1,173 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "StorageManagerId.h"
+
+#include "mozilla/ipc/BackgroundParent.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+
+namespace mozilla {
+namespace dom {
+
+/**
+ * StorageManagerIdFactory
+ */
+
+// static
+already_AddRefed<StorageManagerIdFactory>
+StorageManagerIdFactory::Create(Listener* aListener,
+                                const PrincipalInfo& aPrincipalInfo)
+{
+  AssertIsOnBackgroundThread();
+
+  RefPtr<StorageManagerIdFactory> factory =
+    new StorageManagerIdFactory(aListener, aPrincipalInfo);
+
+  MOZ_ALWAYS_SUCCEEDS(NS_DispatchToMainThread(factory));
+
+  return factory.forget();
+}
+
+StorageManagerIdFactory::StorageManagerIdFactory(
+    Listener* aListener, const PrincipalInfo& aPrincipalInfo)
+  : mPrincipalInfo(aPrincipalInfo)
+  , mInitiatingThread(NS_GetCurrentThread())
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(mInitiatingThread);
+  MOZ_ASSERT(aListener);
+
+  mListenerList.AppendElement(aListener);
+}
+
+StorageManagerIdFactory::~StorageManagerIdFactory()
+{
+  // Since this is a Runnable that executes on multiple threads, its a race
+  // to see which thread de-refs us last. Therefore we cannot guarantee which
+  // thread we destruct on.
+
+  MOZ_ASSERT(mListenerList.IsEmpty());
+}
+
+NS_IMETHODIMP
+StorageManagerIdFactory::Run()
+{
+  // Execute twice. First on the main thread and the back on the originating
+  // thread.
+
+  if (mManagerId) {
+    AssertIsOnBackgroundThread();
+
+    ListenerList::ForwardIterator iter(mListenerList);
+    while (iter.HasMore()) {
+      iter.GetNext()->OnStorageManagerIdCreated(mManagerId);
+    }
+
+    // The listener must clear its reference in
+    // OnStorageManagerIdCreated().
+    MOZ_ASSERT(mListenerList.IsEmpty());
+
+    return NS_OK;
+  }
+
+  AssertIsOnMainThread();
+
+  nsresult rv;
+  RefPtr<nsIPrincipal> principal = PrincipalInfoToPrincipal(mPrincipalInfo,
+                                                            &rv);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  rv = StorageManagerId::Create(principal, getter_AddRefs(mManagerId));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  MOZ_ALWAYS_SUCCEEDS(mInitiatingThread->Dispatch(this, NS_DISPATCH_NORMAL));
+
+  return NS_OK;
+}
+
+void
+StorageManagerIdFactory::AddListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+  MOZ_ASSERT(!mListenerList.Contains(aListener));
+
+  mListenerList.AppendElement(aListener);
+}
+
+void
+StorageManagerIdFactory::RemoveListener(Listener* aListener)
+{
+  AssertIsOnBackgroundThread();
+  MOZ_ASSERT(aListener);
+
+  MOZ_ALWAYS_TRUE(mListenerList.RemoveElement(aListener));
+}
+
+/**
+ * StorageManagerId
+ */
+
+// static
+nsresult
+StorageManagerId::Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  // The QuotaManager::GetInfoFromPrincipal() has special logic for system
+  // and about: principals.  We need to use the same modified origin in
+  // order to interpret calls from QM correctly.
+  nsCString quotaOrigin;
+  nsresult rv = quota::QuotaManager::GetInfoFromPrincipal(aPrincipal,
+                                                          nullptr,   //group
+                                                          &quotaOrigin,
+                                                          nullptr);  // is app
+  if (NS_WARN_IF(NS_FAILED(rv))) { return rv; }
+
+  RefPtr<StorageManagerId> ref =
+    new StorageManagerId(aPrincipal, quotaOrigin);
+  ref.forget(aManagerIdOut);
+
+  return NS_OK;
+}
+
+already_AddRefed<nsIPrincipal>
+StorageManagerId::Principal() const
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  nsCOMPtr<nsIPrincipal> ref = mPrincipal;
+  return ref.forget();
+}
+
+StorageManagerId::StorageManagerId(nsIPrincipal* aPrincipal,
+                                   const nsACString& aQuotaOrigin)
+    : mPrincipal(aPrincipal)
+    , mQuotaOrigin(aQuotaOrigin)
+{
+  MOZ_ASSERT(mPrincipal);
+}
+
+StorageManagerId::~StorageManagerId()
+{
+  // If we're already on the main thread, then default destruction is fine
+  if (NS_IsMainThread()) {
+    return;
+  }
+
+  // Otherwise we need to proxy to main thread to do the release
+
+  // The PBackground worker thread shouldn't be running after the main thread
+  // is stopped.  So main thread is guaranteed to exist here.
+  NS_ReleaseOnMainThread(mPrincipal.forget());
+}
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/backgroundsync/StorageManagerId.h b/dom/backgroundsync/StorageManagerId.h
new file mode 100644
--- /dev/null
+++ b/dom/backgroundsync/StorageManagerId.h
@@ -0,0 +1,92 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef mozilla_dom_StorageManagerId_h
+#define mozilla_dom_StorageManagerId_h
+
+namespace mozilla {
+namespace dom {
+
+using mozilla::ipc::PrincipalInfo;
+
+class StorageManagerId final
+{
+public:
+  // Main thread only.
+  static nsresult Create(nsIPrincipal* aPrincipal,
+                         StorageManagerId** aManagerIdOut);
+
+  // Main thread only.
+  already_AddRefed<nsIPrincipal> Principal() const;
+
+  const nsACString& QuotaOrigin() const { return mQuotaOrigin; }
+
+  bool operator==(const StorageManagerId& aOther) const
+  {
+    return mQuotaOrigin == aOther.mQuotaOrigin;
+  }
+
+private:
+  StorageManagerId(nsIPrincipal* aPrincipal, const nsACString& aOrigin);
+  ~StorageManagerId();
+
+  StorageManagerId(const StorageManagerId&) = delete;
+  StorageManagerId& operator=(const StorageManagerId&) = delete;
+
+  // Only accessible on main thread.
+  nsCOMPtr<nsIPrincipal> mPrincipal;
+
+  // Immutable to allow threadsafe access.
+  const nsCString mQuotaOrigin;
+
+public:
+  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(StorageManagerId)
+};
+
+class StorageManagerIdFactory : public Runnable
+{
+public:
+  // An interface to be implemented by code wishing to use the
+  // StorageManagerIdFactory.
+  // Note, the Listener implementation is responsible for calling
+  // RemoveListener() on the StorageManagerIdFactory to clear the weak
+  // reference.
+  class Listener
+  {
+  public:
+    virtual void OnStorageManagerIdCreated(StorageManagerId* aManagerId) = 0;
+  };
+
+  static already_AddRefed<StorageManagerIdFactory>
+  Create(Listener* aListener, const PrincipalInfo& aPrincipalInfo);
+
+  void AddListener(Listener* aListener);
+  // The Listener must call RemoveListener() when
+  // OnStorageManagerIdCreated is called or when
+  // the Listener is destroyed.
+  void RemoveListener(Listener* aListener);
+
+private:
+  StorageManagerIdFactory(Listener* aListener,
+                          const PrincipalInfo& aPrincipalInfo);
+  virtual ~StorageManagerIdFactory();
+
+  // Weak reference cleared by RemoveListener().
+  typedef nsTObserverArray<Listener*> ListenerList;
+  ListenerList mListenerList;
+
+  const PrincipalInfo mPrincipalInfo;
+  RefPtr<nsIThread> mInitiatingThread;
+  RefPtr<StorageManagerId> mManagerId;
+
+public:
+  NS_DECL_NSIRUNNABLE
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif // mozilla_dom_StorageManagerId_h
diff --git a/dom/backgroundsync/moz.build b/dom/backgroundsync/moz.build
--- a/dom/backgroundsync/moz.build
+++ b/dom/backgroundsync/moz.build
@@ -5,17 +5,20 @@
 
 EXPORTS.mozilla.dom += [
     'BackgroundSync.h'
 ]
 
 UNIFIED_SOURCES += [
     'BackgroundSync.cpp',
     'BackgroundSyncChild.cpp',
-    'BackgroundSyncParent.cpp'
+    'BackgroundSyncParent.cpp',
+    'StorageAction.cpp',
+    'StorageManager.cpp',
+    'StorageManagerId.cpp'
 ]
 
 IPDL_SOURCES += [
     'BackgroundSyncIPCTypes.ipdlh',
     'PBackgroundSync.ipdl'
 ]
 
 LOCAL_INCLUDES += [
diff --git a/ipc/glue/BackgroundChildImpl.cpp b/ipc/glue/BackgroundChildImpl.cpp
--- a/ipc/glue/BackgroundChildImpl.cpp
+++ b/ipc/glue/BackgroundChildImpl.cpp
@@ -470,17 +470,18 @@ BackgroundChildImpl::DeallocPFileSystemR
   return true;
 }
 
 // -----------------------------------------------------------------------------
 // Background Sync API
 // -----------------------------------------------------------------------------
 
 dom::PBackgroundSyncChild*
-BackgroundChildImpl::AllocPBackgroundSyncChild()
+BackgroundChildImpl::AllocPBackgroundSyncChild(
+    const PrincipalInfo& aPrincipalInfo)
 {
   RefPtr<BackgroundSyncChild> agent = new BackgroundSyncChild();
   return agent.forget().take();
 }
 
 bool
 BackgroundChildImpl::DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor)
 {
diff --git a/ipc/glue/BackgroundChildImpl.h b/ipc/glue/BackgroundChildImpl.h
--- a/ipc/glue/BackgroundChildImpl.h
+++ b/ipc/glue/BackgroundChildImpl.h
@@ -161,17 +161,17 @@ protected:
 
   virtual PFileSystemRequestChild*
   AllocPFileSystemRequestChild(const FileSystemParams&) override;
 
   virtual bool
   DeallocPFileSystemRequestChild(PFileSystemRequestChild*) override;
 
   virtual PBackgroundSyncChild*
-  AllocPBackgroundSyncChild() override;
+  AllocPBackgroundSyncChild(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncChild(PBackgroundSyncChild* aActor) override;
 };
 
 class BackgroundChildImpl::ThreadLocal final
 {
   friend class nsAutoPtr<ThreadLocal>;
diff --git a/ipc/glue/BackgroundParentImpl.cpp b/ipc/glue/BackgroundParentImpl.cpp
--- a/ipc/glue/BackgroundParentImpl.cpp
+++ b/ipc/glue/BackgroundParentImpl.cpp
@@ -889,32 +889,38 @@ BackgroundParentImpl::DeallocPFileSystem
   AssertIsOnBackgroundThread();
 
   RefPtr<FileSystemRequestParent> parent =
     dont_AddRef(static_cast<FileSystemRequestParent*>(aDoomed));
   return true;
 }
 
 mozilla::dom::PBackgroundSyncParent*
-BackgroundParentImpl::AllocPBackgroundSyncParent()
+BackgroundParentImpl::AllocPBackgroundSyncParent(
+    const PrincipalInfo& aPrincipalInfo)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
 
-  return new BackgroundSyncParent();
+  RefPtr<BackgroundSyncParent> agent =
+    new BackgroundSyncParent(aPrincipalInfo);
+  return agent.forget().take();
 }
 
 bool
 BackgroundParentImpl::DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor)
 {
   AssertIsInMainProcess();
   AssertIsOnBackgroundThread();
   MOZ_ASSERT(aActor);
 
-  delete static_cast<BackgroundSyncParent*>(aActor);
+  RefPtr<BackgroundSyncParent> parent =
+    dont_AddRef(static_cast<BackgroundSyncParent*>(aActor));
+  MOZ_ASSERT(parent);
+
   return true;
 }
 
 } // namespace ipc
 } // namespace mozilla
 
 void
 TestParent::ActorDestroy(ActorDestroyReason aWhy)
diff --git a/ipc/glue/BackgroundParentImpl.h b/ipc/glue/BackgroundParentImpl.h
--- a/ipc/glue/BackgroundParentImpl.h
+++ b/ipc/glue/BackgroundParentImpl.h
@@ -193,17 +193,17 @@ protected:
   virtual bool
   RecvPFileSystemRequestConstructor(PFileSystemRequestParent* aActor,
                                     const FileSystemParams& aParams) override;
 
   virtual bool
   DeallocPFileSystemRequestParent(PFileSystemRequestParent*) override;
 
   virtual PBackgroundSyncParent*
-  AllocPBackgroundSyncParent() override;
+  AllocPBackgroundSyncParent(const PrincipalInfo& aPrincipalInfo) override;
 
   virtual bool
   DeallocPBackgroundSyncParent(PBackgroundSyncParent* aActor) override;
 };
 
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/PBackground.ipdl b/ipc/glue/PBackground.ipdl
--- a/ipc/glue/PBackground.ipdl
+++ b/ipc/glue/PBackground.ipdl
@@ -97,17 +97,17 @@ parent:
   async PAsmJSCacheEntry(OpenMode openMode,
                          WriteParams write,
                          PrincipalInfo principalInfo);
 
   async PQuota();
 
   async PFileSystemRequest(FileSystemParams params);
 
-  async PBackgroundSync();
+  async PBackgroundSync(PrincipalInfo aPrincipalInfo);
 
 child:
   async PCache();
   async PCacheStreamControl();
 
 both:
   async PBlob(BlobConstructorParams params);
 
